// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tendermint/privval/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tendermint_2fprivval_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tendermint_2fprivval_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tendermint/crypto/keys.pb.h"
#include "tendermint/types/types.pb.h"
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tendermint_2fprivval_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tendermint_2fprivval_2ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tendermint_2fprivval_2ftypes_2eproto;
namespace tendermint {
namespace privval {
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class PubKeyRequest;
struct PubKeyRequestDefaultTypeInternal;
extern PubKeyRequestDefaultTypeInternal _PubKeyRequest_default_instance_;
class PubKeyResponse;
struct PubKeyResponseDefaultTypeInternal;
extern PubKeyResponseDefaultTypeInternal _PubKeyResponse_default_instance_;
class RemoteSignerError;
struct RemoteSignerErrorDefaultTypeInternal;
extern RemoteSignerErrorDefaultTypeInternal _RemoteSignerError_default_instance_;
class SignProposalRequest;
struct SignProposalRequestDefaultTypeInternal;
extern SignProposalRequestDefaultTypeInternal _SignProposalRequest_default_instance_;
class SignVoteRequest;
struct SignVoteRequestDefaultTypeInternal;
extern SignVoteRequestDefaultTypeInternal _SignVoteRequest_default_instance_;
class SignedProposalResponse;
struct SignedProposalResponseDefaultTypeInternal;
extern SignedProposalResponseDefaultTypeInternal _SignedProposalResponse_default_instance_;
class SignedVoteResponse;
struct SignedVoteResponseDefaultTypeInternal;
extern SignedVoteResponseDefaultTypeInternal _SignedVoteResponse_default_instance_;
}  // namespace privval
}  // namespace tendermint
PROTOBUF_NAMESPACE_OPEN
template<> ::tendermint::privval::Message* Arena::CreateMaybeMessage<::tendermint::privval::Message>(Arena*);
template<> ::tendermint::privval::PingRequest* Arena::CreateMaybeMessage<::tendermint::privval::PingRequest>(Arena*);
template<> ::tendermint::privval::PingResponse* Arena::CreateMaybeMessage<::tendermint::privval::PingResponse>(Arena*);
template<> ::tendermint::privval::PubKeyRequest* Arena::CreateMaybeMessage<::tendermint::privval::PubKeyRequest>(Arena*);
template<> ::tendermint::privval::PubKeyResponse* Arena::CreateMaybeMessage<::tendermint::privval::PubKeyResponse>(Arena*);
template<> ::tendermint::privval::RemoteSignerError* Arena::CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(Arena*);
template<> ::tendermint::privval::SignProposalRequest* Arena::CreateMaybeMessage<::tendermint::privval::SignProposalRequest>(Arena*);
template<> ::tendermint::privval::SignVoteRequest* Arena::CreateMaybeMessage<::tendermint::privval::SignVoteRequest>(Arena*);
template<> ::tendermint::privval::SignedProposalResponse* Arena::CreateMaybeMessage<::tendermint::privval::SignedProposalResponse>(Arena*);
template<> ::tendermint::privval::SignedVoteResponse* Arena::CreateMaybeMessage<::tendermint::privval::SignedVoteResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tendermint {
namespace privval {

enum Errors : int {
  ERRORS_UNKNOWN = 0,
  ERRORS_UNEXPECTED_RESPONSE = 1,
  ERRORS_NO_CONNECTION = 2,
  ERRORS_CONNECTION_TIMEOUT = 3,
  ERRORS_READ_TIMEOUT = 4,
  ERRORS_WRITE_TIMEOUT = 5,
  Errors_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Errors_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Errors_IsValid(int value);
constexpr Errors Errors_MIN = ERRORS_UNKNOWN;
constexpr Errors Errors_MAX = ERRORS_WRITE_TIMEOUT;
constexpr int Errors_ARRAYSIZE = Errors_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Errors_descriptor();
template<typename T>
inline const std::string& Errors_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Errors>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Errors_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Errors_descriptor(), enum_t_value);
}
inline bool Errors_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Errors* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Errors>(
    Errors_descriptor(), name, value);
}
// ===================================================================

class RemoteSignerError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.RemoteSignerError) */ {
 public:
  inline RemoteSignerError() : RemoteSignerError(nullptr) {}
  ~RemoteSignerError() override;
  explicit constexpr RemoteSignerError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteSignerError(const RemoteSignerError& from);
  RemoteSignerError(RemoteSignerError&& from) noexcept
    : RemoteSignerError() {
    *this = ::std::move(from);
  }

  inline RemoteSignerError& operator=(const RemoteSignerError& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteSignerError& operator=(RemoteSignerError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteSignerError& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteSignerError* internal_default_instance() {
    return reinterpret_cast<const RemoteSignerError*>(
               &_RemoteSignerError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RemoteSignerError& a, RemoteSignerError& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteSignerError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteSignerError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteSignerError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoteSignerError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteSignerError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoteSignerError& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteSignerError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.RemoteSignerError";
  }
  protected:
  explicit RemoteSignerError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.privval.RemoteSignerError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class PubKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.PubKeyRequest) */ {
 public:
  inline PubKeyRequest() : PubKeyRequest(nullptr) {}
  ~PubKeyRequest() override;
  explicit constexpr PubKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PubKeyRequest(const PubKeyRequest& from);
  PubKeyRequest(PubKeyRequest&& from) noexcept
    : PubKeyRequest() {
    *this = ::std::move(from);
  }

  inline PubKeyRequest& operator=(const PubKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubKeyRequest& operator=(PubKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PubKeyRequest* internal_default_instance() {
    return reinterpret_cast<const PubKeyRequest*>(
               &_PubKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PubKeyRequest& a, PubKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PubKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PubKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PubKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PubKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PubKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.PubKeyRequest";
  }
  protected:
  explicit PubKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 1,
  };
  // string chain_id = 1;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.privval.PubKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class PubKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.PubKeyResponse) */ {
 public:
  inline PubKeyResponse() : PubKeyResponse(nullptr) {}
  ~PubKeyResponse() override;
  explicit constexpr PubKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PubKeyResponse(const PubKeyResponse& from);
  PubKeyResponse(PubKeyResponse&& from) noexcept
    : PubKeyResponse() {
    *this = ::std::move(from);
  }

  inline PubKeyResponse& operator=(const PubKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PubKeyResponse& operator=(PubKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PubKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PubKeyResponse* internal_default_instance() {
    return reinterpret_cast<const PubKeyResponse*>(
               &_PubKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PubKeyResponse& a, PubKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PubKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PubKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PubKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PubKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PubKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PubKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PubKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.PubKeyResponse";
  }
  protected:
  explicit PubKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .tendermint.crypto.PublicKey pub_key = 1 [(.gogoproto.nullable) = false];
  bool has_pub_key() const;
  private:
  bool _internal_has_pub_key() const;
  public:
  void clear_pub_key();
  const ::tendermint::crypto::PublicKey& pub_key() const;
  PROTOBUF_NODISCARD ::tendermint::crypto::PublicKey* release_pub_key();
  ::tendermint::crypto::PublicKey* mutable_pub_key();
  void set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key);
  private:
  const ::tendermint::crypto::PublicKey& _internal_pub_key() const;
  ::tendermint::crypto::PublicKey* _internal_mutable_pub_key();
  public:
  void unsafe_arena_set_allocated_pub_key(
      ::tendermint::crypto::PublicKey* pub_key);
  ::tendermint::crypto::PublicKey* unsafe_arena_release_pub_key();

  // .tendermint.privval.RemoteSignerError error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::tendermint::privval::RemoteSignerError& error() const;
  PROTOBUF_NODISCARD ::tendermint::privval::RemoteSignerError* release_error();
  ::tendermint::privval::RemoteSignerError* mutable_error();
  void set_allocated_error(::tendermint::privval::RemoteSignerError* error);
  private:
  const ::tendermint::privval::RemoteSignerError& _internal_error() const;
  ::tendermint::privval::RemoteSignerError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tendermint::privval::RemoteSignerError* error);
  ::tendermint::privval::RemoteSignerError* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:tendermint.privval.PubKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tendermint::crypto::PublicKey* pub_key_;
  ::tendermint::privval::RemoteSignerError* error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignVoteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignVoteRequest) */ {
 public:
  inline SignVoteRequest() : SignVoteRequest(nullptr) {}
  ~SignVoteRequest() override;
  explicit constexpr SignVoteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignVoteRequest(const SignVoteRequest& from);
  SignVoteRequest(SignVoteRequest&& from) noexcept
    : SignVoteRequest() {
    *this = ::std::move(from);
  }

  inline SignVoteRequest& operator=(const SignVoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignVoteRequest& operator=(SignVoteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignVoteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignVoteRequest* internal_default_instance() {
    return reinterpret_cast<const SignVoteRequest*>(
               &_SignVoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SignVoteRequest& a, SignVoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignVoteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignVoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignVoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignVoteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignVoteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignVoteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignVoteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.SignVoteRequest";
  }
  protected:
  explicit SignVoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 2,
    kVoteFieldNumber = 1,
  };
  // string chain_id = 2;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // .tendermint.types.Vote vote = 1;
  bool has_vote() const;
  private:
  bool _internal_has_vote() const;
  public:
  void clear_vote();
  const ::tendermint::types::Vote& vote() const;
  PROTOBUF_NODISCARD ::tendermint::types::Vote* release_vote();
  ::tendermint::types::Vote* mutable_vote();
  void set_allocated_vote(::tendermint::types::Vote* vote);
  private:
  const ::tendermint::types::Vote& _internal_vote() const;
  ::tendermint::types::Vote* _internal_mutable_vote();
  public:
  void unsafe_arena_set_allocated_vote(
      ::tendermint::types::Vote* vote);
  ::tendermint::types::Vote* unsafe_arena_release_vote();

  // @@protoc_insertion_point(class_scope:tendermint.privval.SignVoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
  ::tendermint::types::Vote* vote_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignedVoteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignedVoteResponse) */ {
 public:
  inline SignedVoteResponse() : SignedVoteResponse(nullptr) {}
  ~SignedVoteResponse() override;
  explicit constexpr SignedVoteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedVoteResponse(const SignedVoteResponse& from);
  SignedVoteResponse(SignedVoteResponse&& from) noexcept
    : SignedVoteResponse() {
    *this = ::std::move(from);
  }

  inline SignedVoteResponse& operator=(const SignedVoteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedVoteResponse& operator=(SignedVoteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedVoteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedVoteResponse* internal_default_instance() {
    return reinterpret_cast<const SignedVoteResponse*>(
               &_SignedVoteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SignedVoteResponse& a, SignedVoteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedVoteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedVoteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedVoteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedVoteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedVoteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignedVoteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedVoteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.SignedVoteResponse";
  }
  protected:
  explicit SignedVoteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoteFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .tendermint.types.Vote vote = 1 [(.gogoproto.nullable) = false];
  bool has_vote() const;
  private:
  bool _internal_has_vote() const;
  public:
  void clear_vote();
  const ::tendermint::types::Vote& vote() const;
  PROTOBUF_NODISCARD ::tendermint::types::Vote* release_vote();
  ::tendermint::types::Vote* mutable_vote();
  void set_allocated_vote(::tendermint::types::Vote* vote);
  private:
  const ::tendermint::types::Vote& _internal_vote() const;
  ::tendermint::types::Vote* _internal_mutable_vote();
  public:
  void unsafe_arena_set_allocated_vote(
      ::tendermint::types::Vote* vote);
  ::tendermint::types::Vote* unsafe_arena_release_vote();

  // .tendermint.privval.RemoteSignerError error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::tendermint::privval::RemoteSignerError& error() const;
  PROTOBUF_NODISCARD ::tendermint::privval::RemoteSignerError* release_error();
  ::tendermint::privval::RemoteSignerError* mutable_error();
  void set_allocated_error(::tendermint::privval::RemoteSignerError* error);
  private:
  const ::tendermint::privval::RemoteSignerError& _internal_error() const;
  ::tendermint::privval::RemoteSignerError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tendermint::privval::RemoteSignerError* error);
  ::tendermint::privval::RemoteSignerError* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:tendermint.privval.SignedVoteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tendermint::types::Vote* vote_;
  ::tendermint::privval::RemoteSignerError* error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignProposalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignProposalRequest) */ {
 public:
  inline SignProposalRequest() : SignProposalRequest(nullptr) {}
  ~SignProposalRequest() override;
  explicit constexpr SignProposalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignProposalRequest(const SignProposalRequest& from);
  SignProposalRequest(SignProposalRequest&& from) noexcept
    : SignProposalRequest() {
    *this = ::std::move(from);
  }

  inline SignProposalRequest& operator=(const SignProposalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignProposalRequest& operator=(SignProposalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignProposalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignProposalRequest* internal_default_instance() {
    return reinterpret_cast<const SignProposalRequest*>(
               &_SignProposalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SignProposalRequest& a, SignProposalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignProposalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignProposalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignProposalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignProposalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignProposalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignProposalRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignProposalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.SignProposalRequest";
  }
  protected:
  explicit SignProposalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 2,
    kProposalFieldNumber = 1,
  };
  // string chain_id = 2;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // .tendermint.types.Proposal proposal = 1;
  bool has_proposal() const;
  private:
  bool _internal_has_proposal() const;
  public:
  void clear_proposal();
  const ::tendermint::types::Proposal& proposal() const;
  PROTOBUF_NODISCARD ::tendermint::types::Proposal* release_proposal();
  ::tendermint::types::Proposal* mutable_proposal();
  void set_allocated_proposal(::tendermint::types::Proposal* proposal);
  private:
  const ::tendermint::types::Proposal& _internal_proposal() const;
  ::tendermint::types::Proposal* _internal_mutable_proposal();
  public:
  void unsafe_arena_set_allocated_proposal(
      ::tendermint::types::Proposal* proposal);
  ::tendermint::types::Proposal* unsafe_arena_release_proposal();

  // @@protoc_insertion_point(class_scope:tendermint.privval.SignProposalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
  ::tendermint::types::Proposal* proposal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class SignedProposalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.SignedProposalResponse) */ {
 public:
  inline SignedProposalResponse() : SignedProposalResponse(nullptr) {}
  ~SignedProposalResponse() override;
  explicit constexpr SignedProposalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignedProposalResponse(const SignedProposalResponse& from);
  SignedProposalResponse(SignedProposalResponse&& from) noexcept
    : SignedProposalResponse() {
    *this = ::std::move(from);
  }

  inline SignedProposalResponse& operator=(const SignedProposalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedProposalResponse& operator=(SignedProposalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignedProposalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignedProposalResponse* internal_default_instance() {
    return reinterpret_cast<const SignedProposalResponse*>(
               &_SignedProposalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SignedProposalResponse& a, SignedProposalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedProposalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedProposalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignedProposalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignedProposalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignedProposalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignedProposalResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedProposalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.SignedProposalResponse";
  }
  protected:
  explicit SignedProposalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProposalFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .tendermint.types.Proposal proposal = 1 [(.gogoproto.nullable) = false];
  bool has_proposal() const;
  private:
  bool _internal_has_proposal() const;
  public:
  void clear_proposal();
  const ::tendermint::types::Proposal& proposal() const;
  PROTOBUF_NODISCARD ::tendermint::types::Proposal* release_proposal();
  ::tendermint::types::Proposal* mutable_proposal();
  void set_allocated_proposal(::tendermint::types::Proposal* proposal);
  private:
  const ::tendermint::types::Proposal& _internal_proposal() const;
  ::tendermint::types::Proposal* _internal_mutable_proposal();
  public:
  void unsafe_arena_set_allocated_proposal(
      ::tendermint::types::Proposal* proposal);
  ::tendermint::types::Proposal* unsafe_arena_release_proposal();

  // .tendermint.privval.RemoteSignerError error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::tendermint::privval::RemoteSignerError& error() const;
  PROTOBUF_NODISCARD ::tendermint::privval::RemoteSignerError* release_error();
  ::tendermint::privval::RemoteSignerError* mutable_error();
  void set_allocated_error(::tendermint::privval::RemoteSignerError* error);
  private:
  const ::tendermint::privval::RemoteSignerError& _internal_error() const;
  ::tendermint::privval::RemoteSignerError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tendermint::privval::RemoteSignerError* error);
  ::tendermint::privval::RemoteSignerError* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:tendermint.privval.SignedProposalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tendermint::types::Proposal* proposal_;
  ::tendermint::privval::RemoteSignerError* error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.privval.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  explicit constexpr PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.privval.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.privval.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  explicit constexpr PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PingResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.privval.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.privval.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit constexpr Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum SumCase {
    kPubKeyRequest = 1,
    kPubKeyResponse = 2,
    kSignVoteRequest = 3,
    kSignedVoteResponse = 4,
    kSignProposalRequest = 5,
    kSignedProposalResponse = 6,
    kPingRequest = 7,
    kPingResponse = 8,
    SUM_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Message& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.privval.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyRequestFieldNumber = 1,
    kPubKeyResponseFieldNumber = 2,
    kSignVoteRequestFieldNumber = 3,
    kSignedVoteResponseFieldNumber = 4,
    kSignProposalRequestFieldNumber = 5,
    kSignedProposalResponseFieldNumber = 6,
    kPingRequestFieldNumber = 7,
    kPingResponseFieldNumber = 8,
  };
  // .tendermint.privval.PubKeyRequest pub_key_request = 1;
  bool has_pub_key_request() const;
  private:
  bool _internal_has_pub_key_request() const;
  public:
  void clear_pub_key_request();
  const ::tendermint::privval::PubKeyRequest& pub_key_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PubKeyRequest* release_pub_key_request();
  ::tendermint::privval::PubKeyRequest* mutable_pub_key_request();
  void set_allocated_pub_key_request(::tendermint::privval::PubKeyRequest* pub_key_request);
  private:
  const ::tendermint::privval::PubKeyRequest& _internal_pub_key_request() const;
  ::tendermint::privval::PubKeyRequest* _internal_mutable_pub_key_request();
  public:
  void unsafe_arena_set_allocated_pub_key_request(
      ::tendermint::privval::PubKeyRequest* pub_key_request);
  ::tendermint::privval::PubKeyRequest* unsafe_arena_release_pub_key_request();

  // .tendermint.privval.PubKeyResponse pub_key_response = 2;
  bool has_pub_key_response() const;
  private:
  bool _internal_has_pub_key_response() const;
  public:
  void clear_pub_key_response();
  const ::tendermint::privval::PubKeyResponse& pub_key_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PubKeyResponse* release_pub_key_response();
  ::tendermint::privval::PubKeyResponse* mutable_pub_key_response();
  void set_allocated_pub_key_response(::tendermint::privval::PubKeyResponse* pub_key_response);
  private:
  const ::tendermint::privval::PubKeyResponse& _internal_pub_key_response() const;
  ::tendermint::privval::PubKeyResponse* _internal_mutable_pub_key_response();
  public:
  void unsafe_arena_set_allocated_pub_key_response(
      ::tendermint::privval::PubKeyResponse* pub_key_response);
  ::tendermint::privval::PubKeyResponse* unsafe_arena_release_pub_key_response();

  // .tendermint.privval.SignVoteRequest sign_vote_request = 3;
  bool has_sign_vote_request() const;
  private:
  bool _internal_has_sign_vote_request() const;
  public:
  void clear_sign_vote_request();
  const ::tendermint::privval::SignVoteRequest& sign_vote_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignVoteRequest* release_sign_vote_request();
  ::tendermint::privval::SignVoteRequest* mutable_sign_vote_request();
  void set_allocated_sign_vote_request(::tendermint::privval::SignVoteRequest* sign_vote_request);
  private:
  const ::tendermint::privval::SignVoteRequest& _internal_sign_vote_request() const;
  ::tendermint::privval::SignVoteRequest* _internal_mutable_sign_vote_request();
  public:
  void unsafe_arena_set_allocated_sign_vote_request(
      ::tendermint::privval::SignVoteRequest* sign_vote_request);
  ::tendermint::privval::SignVoteRequest* unsafe_arena_release_sign_vote_request();

  // .tendermint.privval.SignedVoteResponse signed_vote_response = 4;
  bool has_signed_vote_response() const;
  private:
  bool _internal_has_signed_vote_response() const;
  public:
  void clear_signed_vote_response();
  const ::tendermint::privval::SignedVoteResponse& signed_vote_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignedVoteResponse* release_signed_vote_response();
  ::tendermint::privval::SignedVoteResponse* mutable_signed_vote_response();
  void set_allocated_signed_vote_response(::tendermint::privval::SignedVoteResponse* signed_vote_response);
  private:
  const ::tendermint::privval::SignedVoteResponse& _internal_signed_vote_response() const;
  ::tendermint::privval::SignedVoteResponse* _internal_mutable_signed_vote_response();
  public:
  void unsafe_arena_set_allocated_signed_vote_response(
      ::tendermint::privval::SignedVoteResponse* signed_vote_response);
  ::tendermint::privval::SignedVoteResponse* unsafe_arena_release_signed_vote_response();

  // .tendermint.privval.SignProposalRequest sign_proposal_request = 5;
  bool has_sign_proposal_request() const;
  private:
  bool _internal_has_sign_proposal_request() const;
  public:
  void clear_sign_proposal_request();
  const ::tendermint::privval::SignProposalRequest& sign_proposal_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignProposalRequest* release_sign_proposal_request();
  ::tendermint::privval::SignProposalRequest* mutable_sign_proposal_request();
  void set_allocated_sign_proposal_request(::tendermint::privval::SignProposalRequest* sign_proposal_request);
  private:
  const ::tendermint::privval::SignProposalRequest& _internal_sign_proposal_request() const;
  ::tendermint::privval::SignProposalRequest* _internal_mutable_sign_proposal_request();
  public:
  void unsafe_arena_set_allocated_sign_proposal_request(
      ::tendermint::privval::SignProposalRequest* sign_proposal_request);
  ::tendermint::privval::SignProposalRequest* unsafe_arena_release_sign_proposal_request();

  // .tendermint.privval.SignedProposalResponse signed_proposal_response = 6;
  bool has_signed_proposal_response() const;
  private:
  bool _internal_has_signed_proposal_response() const;
  public:
  void clear_signed_proposal_response();
  const ::tendermint::privval::SignedProposalResponse& signed_proposal_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::SignedProposalResponse* release_signed_proposal_response();
  ::tendermint::privval::SignedProposalResponse* mutable_signed_proposal_response();
  void set_allocated_signed_proposal_response(::tendermint::privval::SignedProposalResponse* signed_proposal_response);
  private:
  const ::tendermint::privval::SignedProposalResponse& _internal_signed_proposal_response() const;
  ::tendermint::privval::SignedProposalResponse* _internal_mutable_signed_proposal_response();
  public:
  void unsafe_arena_set_allocated_signed_proposal_response(
      ::tendermint::privval::SignedProposalResponse* signed_proposal_response);
  ::tendermint::privval::SignedProposalResponse* unsafe_arena_release_signed_proposal_response();

  // .tendermint.privval.PingRequest ping_request = 7;
  bool has_ping_request() const;
  private:
  bool _internal_has_ping_request() const;
  public:
  void clear_ping_request();
  const ::tendermint::privval::PingRequest& ping_request() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PingRequest* release_ping_request();
  ::tendermint::privval::PingRequest* mutable_ping_request();
  void set_allocated_ping_request(::tendermint::privval::PingRequest* ping_request);
  private:
  const ::tendermint::privval::PingRequest& _internal_ping_request() const;
  ::tendermint::privval::PingRequest* _internal_mutable_ping_request();
  public:
  void unsafe_arena_set_allocated_ping_request(
      ::tendermint::privval::PingRequest* ping_request);
  ::tendermint::privval::PingRequest* unsafe_arena_release_ping_request();

  // .tendermint.privval.PingResponse ping_response = 8;
  bool has_ping_response() const;
  private:
  bool _internal_has_ping_response() const;
  public:
  void clear_ping_response();
  const ::tendermint::privval::PingResponse& ping_response() const;
  PROTOBUF_NODISCARD ::tendermint::privval::PingResponse* release_ping_response();
  ::tendermint::privval::PingResponse* mutable_ping_response();
  void set_allocated_ping_response(::tendermint::privval::PingResponse* ping_response);
  private:
  const ::tendermint::privval::PingResponse& _internal_ping_response() const;
  ::tendermint::privval::PingResponse* _internal_mutable_ping_response();
  public:
  void unsafe_arena_set_allocated_ping_response(
      ::tendermint::privval::PingResponse* ping_response);
  ::tendermint::privval::PingResponse* unsafe_arena_release_ping_response();

  void clear_sum();
  SumCase sum_case() const;
  // @@protoc_insertion_point(class_scope:tendermint.privval.Message)
 private:
  class _Internal;
  void set_has_pub_key_request();
  void set_has_pub_key_response();
  void set_has_sign_vote_request();
  void set_has_signed_vote_response();
  void set_has_sign_proposal_request();
  void set_has_signed_proposal_response();
  void set_has_ping_request();
  void set_has_ping_response();

  inline bool has_sum() const;
  inline void clear_has_sum();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union SumUnion {
    constexpr SumUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tendermint::privval::PubKeyRequest* pub_key_request_;
    ::tendermint::privval::PubKeyResponse* pub_key_response_;
    ::tendermint::privval::SignVoteRequest* sign_vote_request_;
    ::tendermint::privval::SignedVoteResponse* signed_vote_response_;
    ::tendermint::privval::SignProposalRequest* sign_proposal_request_;
    ::tendermint::privval::SignedProposalResponse* signed_proposal_response_;
    ::tendermint::privval::PingRequest* ping_request_;
    ::tendermint::privval::PingResponse* ping_response_;
  } sum_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tendermint_2fprivval_2ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RemoteSignerError

// int32 code = 1;
inline void RemoteSignerError::clear_code() {
  code_ = 0;
}
inline int32_t RemoteSignerError::_internal_code() const {
  return code_;
}
inline int32_t RemoteSignerError::code() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.RemoteSignerError.code)
  return _internal_code();
}
inline void RemoteSignerError::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void RemoteSignerError::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.privval.RemoteSignerError.code)
}

// string description = 2;
inline void RemoteSignerError::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& RemoteSignerError::description() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.RemoteSignerError.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteSignerError::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.RemoteSignerError.description)
}
inline std::string* RemoteSignerError::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.RemoteSignerError.description)
  return _s;
}
inline const std::string& RemoteSignerError::_internal_description() const {
  return description_.Get();
}
inline void RemoteSignerError::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoteSignerError::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoteSignerError::release_description() {
  // @@protoc_insertion_point(field_release:tendermint.privval.RemoteSignerError.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoteSignerError::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.RemoteSignerError.description)
}

// -------------------------------------------------------------------

// PubKeyRequest

// string chain_id = 1;
inline void PubKeyRequest::clear_chain_id() {
  chain_id_.ClearToEmpty();
}
inline const std::string& PubKeyRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.PubKeyRequest.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PubKeyRequest::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.PubKeyRequest.chain_id)
}
inline std::string* PubKeyRequest::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.PubKeyRequest.chain_id)
  return _s;
}
inline const std::string& PubKeyRequest::_internal_chain_id() const {
  return chain_id_.Get();
}
inline void PubKeyRequest::_internal_set_chain_id(const std::string& value) {
  
  chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PubKeyRequest::_internal_mutable_chain_id() {
  
  return chain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PubKeyRequest::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.privval.PubKeyRequest.chain_id)
  return chain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PubKeyRequest::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chain_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chain_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chain_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.PubKeyRequest.chain_id)
}

// -------------------------------------------------------------------

// PubKeyResponse

// .tendermint.crypto.PublicKey pub_key = 1 [(.gogoproto.nullable) = false];
inline bool PubKeyResponse::_internal_has_pub_key() const {
  return this != internal_default_instance() && pub_key_ != nullptr;
}
inline bool PubKeyResponse::has_pub_key() const {
  return _internal_has_pub_key();
}
inline const ::tendermint::crypto::PublicKey& PubKeyResponse::_internal_pub_key() const {
  const ::tendermint::crypto::PublicKey* p = pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::crypto::PublicKey&>(
      ::tendermint::crypto::_PublicKey_default_instance_);
}
inline const ::tendermint::crypto::PublicKey& PubKeyResponse::pub_key() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.PubKeyResponse.pub_key)
  return _internal_pub_key();
}
inline void PubKeyResponse::unsafe_arena_set_allocated_pub_key(
    ::tendermint::crypto::PublicKey* pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key_);
  }
  pub_key_ = pub_key;
  if (pub_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.PubKeyResponse.pub_key)
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::release_pub_key() {
  
  ::tendermint::crypto::PublicKey* temp = pub_key_;
  pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::unsafe_arena_release_pub_key() {
  // @@protoc_insertion_point(field_release:tendermint.privval.PubKeyResponse.pub_key)
  
  ::tendermint::crypto::PublicKey* temp = pub_key_;
  pub_key_ = nullptr;
  return temp;
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::_internal_mutable_pub_key() {
  
  if (pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::crypto::PublicKey>(GetArenaForAllocation());
    pub_key_ = p;
  }
  return pub_key_;
}
inline ::tendermint::crypto::PublicKey* PubKeyResponse::mutable_pub_key() {
  ::tendermint::crypto::PublicKey* _msg = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.PubKeyResponse.pub_key)
  return _msg;
}
inline void PubKeyResponse::set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key_);
  }
  if (pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key));
    if (message_arena != submessage_arena) {
      pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pub_key, submessage_arena);
    }
    
  } else {
    
  }
  pub_key_ = pub_key;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.PubKeyResponse.pub_key)
}

// .tendermint.privval.RemoteSignerError error = 2;
inline bool PubKeyResponse::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool PubKeyResponse::has_error() const {
  return _internal_has_error();
}
inline void PubKeyResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::tendermint::privval::RemoteSignerError& PubKeyResponse::_internal_error() const {
  const ::tendermint::privval::RemoteSignerError* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::privval::RemoteSignerError&>(
      ::tendermint::privval::_RemoteSignerError_default_instance_);
}
inline const ::tendermint::privval::RemoteSignerError& PubKeyResponse::error() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.PubKeyResponse.error)
  return _internal_error();
}
inline void PubKeyResponse::unsafe_arena_set_allocated_error(
    ::tendermint::privval::RemoteSignerError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.PubKeyResponse.error)
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::release_error() {
  
  ::tendermint::privval::RemoteSignerError* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tendermint.privval.PubKeyResponse.error)
  
  ::tendermint::privval::RemoteSignerError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::tendermint::privval::RemoteSignerError* PubKeyResponse::mutable_error() {
  ::tendermint::privval::RemoteSignerError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.PubKeyResponse.error)
  return _msg;
}
inline void PubKeyResponse::set_allocated_error(::tendermint::privval::RemoteSignerError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::privval::RemoteSignerError>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.PubKeyResponse.error)
}

// -------------------------------------------------------------------

// SignVoteRequest

// .tendermint.types.Vote vote = 1;
inline bool SignVoteRequest::_internal_has_vote() const {
  return this != internal_default_instance() && vote_ != nullptr;
}
inline bool SignVoteRequest::has_vote() const {
  return _internal_has_vote();
}
inline const ::tendermint::types::Vote& SignVoteRequest::_internal_vote() const {
  const ::tendermint::types::Vote* p = vote_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Vote&>(
      ::tendermint::types::_Vote_default_instance_);
}
inline const ::tendermint::types::Vote& SignVoteRequest::vote() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignVoteRequest.vote)
  return _internal_vote();
}
inline void SignVoteRequest::unsafe_arena_set_allocated_vote(
    ::tendermint::types::Vote* vote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote_);
  }
  vote_ = vote;
  if (vote) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignVoteRequest.vote)
}
inline ::tendermint::types::Vote* SignVoteRequest::release_vote() {
  
  ::tendermint::types::Vote* temp = vote_;
  vote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Vote* SignVoteRequest::unsafe_arena_release_vote() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignVoteRequest.vote)
  
  ::tendermint::types::Vote* temp = vote_;
  vote_ = nullptr;
  return temp;
}
inline ::tendermint::types::Vote* SignVoteRequest::_internal_mutable_vote() {
  
  if (vote_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Vote>(GetArenaForAllocation());
    vote_ = p;
  }
  return vote_;
}
inline ::tendermint::types::Vote* SignVoteRequest::mutable_vote() {
  ::tendermint::types::Vote* _msg = _internal_mutable_vote();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignVoteRequest.vote)
  return _msg;
}
inline void SignVoteRequest::set_allocated_vote(::tendermint::types::Vote* vote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote_);
  }
  if (vote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote));
    if (message_arena != submessage_arena) {
      vote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vote, submessage_arena);
    }
    
  } else {
    
  }
  vote_ = vote;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignVoteRequest.vote)
}

// string chain_id = 2;
inline void SignVoteRequest::clear_chain_id() {
  chain_id_.ClearToEmpty();
}
inline const std::string& SignVoteRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignVoteRequest.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignVoteRequest::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.SignVoteRequest.chain_id)
}
inline std::string* SignVoteRequest::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignVoteRequest.chain_id)
  return _s;
}
inline const std::string& SignVoteRequest::_internal_chain_id() const {
  return chain_id_.Get();
}
inline void SignVoteRequest::_internal_set_chain_id(const std::string& value) {
  
  chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignVoteRequest::_internal_mutable_chain_id() {
  
  return chain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignVoteRequest::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignVoteRequest.chain_id)
  return chain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignVoteRequest::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chain_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chain_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chain_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignVoteRequest.chain_id)
}

// -------------------------------------------------------------------

// SignedVoteResponse

// .tendermint.types.Vote vote = 1 [(.gogoproto.nullable) = false];
inline bool SignedVoteResponse::_internal_has_vote() const {
  return this != internal_default_instance() && vote_ != nullptr;
}
inline bool SignedVoteResponse::has_vote() const {
  return _internal_has_vote();
}
inline const ::tendermint::types::Vote& SignedVoteResponse::_internal_vote() const {
  const ::tendermint::types::Vote* p = vote_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Vote&>(
      ::tendermint::types::_Vote_default_instance_);
}
inline const ::tendermint::types::Vote& SignedVoteResponse::vote() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedVoteResponse.vote)
  return _internal_vote();
}
inline void SignedVoteResponse::unsafe_arena_set_allocated_vote(
    ::tendermint::types::Vote* vote) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote_);
  }
  vote_ = vote;
  if (vote) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedVoteResponse.vote)
}
inline ::tendermint::types::Vote* SignedVoteResponse::release_vote() {
  
  ::tendermint::types::Vote* temp = vote_;
  vote_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Vote* SignedVoteResponse::unsafe_arena_release_vote() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedVoteResponse.vote)
  
  ::tendermint::types::Vote* temp = vote_;
  vote_ = nullptr;
  return temp;
}
inline ::tendermint::types::Vote* SignedVoteResponse::_internal_mutable_vote() {
  
  if (vote_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Vote>(GetArenaForAllocation());
    vote_ = p;
  }
  return vote_;
}
inline ::tendermint::types::Vote* SignedVoteResponse::mutable_vote() {
  ::tendermint::types::Vote* _msg = _internal_mutable_vote();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedVoteResponse.vote)
  return _msg;
}
inline void SignedVoteResponse::set_allocated_vote(::tendermint::types::Vote* vote) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote_);
  }
  if (vote) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vote));
    if (message_arena != submessage_arena) {
      vote = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vote, submessage_arena);
    }
    
  } else {
    
  }
  vote_ = vote;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedVoteResponse.vote)
}

// .tendermint.privval.RemoteSignerError error = 2;
inline bool SignedVoteResponse::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool SignedVoteResponse::has_error() const {
  return _internal_has_error();
}
inline void SignedVoteResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::tendermint::privval::RemoteSignerError& SignedVoteResponse::_internal_error() const {
  const ::tendermint::privval::RemoteSignerError* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::privval::RemoteSignerError&>(
      ::tendermint::privval::_RemoteSignerError_default_instance_);
}
inline const ::tendermint::privval::RemoteSignerError& SignedVoteResponse::error() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedVoteResponse.error)
  return _internal_error();
}
inline void SignedVoteResponse::unsafe_arena_set_allocated_error(
    ::tendermint::privval::RemoteSignerError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedVoteResponse.error)
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::release_error() {
  
  ::tendermint::privval::RemoteSignerError* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedVoteResponse.error)
  
  ::tendermint::privval::RemoteSignerError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::tendermint::privval::RemoteSignerError* SignedVoteResponse::mutable_error() {
  ::tendermint::privval::RemoteSignerError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedVoteResponse.error)
  return _msg;
}
inline void SignedVoteResponse::set_allocated_error(::tendermint::privval::RemoteSignerError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::privval::RemoteSignerError>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedVoteResponse.error)
}

// -------------------------------------------------------------------

// SignProposalRequest

// .tendermint.types.Proposal proposal = 1;
inline bool SignProposalRequest::_internal_has_proposal() const {
  return this != internal_default_instance() && proposal_ != nullptr;
}
inline bool SignProposalRequest::has_proposal() const {
  return _internal_has_proposal();
}
inline const ::tendermint::types::Proposal& SignProposalRequest::_internal_proposal() const {
  const ::tendermint::types::Proposal* p = proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Proposal&>(
      ::tendermint::types::_Proposal_default_instance_);
}
inline const ::tendermint::types::Proposal& SignProposalRequest::proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignProposalRequest.proposal)
  return _internal_proposal();
}
inline void SignProposalRequest::unsafe_arena_set_allocated_proposal(
    ::tendermint::types::Proposal* proposal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal_);
  }
  proposal_ = proposal;
  if (proposal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignProposalRequest.proposal)
}
inline ::tendermint::types::Proposal* SignProposalRequest::release_proposal() {
  
  ::tendermint::types::Proposal* temp = proposal_;
  proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Proposal* SignProposalRequest::unsafe_arena_release_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignProposalRequest.proposal)
  
  ::tendermint::types::Proposal* temp = proposal_;
  proposal_ = nullptr;
  return temp;
}
inline ::tendermint::types::Proposal* SignProposalRequest::_internal_mutable_proposal() {
  
  if (proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Proposal>(GetArenaForAllocation());
    proposal_ = p;
  }
  return proposal_;
}
inline ::tendermint::types::Proposal* SignProposalRequest::mutable_proposal() {
  ::tendermint::types::Proposal* _msg = _internal_mutable_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignProposalRequest.proposal)
  return _msg;
}
inline void SignProposalRequest::set_allocated_proposal(::tendermint::types::Proposal* proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal_);
  }
  if (proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal));
    if (message_arena != submessage_arena) {
      proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }
    
  } else {
    
  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignProposalRequest.proposal)
}

// string chain_id = 2;
inline void SignProposalRequest::clear_chain_id() {
  chain_id_.ClearToEmpty();
}
inline const std::string& SignProposalRequest::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignProposalRequest.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignProposalRequest::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.privval.SignProposalRequest.chain_id)
}
inline std::string* SignProposalRequest::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignProposalRequest.chain_id)
  return _s;
}
inline const std::string& SignProposalRequest::_internal_chain_id() const {
  return chain_id_.Get();
}
inline void SignProposalRequest::_internal_set_chain_id(const std::string& value) {
  
  chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignProposalRequest::_internal_mutable_chain_id() {
  
  return chain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignProposalRequest::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignProposalRequest.chain_id)
  return chain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignProposalRequest::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chain_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chain_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chain_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignProposalRequest.chain_id)
}

// -------------------------------------------------------------------

// SignedProposalResponse

// .tendermint.types.Proposal proposal = 1 [(.gogoproto.nullable) = false];
inline bool SignedProposalResponse::_internal_has_proposal() const {
  return this != internal_default_instance() && proposal_ != nullptr;
}
inline bool SignedProposalResponse::has_proposal() const {
  return _internal_has_proposal();
}
inline const ::tendermint::types::Proposal& SignedProposalResponse::_internal_proposal() const {
  const ::tendermint::types::Proposal* p = proposal_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Proposal&>(
      ::tendermint::types::_Proposal_default_instance_);
}
inline const ::tendermint::types::Proposal& SignedProposalResponse::proposal() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedProposalResponse.proposal)
  return _internal_proposal();
}
inline void SignedProposalResponse::unsafe_arena_set_allocated_proposal(
    ::tendermint::types::Proposal* proposal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal_);
  }
  proposal_ = proposal;
  if (proposal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedProposalResponse.proposal)
}
inline ::tendermint::types::Proposal* SignedProposalResponse::release_proposal() {
  
  ::tendermint::types::Proposal* temp = proposal_;
  proposal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Proposal* SignedProposalResponse::unsafe_arena_release_proposal() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedProposalResponse.proposal)
  
  ::tendermint::types::Proposal* temp = proposal_;
  proposal_ = nullptr;
  return temp;
}
inline ::tendermint::types::Proposal* SignedProposalResponse::_internal_mutable_proposal() {
  
  if (proposal_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Proposal>(GetArenaForAllocation());
    proposal_ = p;
  }
  return proposal_;
}
inline ::tendermint::types::Proposal* SignedProposalResponse::mutable_proposal() {
  ::tendermint::types::Proposal* _msg = _internal_mutable_proposal();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedProposalResponse.proposal)
  return _msg;
}
inline void SignedProposalResponse::set_allocated_proposal(::tendermint::types::Proposal* proposal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal_);
  }
  if (proposal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal));
    if (message_arena != submessage_arena) {
      proposal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposal, submessage_arena);
    }
    
  } else {
    
  }
  proposal_ = proposal;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedProposalResponse.proposal)
}

// .tendermint.privval.RemoteSignerError error = 2;
inline bool SignedProposalResponse::_internal_has_error() const {
  return this != internal_default_instance() && error_ != nullptr;
}
inline bool SignedProposalResponse::has_error() const {
  return _internal_has_error();
}
inline void SignedProposalResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && error_ != nullptr) {
    delete error_;
  }
  error_ = nullptr;
}
inline const ::tendermint::privval::RemoteSignerError& SignedProposalResponse::_internal_error() const {
  const ::tendermint::privval::RemoteSignerError* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::privval::RemoteSignerError&>(
      ::tendermint::privval::_RemoteSignerError_default_instance_);
}
inline const ::tendermint::privval::RemoteSignerError& SignedProposalResponse::error() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.SignedProposalResponse.error)
  return _internal_error();
}
inline void SignedProposalResponse::unsafe_arena_set_allocated_error(
    ::tendermint::privval::RemoteSignerError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.SignedProposalResponse.error)
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::release_error() {
  
  ::tendermint::privval::RemoteSignerError* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tendermint.privval.SignedProposalResponse.error)
  
  ::tendermint::privval::RemoteSignerError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::_internal_mutable_error() {
  
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::privval::RemoteSignerError>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::tendermint::privval::RemoteSignerError* SignedProposalResponse::mutable_error() {
  ::tendermint::privval::RemoteSignerError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.SignedProposalResponse.error)
  return _msg;
}
inline void SignedProposalResponse::set_allocated_error(::tendermint::privval::RemoteSignerError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::privval::RemoteSignerError>::GetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tendermint.privval.SignedProposalResponse.error)
}

// -------------------------------------------------------------------

// PingRequest

// -------------------------------------------------------------------

// PingResponse

// -------------------------------------------------------------------

// Message

// .tendermint.privval.PubKeyRequest pub_key_request = 1;
inline bool Message::_internal_has_pub_key_request() const {
  return sum_case() == kPubKeyRequest;
}
inline bool Message::has_pub_key_request() const {
  return _internal_has_pub_key_request();
}
inline void Message::set_has_pub_key_request() {
  _oneof_case_[0] = kPubKeyRequest;
}
inline void Message::clear_pub_key_request() {
  if (_internal_has_pub_key_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.pub_key_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PubKeyRequest* Message::release_pub_key_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.pub_key_request)
  if (_internal_has_pub_key_request()) {
    clear_has_sum();
      ::tendermint::privval::PubKeyRequest* temp = sum_.pub_key_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.pub_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PubKeyRequest& Message::_internal_pub_key_request() const {
  return _internal_has_pub_key_request()
      ? *sum_.pub_key_request_
      : reinterpret_cast< ::tendermint::privval::PubKeyRequest&>(::tendermint::privval::_PubKeyRequest_default_instance_);
}
inline const ::tendermint::privval::PubKeyRequest& Message::pub_key_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.pub_key_request)
  return _internal_pub_key_request();
}
inline ::tendermint::privval::PubKeyRequest* Message::unsafe_arena_release_pub_key_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.pub_key_request)
  if (_internal_has_pub_key_request()) {
    clear_has_sum();
    ::tendermint::privval::PubKeyRequest* temp = sum_.pub_key_request_;
    sum_.pub_key_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_pub_key_request(::tendermint::privval::PubKeyRequest* pub_key_request) {
  clear_sum();
  if (pub_key_request) {
    set_has_pub_key_request();
    sum_.pub_key_request_ = pub_key_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.pub_key_request)
}
inline ::tendermint::privval::PubKeyRequest* Message::_internal_mutable_pub_key_request() {
  if (!_internal_has_pub_key_request()) {
    clear_sum();
    set_has_pub_key_request();
    sum_.pub_key_request_ = CreateMaybeMessage< ::tendermint::privval::PubKeyRequest >(GetArenaForAllocation());
  }
  return sum_.pub_key_request_;
}
inline ::tendermint::privval::PubKeyRequest* Message::mutable_pub_key_request() {
  ::tendermint::privval::PubKeyRequest* _msg = _internal_mutable_pub_key_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.pub_key_request)
  return _msg;
}

// .tendermint.privval.PubKeyResponse pub_key_response = 2;
inline bool Message::_internal_has_pub_key_response() const {
  return sum_case() == kPubKeyResponse;
}
inline bool Message::has_pub_key_response() const {
  return _internal_has_pub_key_response();
}
inline void Message::set_has_pub_key_response() {
  _oneof_case_[0] = kPubKeyResponse;
}
inline void Message::clear_pub_key_response() {
  if (_internal_has_pub_key_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.pub_key_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PubKeyResponse* Message::release_pub_key_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.pub_key_response)
  if (_internal_has_pub_key_response()) {
    clear_has_sum();
      ::tendermint::privval::PubKeyResponse* temp = sum_.pub_key_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.pub_key_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PubKeyResponse& Message::_internal_pub_key_response() const {
  return _internal_has_pub_key_response()
      ? *sum_.pub_key_response_
      : reinterpret_cast< ::tendermint::privval::PubKeyResponse&>(::tendermint::privval::_PubKeyResponse_default_instance_);
}
inline const ::tendermint::privval::PubKeyResponse& Message::pub_key_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.pub_key_response)
  return _internal_pub_key_response();
}
inline ::tendermint::privval::PubKeyResponse* Message::unsafe_arena_release_pub_key_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.pub_key_response)
  if (_internal_has_pub_key_response()) {
    clear_has_sum();
    ::tendermint::privval::PubKeyResponse* temp = sum_.pub_key_response_;
    sum_.pub_key_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_pub_key_response(::tendermint::privval::PubKeyResponse* pub_key_response) {
  clear_sum();
  if (pub_key_response) {
    set_has_pub_key_response();
    sum_.pub_key_response_ = pub_key_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.pub_key_response)
}
inline ::tendermint::privval::PubKeyResponse* Message::_internal_mutable_pub_key_response() {
  if (!_internal_has_pub_key_response()) {
    clear_sum();
    set_has_pub_key_response();
    sum_.pub_key_response_ = CreateMaybeMessage< ::tendermint::privval::PubKeyResponse >(GetArenaForAllocation());
  }
  return sum_.pub_key_response_;
}
inline ::tendermint::privval::PubKeyResponse* Message::mutable_pub_key_response() {
  ::tendermint::privval::PubKeyResponse* _msg = _internal_mutable_pub_key_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.pub_key_response)
  return _msg;
}

// .tendermint.privval.SignVoteRequest sign_vote_request = 3;
inline bool Message::_internal_has_sign_vote_request() const {
  return sum_case() == kSignVoteRequest;
}
inline bool Message::has_sign_vote_request() const {
  return _internal_has_sign_vote_request();
}
inline void Message::set_has_sign_vote_request() {
  _oneof_case_[0] = kSignVoteRequest;
}
inline void Message::clear_sign_vote_request() {
  if (_internal_has_sign_vote_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.sign_vote_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignVoteRequest* Message::release_sign_vote_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.sign_vote_request)
  if (_internal_has_sign_vote_request()) {
    clear_has_sum();
      ::tendermint::privval::SignVoteRequest* temp = sum_.sign_vote_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.sign_vote_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignVoteRequest& Message::_internal_sign_vote_request() const {
  return _internal_has_sign_vote_request()
      ? *sum_.sign_vote_request_
      : reinterpret_cast< ::tendermint::privval::SignVoteRequest&>(::tendermint::privval::_SignVoteRequest_default_instance_);
}
inline const ::tendermint::privval::SignVoteRequest& Message::sign_vote_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.sign_vote_request)
  return _internal_sign_vote_request();
}
inline ::tendermint::privval::SignVoteRequest* Message::unsafe_arena_release_sign_vote_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.sign_vote_request)
  if (_internal_has_sign_vote_request()) {
    clear_has_sum();
    ::tendermint::privval::SignVoteRequest* temp = sum_.sign_vote_request_;
    sum_.sign_vote_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_sign_vote_request(::tendermint::privval::SignVoteRequest* sign_vote_request) {
  clear_sum();
  if (sign_vote_request) {
    set_has_sign_vote_request();
    sum_.sign_vote_request_ = sign_vote_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.sign_vote_request)
}
inline ::tendermint::privval::SignVoteRequest* Message::_internal_mutable_sign_vote_request() {
  if (!_internal_has_sign_vote_request()) {
    clear_sum();
    set_has_sign_vote_request();
    sum_.sign_vote_request_ = CreateMaybeMessage< ::tendermint::privval::SignVoteRequest >(GetArenaForAllocation());
  }
  return sum_.sign_vote_request_;
}
inline ::tendermint::privval::SignVoteRequest* Message::mutable_sign_vote_request() {
  ::tendermint::privval::SignVoteRequest* _msg = _internal_mutable_sign_vote_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.sign_vote_request)
  return _msg;
}

// .tendermint.privval.SignedVoteResponse signed_vote_response = 4;
inline bool Message::_internal_has_signed_vote_response() const {
  return sum_case() == kSignedVoteResponse;
}
inline bool Message::has_signed_vote_response() const {
  return _internal_has_signed_vote_response();
}
inline void Message::set_has_signed_vote_response() {
  _oneof_case_[0] = kSignedVoteResponse;
}
inline void Message::clear_signed_vote_response() {
  if (_internal_has_signed_vote_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.signed_vote_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignedVoteResponse* Message::release_signed_vote_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.signed_vote_response)
  if (_internal_has_signed_vote_response()) {
    clear_has_sum();
      ::tendermint::privval::SignedVoteResponse* temp = sum_.signed_vote_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.signed_vote_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignedVoteResponse& Message::_internal_signed_vote_response() const {
  return _internal_has_signed_vote_response()
      ? *sum_.signed_vote_response_
      : reinterpret_cast< ::tendermint::privval::SignedVoteResponse&>(::tendermint::privval::_SignedVoteResponse_default_instance_);
}
inline const ::tendermint::privval::SignedVoteResponse& Message::signed_vote_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.signed_vote_response)
  return _internal_signed_vote_response();
}
inline ::tendermint::privval::SignedVoteResponse* Message::unsafe_arena_release_signed_vote_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.signed_vote_response)
  if (_internal_has_signed_vote_response()) {
    clear_has_sum();
    ::tendermint::privval::SignedVoteResponse* temp = sum_.signed_vote_response_;
    sum_.signed_vote_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_signed_vote_response(::tendermint::privval::SignedVoteResponse* signed_vote_response) {
  clear_sum();
  if (signed_vote_response) {
    set_has_signed_vote_response();
    sum_.signed_vote_response_ = signed_vote_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.signed_vote_response)
}
inline ::tendermint::privval::SignedVoteResponse* Message::_internal_mutable_signed_vote_response() {
  if (!_internal_has_signed_vote_response()) {
    clear_sum();
    set_has_signed_vote_response();
    sum_.signed_vote_response_ = CreateMaybeMessage< ::tendermint::privval::SignedVoteResponse >(GetArenaForAllocation());
  }
  return sum_.signed_vote_response_;
}
inline ::tendermint::privval::SignedVoteResponse* Message::mutable_signed_vote_response() {
  ::tendermint::privval::SignedVoteResponse* _msg = _internal_mutable_signed_vote_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.signed_vote_response)
  return _msg;
}

// .tendermint.privval.SignProposalRequest sign_proposal_request = 5;
inline bool Message::_internal_has_sign_proposal_request() const {
  return sum_case() == kSignProposalRequest;
}
inline bool Message::has_sign_proposal_request() const {
  return _internal_has_sign_proposal_request();
}
inline void Message::set_has_sign_proposal_request() {
  _oneof_case_[0] = kSignProposalRequest;
}
inline void Message::clear_sign_proposal_request() {
  if (_internal_has_sign_proposal_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.sign_proposal_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignProposalRequest* Message::release_sign_proposal_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.sign_proposal_request)
  if (_internal_has_sign_proposal_request()) {
    clear_has_sum();
      ::tendermint::privval::SignProposalRequest* temp = sum_.sign_proposal_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.sign_proposal_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignProposalRequest& Message::_internal_sign_proposal_request() const {
  return _internal_has_sign_proposal_request()
      ? *sum_.sign_proposal_request_
      : reinterpret_cast< ::tendermint::privval::SignProposalRequest&>(::tendermint::privval::_SignProposalRequest_default_instance_);
}
inline const ::tendermint::privval::SignProposalRequest& Message::sign_proposal_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.sign_proposal_request)
  return _internal_sign_proposal_request();
}
inline ::tendermint::privval::SignProposalRequest* Message::unsafe_arena_release_sign_proposal_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.sign_proposal_request)
  if (_internal_has_sign_proposal_request()) {
    clear_has_sum();
    ::tendermint::privval::SignProposalRequest* temp = sum_.sign_proposal_request_;
    sum_.sign_proposal_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_sign_proposal_request(::tendermint::privval::SignProposalRequest* sign_proposal_request) {
  clear_sum();
  if (sign_proposal_request) {
    set_has_sign_proposal_request();
    sum_.sign_proposal_request_ = sign_proposal_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.sign_proposal_request)
}
inline ::tendermint::privval::SignProposalRequest* Message::_internal_mutable_sign_proposal_request() {
  if (!_internal_has_sign_proposal_request()) {
    clear_sum();
    set_has_sign_proposal_request();
    sum_.sign_proposal_request_ = CreateMaybeMessage< ::tendermint::privval::SignProposalRequest >(GetArenaForAllocation());
  }
  return sum_.sign_proposal_request_;
}
inline ::tendermint::privval::SignProposalRequest* Message::mutable_sign_proposal_request() {
  ::tendermint::privval::SignProposalRequest* _msg = _internal_mutable_sign_proposal_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.sign_proposal_request)
  return _msg;
}

// .tendermint.privval.SignedProposalResponse signed_proposal_response = 6;
inline bool Message::_internal_has_signed_proposal_response() const {
  return sum_case() == kSignedProposalResponse;
}
inline bool Message::has_signed_proposal_response() const {
  return _internal_has_signed_proposal_response();
}
inline void Message::set_has_signed_proposal_response() {
  _oneof_case_[0] = kSignedProposalResponse;
}
inline void Message::clear_signed_proposal_response() {
  if (_internal_has_signed_proposal_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.signed_proposal_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::SignedProposalResponse* Message::release_signed_proposal_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.signed_proposal_response)
  if (_internal_has_signed_proposal_response()) {
    clear_has_sum();
      ::tendermint::privval::SignedProposalResponse* temp = sum_.signed_proposal_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.signed_proposal_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::SignedProposalResponse& Message::_internal_signed_proposal_response() const {
  return _internal_has_signed_proposal_response()
      ? *sum_.signed_proposal_response_
      : reinterpret_cast< ::tendermint::privval::SignedProposalResponse&>(::tendermint::privval::_SignedProposalResponse_default_instance_);
}
inline const ::tendermint::privval::SignedProposalResponse& Message::signed_proposal_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.signed_proposal_response)
  return _internal_signed_proposal_response();
}
inline ::tendermint::privval::SignedProposalResponse* Message::unsafe_arena_release_signed_proposal_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.signed_proposal_response)
  if (_internal_has_signed_proposal_response()) {
    clear_has_sum();
    ::tendermint::privval::SignedProposalResponse* temp = sum_.signed_proposal_response_;
    sum_.signed_proposal_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_signed_proposal_response(::tendermint::privval::SignedProposalResponse* signed_proposal_response) {
  clear_sum();
  if (signed_proposal_response) {
    set_has_signed_proposal_response();
    sum_.signed_proposal_response_ = signed_proposal_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.signed_proposal_response)
}
inline ::tendermint::privval::SignedProposalResponse* Message::_internal_mutable_signed_proposal_response() {
  if (!_internal_has_signed_proposal_response()) {
    clear_sum();
    set_has_signed_proposal_response();
    sum_.signed_proposal_response_ = CreateMaybeMessage< ::tendermint::privval::SignedProposalResponse >(GetArenaForAllocation());
  }
  return sum_.signed_proposal_response_;
}
inline ::tendermint::privval::SignedProposalResponse* Message::mutable_signed_proposal_response() {
  ::tendermint::privval::SignedProposalResponse* _msg = _internal_mutable_signed_proposal_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.signed_proposal_response)
  return _msg;
}

// .tendermint.privval.PingRequest ping_request = 7;
inline bool Message::_internal_has_ping_request() const {
  return sum_case() == kPingRequest;
}
inline bool Message::has_ping_request() const {
  return _internal_has_ping_request();
}
inline void Message::set_has_ping_request() {
  _oneof_case_[0] = kPingRequest;
}
inline void Message::clear_ping_request() {
  if (_internal_has_ping_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.ping_request_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PingRequest* Message::release_ping_request() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.ping_request)
  if (_internal_has_ping_request()) {
    clear_has_sum();
      ::tendermint::privval::PingRequest* temp = sum_.ping_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.ping_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PingRequest& Message::_internal_ping_request() const {
  return _internal_has_ping_request()
      ? *sum_.ping_request_
      : reinterpret_cast< ::tendermint::privval::PingRequest&>(::tendermint::privval::_PingRequest_default_instance_);
}
inline const ::tendermint::privval::PingRequest& Message::ping_request() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.ping_request)
  return _internal_ping_request();
}
inline ::tendermint::privval::PingRequest* Message::unsafe_arena_release_ping_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.ping_request)
  if (_internal_has_ping_request()) {
    clear_has_sum();
    ::tendermint::privval::PingRequest* temp = sum_.ping_request_;
    sum_.ping_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_ping_request(::tendermint::privval::PingRequest* ping_request) {
  clear_sum();
  if (ping_request) {
    set_has_ping_request();
    sum_.ping_request_ = ping_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.ping_request)
}
inline ::tendermint::privval::PingRequest* Message::_internal_mutable_ping_request() {
  if (!_internal_has_ping_request()) {
    clear_sum();
    set_has_ping_request();
    sum_.ping_request_ = CreateMaybeMessage< ::tendermint::privval::PingRequest >(GetArenaForAllocation());
  }
  return sum_.ping_request_;
}
inline ::tendermint::privval::PingRequest* Message::mutable_ping_request() {
  ::tendermint::privval::PingRequest* _msg = _internal_mutable_ping_request();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.ping_request)
  return _msg;
}

// .tendermint.privval.PingResponse ping_response = 8;
inline bool Message::_internal_has_ping_response() const {
  return sum_case() == kPingResponse;
}
inline bool Message::has_ping_response() const {
  return _internal_has_ping_response();
}
inline void Message::set_has_ping_response() {
  _oneof_case_[0] = kPingResponse;
}
inline void Message::clear_ping_response() {
  if (_internal_has_ping_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete sum_.ping_response_;
    }
    clear_has_sum();
  }
}
inline ::tendermint::privval::PingResponse* Message::release_ping_response() {
  // @@protoc_insertion_point(field_release:tendermint.privval.Message.ping_response)
  if (_internal_has_ping_response()) {
    clear_has_sum();
      ::tendermint::privval::PingResponse* temp = sum_.ping_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    sum_.ping_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::privval::PingResponse& Message::_internal_ping_response() const {
  return _internal_has_ping_response()
      ? *sum_.ping_response_
      : reinterpret_cast< ::tendermint::privval::PingResponse&>(::tendermint::privval::_PingResponse_default_instance_);
}
inline const ::tendermint::privval::PingResponse& Message::ping_response() const {
  // @@protoc_insertion_point(field_get:tendermint.privval.Message.ping_response)
  return _internal_ping_response();
}
inline ::tendermint::privval::PingResponse* Message::unsafe_arena_release_ping_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.privval.Message.ping_response)
  if (_internal_has_ping_response()) {
    clear_has_sum();
    ::tendermint::privval::PingResponse* temp = sum_.ping_response_;
    sum_.ping_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_ping_response(::tendermint::privval::PingResponse* ping_response) {
  clear_sum();
  if (ping_response) {
    set_has_ping_response();
    sum_.ping_response_ = ping_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.privval.Message.ping_response)
}
inline ::tendermint::privval::PingResponse* Message::_internal_mutable_ping_response() {
  if (!_internal_has_ping_response()) {
    clear_sum();
    set_has_ping_response();
    sum_.ping_response_ = CreateMaybeMessage< ::tendermint::privval::PingResponse >(GetArenaForAllocation());
  }
  return sum_.ping_response_;
}
inline ::tendermint::privval::PingResponse* Message::mutable_ping_response() {
  ::tendermint::privval::PingResponse* _msg = _internal_mutable_ping_response();
  // @@protoc_insertion_point(field_mutable:tendermint.privval.Message.ping_response)
  return _msg;
}

inline bool Message::has_sum() const {
  return sum_case() != SUM_NOT_SET;
}
inline void Message::clear_has_sum() {
  _oneof_case_[0] = SUM_NOT_SET;
}
inline Message::SumCase Message::sum_case() const {
  return Message::SumCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace privval
}  // namespace tendermint

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tendermint::privval::Errors> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tendermint::privval::Errors>() {
  return ::tendermint::privval::Errors_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tendermint_2fprivval_2ftypes_2eproto
