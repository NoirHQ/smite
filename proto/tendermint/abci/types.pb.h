// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tendermint/abci/types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tendermint_2fabci_2ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tendermint_2fabci_2ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tendermint/crypto/proof.pb.h"
#include "tendermint/types/types.pb.h"
#include "tendermint/crypto/keys.pb.h"
#include "tendermint/types/params.pb.h"
#include <google/protobuf/timestamp.pb.h>
#include "gogoproto/gogo.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tendermint_2fabci_2ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tendermint_2fabci_2ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[44]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tendermint_2fabci_2ftypes_2eproto;
namespace tendermint {
namespace abci {
class BlockParams;
struct BlockParamsDefaultTypeInternal;
extern BlockParamsDefaultTypeInternal _BlockParams_default_instance_;
class ConsensusParams;
struct ConsensusParamsDefaultTypeInternal;
extern ConsensusParamsDefaultTypeInternal _ConsensusParams_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventAttribute;
struct EventAttributeDefaultTypeInternal;
extern EventAttributeDefaultTypeInternal _EventAttribute_default_instance_;
class Evidence;
struct EvidenceDefaultTypeInternal;
extern EvidenceDefaultTypeInternal _Evidence_default_instance_;
class LastCommitInfo;
struct LastCommitInfoDefaultTypeInternal;
extern LastCommitInfoDefaultTypeInternal _LastCommitInfo_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestApplySnapshotChunk;
struct RequestApplySnapshotChunkDefaultTypeInternal;
extern RequestApplySnapshotChunkDefaultTypeInternal _RequestApplySnapshotChunk_default_instance_;
class RequestBeginBlock;
struct RequestBeginBlockDefaultTypeInternal;
extern RequestBeginBlockDefaultTypeInternal _RequestBeginBlock_default_instance_;
class RequestCheckTx;
struct RequestCheckTxDefaultTypeInternal;
extern RequestCheckTxDefaultTypeInternal _RequestCheckTx_default_instance_;
class RequestCommit;
struct RequestCommitDefaultTypeInternal;
extern RequestCommitDefaultTypeInternal _RequestCommit_default_instance_;
class RequestDeliverTx;
struct RequestDeliverTxDefaultTypeInternal;
extern RequestDeliverTxDefaultTypeInternal _RequestDeliverTx_default_instance_;
class RequestEcho;
struct RequestEchoDefaultTypeInternal;
extern RequestEchoDefaultTypeInternal _RequestEcho_default_instance_;
class RequestEndBlock;
struct RequestEndBlockDefaultTypeInternal;
extern RequestEndBlockDefaultTypeInternal _RequestEndBlock_default_instance_;
class RequestFlush;
struct RequestFlushDefaultTypeInternal;
extern RequestFlushDefaultTypeInternal _RequestFlush_default_instance_;
class RequestInfo;
struct RequestInfoDefaultTypeInternal;
extern RequestInfoDefaultTypeInternal _RequestInfo_default_instance_;
class RequestInitChain;
struct RequestInitChainDefaultTypeInternal;
extern RequestInitChainDefaultTypeInternal _RequestInitChain_default_instance_;
class RequestListSnapshots;
struct RequestListSnapshotsDefaultTypeInternal;
extern RequestListSnapshotsDefaultTypeInternal _RequestListSnapshots_default_instance_;
class RequestLoadSnapshotChunk;
struct RequestLoadSnapshotChunkDefaultTypeInternal;
extern RequestLoadSnapshotChunkDefaultTypeInternal _RequestLoadSnapshotChunk_default_instance_;
class RequestOfferSnapshot;
struct RequestOfferSnapshotDefaultTypeInternal;
extern RequestOfferSnapshotDefaultTypeInternal _RequestOfferSnapshot_default_instance_;
class RequestQuery;
struct RequestQueryDefaultTypeInternal;
extern RequestQueryDefaultTypeInternal _RequestQuery_default_instance_;
class RequestSetOption;
struct RequestSetOptionDefaultTypeInternal;
extern RequestSetOptionDefaultTypeInternal _RequestSetOption_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseApplySnapshotChunk;
struct ResponseApplySnapshotChunkDefaultTypeInternal;
extern ResponseApplySnapshotChunkDefaultTypeInternal _ResponseApplySnapshotChunk_default_instance_;
class ResponseBeginBlock;
struct ResponseBeginBlockDefaultTypeInternal;
extern ResponseBeginBlockDefaultTypeInternal _ResponseBeginBlock_default_instance_;
class ResponseCheckTx;
struct ResponseCheckTxDefaultTypeInternal;
extern ResponseCheckTxDefaultTypeInternal _ResponseCheckTx_default_instance_;
class ResponseCommit;
struct ResponseCommitDefaultTypeInternal;
extern ResponseCommitDefaultTypeInternal _ResponseCommit_default_instance_;
class ResponseDeliverTx;
struct ResponseDeliverTxDefaultTypeInternal;
extern ResponseDeliverTxDefaultTypeInternal _ResponseDeliverTx_default_instance_;
class ResponseEcho;
struct ResponseEchoDefaultTypeInternal;
extern ResponseEchoDefaultTypeInternal _ResponseEcho_default_instance_;
class ResponseEndBlock;
struct ResponseEndBlockDefaultTypeInternal;
extern ResponseEndBlockDefaultTypeInternal _ResponseEndBlock_default_instance_;
class ResponseException;
struct ResponseExceptionDefaultTypeInternal;
extern ResponseExceptionDefaultTypeInternal _ResponseException_default_instance_;
class ResponseFlush;
struct ResponseFlushDefaultTypeInternal;
extern ResponseFlushDefaultTypeInternal _ResponseFlush_default_instance_;
class ResponseInfo;
struct ResponseInfoDefaultTypeInternal;
extern ResponseInfoDefaultTypeInternal _ResponseInfo_default_instance_;
class ResponseInitChain;
struct ResponseInitChainDefaultTypeInternal;
extern ResponseInitChainDefaultTypeInternal _ResponseInitChain_default_instance_;
class ResponseListSnapshots;
struct ResponseListSnapshotsDefaultTypeInternal;
extern ResponseListSnapshotsDefaultTypeInternal _ResponseListSnapshots_default_instance_;
class ResponseLoadSnapshotChunk;
struct ResponseLoadSnapshotChunkDefaultTypeInternal;
extern ResponseLoadSnapshotChunkDefaultTypeInternal _ResponseLoadSnapshotChunk_default_instance_;
class ResponseOfferSnapshot;
struct ResponseOfferSnapshotDefaultTypeInternal;
extern ResponseOfferSnapshotDefaultTypeInternal _ResponseOfferSnapshot_default_instance_;
class ResponseQuery;
struct ResponseQueryDefaultTypeInternal;
extern ResponseQueryDefaultTypeInternal _ResponseQuery_default_instance_;
class ResponseSetOption;
struct ResponseSetOptionDefaultTypeInternal;
extern ResponseSetOptionDefaultTypeInternal _ResponseSetOption_default_instance_;
class Snapshot;
struct SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class TxResult;
struct TxResultDefaultTypeInternal;
extern TxResultDefaultTypeInternal _TxResult_default_instance_;
class Validator;
struct ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorUpdate;
struct ValidatorUpdateDefaultTypeInternal;
extern ValidatorUpdateDefaultTypeInternal _ValidatorUpdate_default_instance_;
class VoteInfo;
struct VoteInfoDefaultTypeInternal;
extern VoteInfoDefaultTypeInternal _VoteInfo_default_instance_;
}  // namespace abci
}  // namespace tendermint
PROTOBUF_NAMESPACE_OPEN
template<> ::tendermint::abci::BlockParams* Arena::CreateMaybeMessage<::tendermint::abci::BlockParams>(Arena*);
template<> ::tendermint::abci::ConsensusParams* Arena::CreateMaybeMessage<::tendermint::abci::ConsensusParams>(Arena*);
template<> ::tendermint::abci::Event* Arena::CreateMaybeMessage<::tendermint::abci::Event>(Arena*);
template<> ::tendermint::abci::EventAttribute* Arena::CreateMaybeMessage<::tendermint::abci::EventAttribute>(Arena*);
template<> ::tendermint::abci::Evidence* Arena::CreateMaybeMessage<::tendermint::abci::Evidence>(Arena*);
template<> ::tendermint::abci::LastCommitInfo* Arena::CreateMaybeMessage<::tendermint::abci::LastCommitInfo>(Arena*);
template<> ::tendermint::abci::Request* Arena::CreateMaybeMessage<::tendermint::abci::Request>(Arena*);
template<> ::tendermint::abci::RequestApplySnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::RequestApplySnapshotChunk>(Arena*);
template<> ::tendermint::abci::RequestBeginBlock* Arena::CreateMaybeMessage<::tendermint::abci::RequestBeginBlock>(Arena*);
template<> ::tendermint::abci::RequestCheckTx* Arena::CreateMaybeMessage<::tendermint::abci::RequestCheckTx>(Arena*);
template<> ::tendermint::abci::RequestCommit* Arena::CreateMaybeMessage<::tendermint::abci::RequestCommit>(Arena*);
template<> ::tendermint::abci::RequestDeliverTx* Arena::CreateMaybeMessage<::tendermint::abci::RequestDeliverTx>(Arena*);
template<> ::tendermint::abci::RequestEcho* Arena::CreateMaybeMessage<::tendermint::abci::RequestEcho>(Arena*);
template<> ::tendermint::abci::RequestEndBlock* Arena::CreateMaybeMessage<::tendermint::abci::RequestEndBlock>(Arena*);
template<> ::tendermint::abci::RequestFlush* Arena::CreateMaybeMessage<::tendermint::abci::RequestFlush>(Arena*);
template<> ::tendermint::abci::RequestInfo* Arena::CreateMaybeMessage<::tendermint::abci::RequestInfo>(Arena*);
template<> ::tendermint::abci::RequestInitChain* Arena::CreateMaybeMessage<::tendermint::abci::RequestInitChain>(Arena*);
template<> ::tendermint::abci::RequestListSnapshots* Arena::CreateMaybeMessage<::tendermint::abci::RequestListSnapshots>(Arena*);
template<> ::tendermint::abci::RequestLoadSnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::RequestLoadSnapshotChunk>(Arena*);
template<> ::tendermint::abci::RequestOfferSnapshot* Arena::CreateMaybeMessage<::tendermint::abci::RequestOfferSnapshot>(Arena*);
template<> ::tendermint::abci::RequestQuery* Arena::CreateMaybeMessage<::tendermint::abci::RequestQuery>(Arena*);
template<> ::tendermint::abci::RequestSetOption* Arena::CreateMaybeMessage<::tendermint::abci::RequestSetOption>(Arena*);
template<> ::tendermint::abci::Response* Arena::CreateMaybeMessage<::tendermint::abci::Response>(Arena*);
template<> ::tendermint::abci::ResponseApplySnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::ResponseApplySnapshotChunk>(Arena*);
template<> ::tendermint::abci::ResponseBeginBlock* Arena::CreateMaybeMessage<::tendermint::abci::ResponseBeginBlock>(Arena*);
template<> ::tendermint::abci::ResponseCheckTx* Arena::CreateMaybeMessage<::tendermint::abci::ResponseCheckTx>(Arena*);
template<> ::tendermint::abci::ResponseCommit* Arena::CreateMaybeMessage<::tendermint::abci::ResponseCommit>(Arena*);
template<> ::tendermint::abci::ResponseDeliverTx* Arena::CreateMaybeMessage<::tendermint::abci::ResponseDeliverTx>(Arena*);
template<> ::tendermint::abci::ResponseEcho* Arena::CreateMaybeMessage<::tendermint::abci::ResponseEcho>(Arena*);
template<> ::tendermint::abci::ResponseEndBlock* Arena::CreateMaybeMessage<::tendermint::abci::ResponseEndBlock>(Arena*);
template<> ::tendermint::abci::ResponseException* Arena::CreateMaybeMessage<::tendermint::abci::ResponseException>(Arena*);
template<> ::tendermint::abci::ResponseFlush* Arena::CreateMaybeMessage<::tendermint::abci::ResponseFlush>(Arena*);
template<> ::tendermint::abci::ResponseInfo* Arena::CreateMaybeMessage<::tendermint::abci::ResponseInfo>(Arena*);
template<> ::tendermint::abci::ResponseInitChain* Arena::CreateMaybeMessage<::tendermint::abci::ResponseInitChain>(Arena*);
template<> ::tendermint::abci::ResponseListSnapshots* Arena::CreateMaybeMessage<::tendermint::abci::ResponseListSnapshots>(Arena*);
template<> ::tendermint::abci::ResponseLoadSnapshotChunk* Arena::CreateMaybeMessage<::tendermint::abci::ResponseLoadSnapshotChunk>(Arena*);
template<> ::tendermint::abci::ResponseOfferSnapshot* Arena::CreateMaybeMessage<::tendermint::abci::ResponseOfferSnapshot>(Arena*);
template<> ::tendermint::abci::ResponseQuery* Arena::CreateMaybeMessage<::tendermint::abci::ResponseQuery>(Arena*);
template<> ::tendermint::abci::ResponseSetOption* Arena::CreateMaybeMessage<::tendermint::abci::ResponseSetOption>(Arena*);
template<> ::tendermint::abci::Snapshot* Arena::CreateMaybeMessage<::tendermint::abci::Snapshot>(Arena*);
template<> ::tendermint::abci::TxResult* Arena::CreateMaybeMessage<::tendermint::abci::TxResult>(Arena*);
template<> ::tendermint::abci::Validator* Arena::CreateMaybeMessage<::tendermint::abci::Validator>(Arena*);
template<> ::tendermint::abci::ValidatorUpdate* Arena::CreateMaybeMessage<::tendermint::abci::ValidatorUpdate>(Arena*);
template<> ::tendermint::abci::VoteInfo* Arena::CreateMaybeMessage<::tendermint::abci::VoteInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tendermint {
namespace abci {

enum ResponseOfferSnapshot_Result : int {
  ResponseOfferSnapshot_Result_UNKNOWN = 0,
  ResponseOfferSnapshot_Result_ACCEPT = 1,
  ResponseOfferSnapshot_Result_ABORT = 2,
  ResponseOfferSnapshot_Result_REJECT = 3,
  ResponseOfferSnapshot_Result_REJECT_FORMAT = 4,
  ResponseOfferSnapshot_Result_REJECT_SENDER = 5,
  ResponseOfferSnapshot_Result_ResponseOfferSnapshot_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResponseOfferSnapshot_Result_ResponseOfferSnapshot_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResponseOfferSnapshot_Result_IsValid(int value);
constexpr ResponseOfferSnapshot_Result ResponseOfferSnapshot_Result_Result_MIN = ResponseOfferSnapshot_Result_UNKNOWN;
constexpr ResponseOfferSnapshot_Result ResponseOfferSnapshot_Result_Result_MAX = ResponseOfferSnapshot_Result_REJECT_SENDER;
constexpr int ResponseOfferSnapshot_Result_Result_ARRAYSIZE = ResponseOfferSnapshot_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseOfferSnapshot_Result_descriptor();
template<typename T>
inline const std::string& ResponseOfferSnapshot_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseOfferSnapshot_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseOfferSnapshot_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseOfferSnapshot_Result_descriptor(), enum_t_value);
}
inline bool ResponseOfferSnapshot_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseOfferSnapshot_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseOfferSnapshot_Result>(
    ResponseOfferSnapshot_Result_descriptor(), name, value);
}
enum ResponseApplySnapshotChunk_Result : int {
  ResponseApplySnapshotChunk_Result_UNKNOWN = 0,
  ResponseApplySnapshotChunk_Result_ACCEPT = 1,
  ResponseApplySnapshotChunk_Result_ABORT = 2,
  ResponseApplySnapshotChunk_Result_RETRY = 3,
  ResponseApplySnapshotChunk_Result_RETRY_SNAPSHOT = 4,
  ResponseApplySnapshotChunk_Result_REJECT_SNAPSHOT = 5,
  ResponseApplySnapshotChunk_Result_ResponseApplySnapshotChunk_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ResponseApplySnapshotChunk_Result_ResponseApplySnapshotChunk_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ResponseApplySnapshotChunk_Result_IsValid(int value);
constexpr ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk_Result_Result_MIN = ResponseApplySnapshotChunk_Result_UNKNOWN;
constexpr ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk_Result_Result_MAX = ResponseApplySnapshotChunk_Result_REJECT_SNAPSHOT;
constexpr int ResponseApplySnapshotChunk_Result_Result_ARRAYSIZE = ResponseApplySnapshotChunk_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ResponseApplySnapshotChunk_Result_descriptor();
template<typename T>
inline const std::string& ResponseApplySnapshotChunk_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ResponseApplySnapshotChunk_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ResponseApplySnapshotChunk_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ResponseApplySnapshotChunk_Result_descriptor(), enum_t_value);
}
inline bool ResponseApplySnapshotChunk_Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseApplySnapshotChunk_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ResponseApplySnapshotChunk_Result>(
    ResponseApplySnapshotChunk_Result_descriptor(), name, value);
}
enum CheckTxType : int {
  NEW = 0,
  RECHECK = 1,
  CheckTxType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CheckTxType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CheckTxType_IsValid(int value);
constexpr CheckTxType CheckTxType_MIN = NEW;
constexpr CheckTxType CheckTxType_MAX = RECHECK;
constexpr int CheckTxType_ARRAYSIZE = CheckTxType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CheckTxType_descriptor();
template<typename T>
inline const std::string& CheckTxType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckTxType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckTxType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CheckTxType_descriptor(), enum_t_value);
}
inline bool CheckTxType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CheckTxType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CheckTxType>(
    CheckTxType_descriptor(), name, value);
}
enum EvidenceType : int {
  UNKNOWN = 0,
  DUPLICATE_VOTE = 1,
  LIGHT_CLIENT_ATTACK = 2,
  EvidenceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EvidenceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EvidenceType_IsValid(int value);
constexpr EvidenceType EvidenceType_MIN = UNKNOWN;
constexpr EvidenceType EvidenceType_MAX = LIGHT_CLIENT_ATTACK;
constexpr int EvidenceType_ARRAYSIZE = EvidenceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EvidenceType_descriptor();
template<typename T>
inline const std::string& EvidenceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EvidenceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EvidenceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EvidenceType_descriptor(), enum_t_value);
}
inline bool EvidenceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EvidenceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EvidenceType>(
    EvidenceType_descriptor(), name, value);
}
// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit constexpr Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kEcho = 1,
    kFlush = 2,
    kInfo = 3,
    kSetOption = 4,
    kInitChain = 5,
    kQuery = 6,
    kBeginBlock = 7,
    kCheckTx = 8,
    kDeliverTx = 9,
    kEndBlock = 10,
    kCommit = 11,
    kListSnapshots = 12,
    kOfferSnapshot = 13,
    kLoadSnapshotChunk = 14,
    kApplySnapshotChunk = 15,
    VALUE_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEchoFieldNumber = 1,
    kFlushFieldNumber = 2,
    kInfoFieldNumber = 3,
    kSetOptionFieldNumber = 4,
    kInitChainFieldNumber = 5,
    kQueryFieldNumber = 6,
    kBeginBlockFieldNumber = 7,
    kCheckTxFieldNumber = 8,
    kDeliverTxFieldNumber = 9,
    kEndBlockFieldNumber = 10,
    kCommitFieldNumber = 11,
    kListSnapshotsFieldNumber = 12,
    kOfferSnapshotFieldNumber = 13,
    kLoadSnapshotChunkFieldNumber = 14,
    kApplySnapshotChunkFieldNumber = 15,
  };
  // .tendermint.abci.RequestEcho echo = 1;
  bool has_echo() const;
  private:
  bool _internal_has_echo() const;
  public:
  void clear_echo();
  const ::tendermint::abci::RequestEcho& echo() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestEcho* release_echo();
  ::tendermint::abci::RequestEcho* mutable_echo();
  void set_allocated_echo(::tendermint::abci::RequestEcho* echo);
  private:
  const ::tendermint::abci::RequestEcho& _internal_echo() const;
  ::tendermint::abci::RequestEcho* _internal_mutable_echo();
  public:
  void unsafe_arena_set_allocated_echo(
      ::tendermint::abci::RequestEcho* echo);
  ::tendermint::abci::RequestEcho* unsafe_arena_release_echo();

  // .tendermint.abci.RequestFlush flush = 2;
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;
  public:
  void clear_flush();
  const ::tendermint::abci::RequestFlush& flush() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestFlush* release_flush();
  ::tendermint::abci::RequestFlush* mutable_flush();
  void set_allocated_flush(::tendermint::abci::RequestFlush* flush);
  private:
  const ::tendermint::abci::RequestFlush& _internal_flush() const;
  ::tendermint::abci::RequestFlush* _internal_mutable_flush();
  public:
  void unsafe_arena_set_allocated_flush(
      ::tendermint::abci::RequestFlush* flush);
  ::tendermint::abci::RequestFlush* unsafe_arena_release_flush();

  // .tendermint.abci.RequestInfo info = 3;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::tendermint::abci::RequestInfo& info() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestInfo* release_info();
  ::tendermint::abci::RequestInfo* mutable_info();
  void set_allocated_info(::tendermint::abci::RequestInfo* info);
  private:
  const ::tendermint::abci::RequestInfo& _internal_info() const;
  ::tendermint::abci::RequestInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::tendermint::abci::RequestInfo* info);
  ::tendermint::abci::RequestInfo* unsafe_arena_release_info();

  // .tendermint.abci.RequestSetOption set_option = 4;
  bool has_set_option() const;
  private:
  bool _internal_has_set_option() const;
  public:
  void clear_set_option();
  const ::tendermint::abci::RequestSetOption& set_option() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestSetOption* release_set_option();
  ::tendermint::abci::RequestSetOption* mutable_set_option();
  void set_allocated_set_option(::tendermint::abci::RequestSetOption* set_option);
  private:
  const ::tendermint::abci::RequestSetOption& _internal_set_option() const;
  ::tendermint::abci::RequestSetOption* _internal_mutable_set_option();
  public:
  void unsafe_arena_set_allocated_set_option(
      ::tendermint::abci::RequestSetOption* set_option);
  ::tendermint::abci::RequestSetOption* unsafe_arena_release_set_option();

  // .tendermint.abci.RequestInitChain init_chain = 5;
  bool has_init_chain() const;
  private:
  bool _internal_has_init_chain() const;
  public:
  void clear_init_chain();
  const ::tendermint::abci::RequestInitChain& init_chain() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestInitChain* release_init_chain();
  ::tendermint::abci::RequestInitChain* mutable_init_chain();
  void set_allocated_init_chain(::tendermint::abci::RequestInitChain* init_chain);
  private:
  const ::tendermint::abci::RequestInitChain& _internal_init_chain() const;
  ::tendermint::abci::RequestInitChain* _internal_mutable_init_chain();
  public:
  void unsafe_arena_set_allocated_init_chain(
      ::tendermint::abci::RequestInitChain* init_chain);
  ::tendermint::abci::RequestInitChain* unsafe_arena_release_init_chain();

  // .tendermint.abci.RequestQuery query = 6;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::tendermint::abci::RequestQuery& query() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestQuery* release_query();
  ::tendermint::abci::RequestQuery* mutable_query();
  void set_allocated_query(::tendermint::abci::RequestQuery* query);
  private:
  const ::tendermint::abci::RequestQuery& _internal_query() const;
  ::tendermint::abci::RequestQuery* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::tendermint::abci::RequestQuery* query);
  ::tendermint::abci::RequestQuery* unsafe_arena_release_query();

  // .tendermint.abci.RequestBeginBlock begin_block = 7;
  bool has_begin_block() const;
  private:
  bool _internal_has_begin_block() const;
  public:
  void clear_begin_block();
  const ::tendermint::abci::RequestBeginBlock& begin_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestBeginBlock* release_begin_block();
  ::tendermint::abci::RequestBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::tendermint::abci::RequestBeginBlock* begin_block);
  private:
  const ::tendermint::abci::RequestBeginBlock& _internal_begin_block() const;
  ::tendermint::abci::RequestBeginBlock* _internal_mutable_begin_block();
  public:
  void unsafe_arena_set_allocated_begin_block(
      ::tendermint::abci::RequestBeginBlock* begin_block);
  ::tendermint::abci::RequestBeginBlock* unsafe_arena_release_begin_block();

  // .tendermint.abci.RequestCheckTx check_tx = 8;
  bool has_check_tx() const;
  private:
  bool _internal_has_check_tx() const;
  public:
  void clear_check_tx();
  const ::tendermint::abci::RequestCheckTx& check_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestCheckTx* release_check_tx();
  ::tendermint::abci::RequestCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::tendermint::abci::RequestCheckTx* check_tx);
  private:
  const ::tendermint::abci::RequestCheckTx& _internal_check_tx() const;
  ::tendermint::abci::RequestCheckTx* _internal_mutable_check_tx();
  public:
  void unsafe_arena_set_allocated_check_tx(
      ::tendermint::abci::RequestCheckTx* check_tx);
  ::tendermint::abci::RequestCheckTx* unsafe_arena_release_check_tx();

  // .tendermint.abci.RequestDeliverTx deliver_tx = 9;
  bool has_deliver_tx() const;
  private:
  bool _internal_has_deliver_tx() const;
  public:
  void clear_deliver_tx();
  const ::tendermint::abci::RequestDeliverTx& deliver_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestDeliverTx* release_deliver_tx();
  ::tendermint::abci::RequestDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::tendermint::abci::RequestDeliverTx* deliver_tx);
  private:
  const ::tendermint::abci::RequestDeliverTx& _internal_deliver_tx() const;
  ::tendermint::abci::RequestDeliverTx* _internal_mutable_deliver_tx();
  public:
  void unsafe_arena_set_allocated_deliver_tx(
      ::tendermint::abci::RequestDeliverTx* deliver_tx);
  ::tendermint::abci::RequestDeliverTx* unsafe_arena_release_deliver_tx();

  // .tendermint.abci.RequestEndBlock end_block = 10;
  bool has_end_block() const;
  private:
  bool _internal_has_end_block() const;
  public:
  void clear_end_block();
  const ::tendermint::abci::RequestEndBlock& end_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestEndBlock* release_end_block();
  ::tendermint::abci::RequestEndBlock* mutable_end_block();
  void set_allocated_end_block(::tendermint::abci::RequestEndBlock* end_block);
  private:
  const ::tendermint::abci::RequestEndBlock& _internal_end_block() const;
  ::tendermint::abci::RequestEndBlock* _internal_mutable_end_block();
  public:
  void unsafe_arena_set_allocated_end_block(
      ::tendermint::abci::RequestEndBlock* end_block);
  ::tendermint::abci::RequestEndBlock* unsafe_arena_release_end_block();

  // .tendermint.abci.RequestCommit commit = 11;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::tendermint::abci::RequestCommit& commit() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestCommit* release_commit();
  ::tendermint::abci::RequestCommit* mutable_commit();
  void set_allocated_commit(::tendermint::abci::RequestCommit* commit);
  private:
  const ::tendermint::abci::RequestCommit& _internal_commit() const;
  ::tendermint::abci::RequestCommit* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::tendermint::abci::RequestCommit* commit);
  ::tendermint::abci::RequestCommit* unsafe_arena_release_commit();

  // .tendermint.abci.RequestListSnapshots list_snapshots = 12;
  bool has_list_snapshots() const;
  private:
  bool _internal_has_list_snapshots() const;
  public:
  void clear_list_snapshots();
  const ::tendermint::abci::RequestListSnapshots& list_snapshots() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestListSnapshots* release_list_snapshots();
  ::tendermint::abci::RequestListSnapshots* mutable_list_snapshots();
  void set_allocated_list_snapshots(::tendermint::abci::RequestListSnapshots* list_snapshots);
  private:
  const ::tendermint::abci::RequestListSnapshots& _internal_list_snapshots() const;
  ::tendermint::abci::RequestListSnapshots* _internal_mutable_list_snapshots();
  public:
  void unsafe_arena_set_allocated_list_snapshots(
      ::tendermint::abci::RequestListSnapshots* list_snapshots);
  ::tendermint::abci::RequestListSnapshots* unsafe_arena_release_list_snapshots();

  // .tendermint.abci.RequestOfferSnapshot offer_snapshot = 13;
  bool has_offer_snapshot() const;
  private:
  bool _internal_has_offer_snapshot() const;
  public:
  void clear_offer_snapshot();
  const ::tendermint::abci::RequestOfferSnapshot& offer_snapshot() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestOfferSnapshot* release_offer_snapshot();
  ::tendermint::abci::RequestOfferSnapshot* mutable_offer_snapshot();
  void set_allocated_offer_snapshot(::tendermint::abci::RequestOfferSnapshot* offer_snapshot);
  private:
  const ::tendermint::abci::RequestOfferSnapshot& _internal_offer_snapshot() const;
  ::tendermint::abci::RequestOfferSnapshot* _internal_mutable_offer_snapshot();
  public:
  void unsafe_arena_set_allocated_offer_snapshot(
      ::tendermint::abci::RequestOfferSnapshot* offer_snapshot);
  ::tendermint::abci::RequestOfferSnapshot* unsafe_arena_release_offer_snapshot();

  // .tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14;
  bool has_load_snapshot_chunk() const;
  private:
  bool _internal_has_load_snapshot_chunk() const;
  public:
  void clear_load_snapshot_chunk();
  const ::tendermint::abci::RequestLoadSnapshotChunk& load_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestLoadSnapshotChunk* release_load_snapshot_chunk();
  ::tendermint::abci::RequestLoadSnapshotChunk* mutable_load_snapshot_chunk();
  void set_allocated_load_snapshot_chunk(::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk);
  private:
  const ::tendermint::abci::RequestLoadSnapshotChunk& _internal_load_snapshot_chunk() const;
  ::tendermint::abci::RequestLoadSnapshotChunk* _internal_mutable_load_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_load_snapshot_chunk(
      ::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk);
  ::tendermint::abci::RequestLoadSnapshotChunk* unsafe_arena_release_load_snapshot_chunk();

  // .tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15;
  bool has_apply_snapshot_chunk() const;
  private:
  bool _internal_has_apply_snapshot_chunk() const;
  public:
  void clear_apply_snapshot_chunk();
  const ::tendermint::abci::RequestApplySnapshotChunk& apply_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::RequestApplySnapshotChunk* release_apply_snapshot_chunk();
  ::tendermint::abci::RequestApplySnapshotChunk* mutable_apply_snapshot_chunk();
  void set_allocated_apply_snapshot_chunk(::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk);
  private:
  const ::tendermint::abci::RequestApplySnapshotChunk& _internal_apply_snapshot_chunk() const;
  ::tendermint::abci::RequestApplySnapshotChunk* _internal_mutable_apply_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_apply_snapshot_chunk(
      ::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk);
  ::tendermint::abci::RequestApplySnapshotChunk* unsafe_arena_release_apply_snapshot_chunk();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:tendermint.abci.Request)
 private:
  class _Internal;
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();
  void set_has_list_snapshots();
  void set_has_offer_snapshot();
  void set_has_load_snapshot_chunk();
  void set_has_apply_snapshot_chunk();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tendermint::abci::RequestEcho* echo_;
    ::tendermint::abci::RequestFlush* flush_;
    ::tendermint::abci::RequestInfo* info_;
    ::tendermint::abci::RequestSetOption* set_option_;
    ::tendermint::abci::RequestInitChain* init_chain_;
    ::tendermint::abci::RequestQuery* query_;
    ::tendermint::abci::RequestBeginBlock* begin_block_;
    ::tendermint::abci::RequestCheckTx* check_tx_;
    ::tendermint::abci::RequestDeliverTx* deliver_tx_;
    ::tendermint::abci::RequestEndBlock* end_block_;
    ::tendermint::abci::RequestCommit* commit_;
    ::tendermint::abci::RequestListSnapshots* list_snapshots_;
    ::tendermint::abci::RequestOfferSnapshot* offer_snapshot_;
    ::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk_;
    ::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestEcho final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestEcho) */ {
 public:
  inline RequestEcho() : RequestEcho(nullptr) {}
  ~RequestEcho() override;
  explicit constexpr RequestEcho(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestEcho(const RequestEcho& from);
  RequestEcho(RequestEcho&& from) noexcept
    : RequestEcho() {
    *this = ::std::move(from);
  }

  inline RequestEcho& operator=(const RequestEcho& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestEcho& operator=(RequestEcho&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestEcho& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestEcho* internal_default_instance() {
    return reinterpret_cast<const RequestEcho*>(
               &_RequestEcho_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RequestEcho& a, RequestEcho& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestEcho* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestEcho* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestEcho* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestEcho>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestEcho& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestEcho& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEcho* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestEcho";
  }
  protected:
  explicit RequestEcho(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestEcho)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestFlush final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestFlush) */ {
 public:
  inline RequestFlush() : RequestFlush(nullptr) {}
  explicit constexpr RequestFlush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestFlush(const RequestFlush& from);
  RequestFlush(RequestFlush&& from) noexcept
    : RequestFlush() {
    *this = ::std::move(from);
  }

  inline RequestFlush& operator=(const RequestFlush& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestFlush& operator=(RequestFlush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestFlush& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestFlush* internal_default_instance() {
    return reinterpret_cast<const RequestFlush*>(
               &_RequestFlush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestFlush& a, RequestFlush& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestFlush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestFlush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestFlush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestFlush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestFlush";
  }
  protected:
  explicit RequestFlush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestFlush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestInfo) */ {
 public:
  inline RequestInfo() : RequestInfo(nullptr) {}
  ~RequestInfo() override;
  explicit constexpr RequestInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInfo(const RequestInfo& from);
  RequestInfo(RequestInfo&& from) noexcept
    : RequestInfo() {
    *this = ::std::move(from);
  }

  inline RequestInfo& operator=(const RequestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInfo& operator=(RequestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInfo* internal_default_instance() {
    return reinterpret_cast<const RequestInfo*>(
               &_RequestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestInfo& a, RequestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestInfo";
  }
  protected:
  explicit RequestInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kBlockVersionFieldNumber = 2,
    kP2PVersionFieldNumber = 3,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // uint64 block_version = 2;
  void clear_block_version();
  uint64_t block_version() const;
  void set_block_version(uint64_t value);
  private:
  uint64_t _internal_block_version() const;
  void _internal_set_block_version(uint64_t value);
  public:

  // uint64 p2p_version = 3;
  void clear_p2p_version();
  uint64_t p2p_version() const;
  void set_p2p_version(uint64_t value);
  private:
  uint64_t _internal_p2p_version() const;
  void _internal_set_p2p_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  uint64_t block_version_;
  uint64_t p2p_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestSetOption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestSetOption) */ {
 public:
  inline RequestSetOption() : RequestSetOption(nullptr) {}
  ~RequestSetOption() override;
  explicit constexpr RequestSetOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestSetOption(const RequestSetOption& from);
  RequestSetOption(RequestSetOption&& from) noexcept
    : RequestSetOption() {
    *this = ::std::move(from);
  }

  inline RequestSetOption& operator=(const RequestSetOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestSetOption& operator=(RequestSetOption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestSetOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestSetOption* internal_default_instance() {
    return reinterpret_cast<const RequestSetOption*>(
               &_RequestSetOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestSetOption& a, RequestSetOption& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestSetOption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestSetOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestSetOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestSetOption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestSetOption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestSetOption& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestSetOption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestSetOption";
  }
  protected:
  explicit RequestSetOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestSetOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestInitChain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestInitChain) */ {
 public:
  inline RequestInitChain() : RequestInitChain(nullptr) {}
  ~RequestInitChain() override;
  explicit constexpr RequestInitChain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestInitChain(const RequestInitChain& from);
  RequestInitChain(RequestInitChain&& from) noexcept
    : RequestInitChain() {
    *this = ::std::move(from);
  }

  inline RequestInitChain& operator=(const RequestInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestInitChain& operator=(RequestInitChain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestInitChain& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestInitChain* internal_default_instance() {
    return reinterpret_cast<const RequestInitChain*>(
               &_RequestInitChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RequestInitChain& a, RequestInitChain& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestInitChain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestInitChain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestInitChain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestInitChain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestInitChain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestInitChain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestInitChain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestInitChain";
  }
  protected:
  explicit RequestInitChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorsFieldNumber = 4,
    kChainIdFieldNumber = 2,
    kAppStateBytesFieldNumber = 5,
    kTimeFieldNumber = 1,
    kConsensusParamsFieldNumber = 3,
    kInitialHeightFieldNumber = 6,
  };
  // repeated .tendermint.abci.ValidatorUpdate validators = 4 [(.gogoproto.nullable) = false];
  int validators_size() const;
  private:
  int _internal_validators_size() const;
  public:
  void clear_validators();
  ::tendermint::abci::ValidatorUpdate* mutable_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
      mutable_validators();
  private:
  const ::tendermint::abci::ValidatorUpdate& _internal_validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* _internal_add_validators();
  public:
  const ::tendermint::abci::ValidatorUpdate& validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
      validators() const;

  // string chain_id = 2;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_NODISCARD std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // bytes app_state_bytes = 5;
  void clear_app_state_bytes();
  const std::string& app_state_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_state_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_state_bytes();
  PROTOBUF_NODISCARD std::string* release_app_state_bytes();
  void set_allocated_app_state_bytes(std::string* app_state_bytes);
  private:
  const std::string& _internal_app_state_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_state_bytes(const std::string& value);
  std::string* _internal_mutable_app_state_bytes();
  public:

  // .google.protobuf.Timestamp time = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // .tendermint.abci.ConsensusParams consensus_params = 3;
  bool has_consensus_params() const;
  private:
  bool _internal_has_consensus_params() const;
  public:
  void clear_consensus_params();
  const ::tendermint::abci::ConsensusParams& consensus_params() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ConsensusParams* release_consensus_params();
  ::tendermint::abci::ConsensusParams* mutable_consensus_params();
  void set_allocated_consensus_params(::tendermint::abci::ConsensusParams* consensus_params);
  private:
  const ::tendermint::abci::ConsensusParams& _internal_consensus_params() const;
  ::tendermint::abci::ConsensusParams* _internal_mutable_consensus_params();
  public:
  void unsafe_arena_set_allocated_consensus_params(
      ::tendermint::abci::ConsensusParams* consensus_params);
  ::tendermint::abci::ConsensusParams* unsafe_arena_release_consensus_params();

  // int64 initial_height = 6;
  void clear_initial_height();
  int64_t initial_height() const;
  void set_initial_height(int64_t value);
  private:
  int64_t _internal_initial_height() const;
  void _internal_set_initial_height(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestInitChain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > validators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_state_bytes_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
  ::tendermint::abci::ConsensusParams* consensus_params_;
  int64_t initial_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestQuery) */ {
 public:
  inline RequestQuery() : RequestQuery(nullptr) {}
  ~RequestQuery() override;
  explicit constexpr RequestQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestQuery(const RequestQuery& from);
  RequestQuery(RequestQuery&& from) noexcept
    : RequestQuery() {
    *this = ::std::move(from);
  }

  inline RequestQuery& operator=(const RequestQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestQuery& operator=(RequestQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestQuery* internal_default_instance() {
    return reinterpret_cast<const RequestQuery*>(
               &_RequestQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RequestQuery& a, RequestQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestQuery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestQuery";
  }
  protected:
  explicit RequestQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kPathFieldNumber = 2,
    kHeightFieldNumber = 3,
    kProveFieldNumber = 4,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int64 height = 3;
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // bool prove = 4;
  void clear_prove();
  bool prove() const;
  void set_prove(bool value);
  private:
  bool _internal_prove() const;
  void _internal_set_prove(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  int64_t height_;
  bool prove_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestBeginBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestBeginBlock) */ {
 public:
  inline RequestBeginBlock() : RequestBeginBlock(nullptr) {}
  ~RequestBeginBlock() override;
  explicit constexpr RequestBeginBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestBeginBlock(const RequestBeginBlock& from);
  RequestBeginBlock(RequestBeginBlock&& from) noexcept
    : RequestBeginBlock() {
    *this = ::std::move(from);
  }

  inline RequestBeginBlock& operator=(const RequestBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBeginBlock& operator=(RequestBeginBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestBeginBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestBeginBlock* internal_default_instance() {
    return reinterpret_cast<const RequestBeginBlock*>(
               &_RequestBeginBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RequestBeginBlock& a, RequestBeginBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBeginBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBeginBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestBeginBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestBeginBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestBeginBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestBeginBlock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBeginBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestBeginBlock";
  }
  protected:
  explicit RequestBeginBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kByzantineValidatorsFieldNumber = 4,
    kHashFieldNumber = 1,
    kHeaderFieldNumber = 2,
    kLastCommitInfoFieldNumber = 3,
  };
  // repeated .tendermint.abci.Evidence byzantine_validators = 4 [(.gogoproto.nullable) = false];
  int byzantine_validators_size() const;
  private:
  int _internal_byzantine_validators_size() const;
  public:
  void clear_byzantine_validators();
  ::tendermint::abci::Evidence* mutable_byzantine_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Evidence >*
      mutable_byzantine_validators();
  private:
  const ::tendermint::abci::Evidence& _internal_byzantine_validators(int index) const;
  ::tendermint::abci::Evidence* _internal_add_byzantine_validators();
  public:
  const ::tendermint::abci::Evidence& byzantine_validators(int index) const;
  ::tendermint::abci::Evidence* add_byzantine_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Evidence >&
      byzantine_validators() const;

  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // .tendermint.types.Header header = 2 [(.gogoproto.nullable) = false];
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::tendermint::types::Header& header() const;
  PROTOBUF_NODISCARD ::tendermint::types::Header* release_header();
  ::tendermint::types::Header* mutable_header();
  void set_allocated_header(::tendermint::types::Header* header);
  private:
  const ::tendermint::types::Header& _internal_header() const;
  ::tendermint::types::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::tendermint::types::Header* header);
  ::tendermint::types::Header* unsafe_arena_release_header();

  // .tendermint.abci.LastCommitInfo last_commit_info = 3 [(.gogoproto.nullable) = false];
  bool has_last_commit_info() const;
  private:
  bool _internal_has_last_commit_info() const;
  public:
  void clear_last_commit_info();
  const ::tendermint::abci::LastCommitInfo& last_commit_info() const;
  PROTOBUF_NODISCARD ::tendermint::abci::LastCommitInfo* release_last_commit_info();
  ::tendermint::abci::LastCommitInfo* mutable_last_commit_info();
  void set_allocated_last_commit_info(::tendermint::abci::LastCommitInfo* last_commit_info);
  private:
  const ::tendermint::abci::LastCommitInfo& _internal_last_commit_info() const;
  ::tendermint::abci::LastCommitInfo* _internal_mutable_last_commit_info();
  public:
  void unsafe_arena_set_allocated_last_commit_info(
      ::tendermint::abci::LastCommitInfo* last_commit_info);
  ::tendermint::abci::LastCommitInfo* unsafe_arena_release_last_commit_info();

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestBeginBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Evidence > byzantine_validators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::tendermint::types::Header* header_;
  ::tendermint::abci::LastCommitInfo* last_commit_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestCheckTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestCheckTx) */ {
 public:
  inline RequestCheckTx() : RequestCheckTx(nullptr) {}
  ~RequestCheckTx() override;
  explicit constexpr RequestCheckTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestCheckTx(const RequestCheckTx& from);
  RequestCheckTx(RequestCheckTx&& from) noexcept
    : RequestCheckTx() {
    *this = ::std::move(from);
  }

  inline RequestCheckTx& operator=(const RequestCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCheckTx& operator=(RequestCheckTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestCheckTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestCheckTx* internal_default_instance() {
    return reinterpret_cast<const RequestCheckTx*>(
               &_RequestCheckTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RequestCheckTx& a, RequestCheckTx& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCheckTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCheckTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestCheckTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestCheckTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestCheckTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestCheckTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCheckTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestCheckTx";
  }
  protected:
  explicit RequestCheckTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes tx = 1;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // .tendermint.abci.CheckTxType type = 2;
  void clear_type();
  ::tendermint::abci::CheckTxType type() const;
  void set_type(::tendermint::abci::CheckTxType value);
  private:
  ::tendermint::abci::CheckTxType _internal_type() const;
  void _internal_set_type(::tendermint::abci::CheckTxType value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestCheckTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestDeliverTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestDeliverTx) */ {
 public:
  inline RequestDeliverTx() : RequestDeliverTx(nullptr) {}
  ~RequestDeliverTx() override;
  explicit constexpr RequestDeliverTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestDeliverTx(const RequestDeliverTx& from);
  RequestDeliverTx(RequestDeliverTx&& from) noexcept
    : RequestDeliverTx() {
    *this = ::std::move(from);
  }

  inline RequestDeliverTx& operator=(const RequestDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestDeliverTx& operator=(RequestDeliverTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestDeliverTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestDeliverTx* internal_default_instance() {
    return reinterpret_cast<const RequestDeliverTx*>(
               &_RequestDeliverTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RequestDeliverTx& a, RequestDeliverTx& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestDeliverTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestDeliverTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestDeliverTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestDeliverTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestDeliverTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestDeliverTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestDeliverTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestDeliverTx";
  }
  protected:
  explicit RequestDeliverTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
  };
  // bytes tx = 1;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestDeliverTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestEndBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestEndBlock) */ {
 public:
  inline RequestEndBlock() : RequestEndBlock(nullptr) {}
  ~RequestEndBlock() override;
  explicit constexpr RequestEndBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestEndBlock(const RequestEndBlock& from);
  RequestEndBlock(RequestEndBlock&& from) noexcept
    : RequestEndBlock() {
    *this = ::std::move(from);
  }

  inline RequestEndBlock& operator=(const RequestEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestEndBlock& operator=(RequestEndBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestEndBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestEndBlock* internal_default_instance() {
    return reinterpret_cast<const RequestEndBlock*>(
               &_RequestEndBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RequestEndBlock& a, RequestEndBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestEndBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestEndBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestEndBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestEndBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestEndBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestEndBlock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestEndBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestEndBlock";
  }
  protected:
  explicit RequestEndBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // int64 height = 1;
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestEndBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestCommit final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestCommit) */ {
 public:
  inline RequestCommit() : RequestCommit(nullptr) {}
  explicit constexpr RequestCommit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestCommit(const RequestCommit& from);
  RequestCommit(RequestCommit&& from) noexcept
    : RequestCommit() {
    *this = ::std::move(from);
  }

  inline RequestCommit& operator=(const RequestCommit& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCommit& operator=(RequestCommit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestCommit& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestCommit* internal_default_instance() {
    return reinterpret_cast<const RequestCommit*>(
               &_RequestCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RequestCommit& a, RequestCommit& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCommit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCommit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestCommit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestCommit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestCommit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestCommit& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestCommit";
  }
  protected:
  explicit RequestCommit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestCommit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestListSnapshots final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestListSnapshots) */ {
 public:
  inline RequestListSnapshots() : RequestListSnapshots(nullptr) {}
  explicit constexpr RequestListSnapshots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestListSnapshots(const RequestListSnapshots& from);
  RequestListSnapshots(RequestListSnapshots&& from) noexcept
    : RequestListSnapshots() {
    *this = ::std::move(from);
  }

  inline RequestListSnapshots& operator=(const RequestListSnapshots& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestListSnapshots& operator=(RequestListSnapshots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestListSnapshots& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestListSnapshots* internal_default_instance() {
    return reinterpret_cast<const RequestListSnapshots*>(
               &_RequestListSnapshots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RequestListSnapshots& a, RequestListSnapshots& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestListSnapshots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestListSnapshots* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestListSnapshots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestListSnapshots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestListSnapshots& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestListSnapshots& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestListSnapshots";
  }
  protected:
  explicit RequestListSnapshots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestListSnapshots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestOfferSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestOfferSnapshot) */ {
 public:
  inline RequestOfferSnapshot() : RequestOfferSnapshot(nullptr) {}
  ~RequestOfferSnapshot() override;
  explicit constexpr RequestOfferSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestOfferSnapshot(const RequestOfferSnapshot& from);
  RequestOfferSnapshot(RequestOfferSnapshot&& from) noexcept
    : RequestOfferSnapshot() {
    *this = ::std::move(from);
  }

  inline RequestOfferSnapshot& operator=(const RequestOfferSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestOfferSnapshot& operator=(RequestOfferSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestOfferSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestOfferSnapshot* internal_default_instance() {
    return reinterpret_cast<const RequestOfferSnapshot*>(
               &_RequestOfferSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RequestOfferSnapshot& a, RequestOfferSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestOfferSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestOfferSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestOfferSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestOfferSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestOfferSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestOfferSnapshot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestOfferSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestOfferSnapshot";
  }
  protected:
  explicit RequestOfferSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppHashFieldNumber = 2,
    kSnapshotFieldNumber = 1,
  };
  // bytes app_hash = 2;
  void clear_app_hash();
  const std::string& app_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_hash();
  PROTOBUF_NODISCARD std::string* release_app_hash();
  void set_allocated_app_hash(std::string* app_hash);
  private:
  const std::string& _internal_app_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_hash(const std::string& value);
  std::string* _internal_mutable_app_hash();
  public:

  // .tendermint.abci.Snapshot snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::tendermint::abci::Snapshot& snapshot() const;
  PROTOBUF_NODISCARD ::tendermint::abci::Snapshot* release_snapshot();
  ::tendermint::abci::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::tendermint::abci::Snapshot* snapshot);
  private:
  const ::tendermint::abci::Snapshot& _internal_snapshot() const;
  ::tendermint::abci::Snapshot* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::tendermint::abci::Snapshot* snapshot);
  ::tendermint::abci::Snapshot* unsafe_arena_release_snapshot();

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestOfferSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_hash_;
  ::tendermint::abci::Snapshot* snapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestLoadSnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestLoadSnapshotChunk) */ {
 public:
  inline RequestLoadSnapshotChunk() : RequestLoadSnapshotChunk(nullptr) {}
  ~RequestLoadSnapshotChunk() override;
  explicit constexpr RequestLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLoadSnapshotChunk(const RequestLoadSnapshotChunk& from);
  RequestLoadSnapshotChunk(RequestLoadSnapshotChunk&& from) noexcept
    : RequestLoadSnapshotChunk() {
    *this = ::std::move(from);
  }

  inline RequestLoadSnapshotChunk& operator=(const RequestLoadSnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLoadSnapshotChunk& operator=(RequestLoadSnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLoadSnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLoadSnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const RequestLoadSnapshotChunk*>(
               &_RequestLoadSnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RequestLoadSnapshotChunk& a, RequestLoadSnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLoadSnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLoadSnapshotChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLoadSnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLoadSnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestLoadSnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestLoadSnapshotChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLoadSnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestLoadSnapshotChunk";
  }
  protected:
  explicit RequestLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
    kFormatFieldNumber = 2,
    kChunkFieldNumber = 3,
  };
  // uint64 height = 1;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // uint32 format = 2;
  void clear_format();
  uint32_t format() const;
  void set_format(uint32_t value);
  private:
  uint32_t _internal_format() const;
  void _internal_set_format(uint32_t value);
  public:

  // uint32 chunk = 3;
  void clear_chunk();
  uint32_t chunk() const;
  void set_chunk(uint32_t value);
  private:
  uint32_t _internal_chunk() const;
  void _internal_set_chunk(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestLoadSnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t height_;
  uint32_t format_;
  uint32_t chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class RequestApplySnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.RequestApplySnapshotChunk) */ {
 public:
  inline RequestApplySnapshotChunk() : RequestApplySnapshotChunk(nullptr) {}
  ~RequestApplySnapshotChunk() override;
  explicit constexpr RequestApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestApplySnapshotChunk(const RequestApplySnapshotChunk& from);
  RequestApplySnapshotChunk(RequestApplySnapshotChunk&& from) noexcept
    : RequestApplySnapshotChunk() {
    *this = ::std::move(from);
  }

  inline RequestApplySnapshotChunk& operator=(const RequestApplySnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestApplySnapshotChunk& operator=(RequestApplySnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestApplySnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestApplySnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const RequestApplySnapshotChunk*>(
               &_RequestApplySnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RequestApplySnapshotChunk& a, RequestApplySnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestApplySnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestApplySnapshotChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestApplySnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestApplySnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestApplySnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RequestApplySnapshotChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestApplySnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.RequestApplySnapshotChunk";
  }
  protected:
  explicit RequestApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 2,
    kSenderFieldNumber = 3,
    kIndexFieldNumber = 1,
  };
  // bytes chunk = 2;
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // string sender = 3;
  void clear_sender();
  const std::string& sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* sender);
  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string& value);
  std::string* _internal_mutable_sender();
  public:

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.RequestApplySnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
  uint32_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kException = 1,
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kSetOption = 5,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 10,
    kEndBlock = 11,
    kCommit = 12,
    kListSnapshots = 13,
    kOfferSnapshot = 14,
    kLoadSnapshotChunk = 15,
    kApplySnapshotChunk = 16,
    VALUE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExceptionFieldNumber = 1,
    kEchoFieldNumber = 2,
    kFlushFieldNumber = 3,
    kInfoFieldNumber = 4,
    kSetOptionFieldNumber = 5,
    kInitChainFieldNumber = 6,
    kQueryFieldNumber = 7,
    kBeginBlockFieldNumber = 8,
    kCheckTxFieldNumber = 9,
    kDeliverTxFieldNumber = 10,
    kEndBlockFieldNumber = 11,
    kCommitFieldNumber = 12,
    kListSnapshotsFieldNumber = 13,
    kOfferSnapshotFieldNumber = 14,
    kLoadSnapshotChunkFieldNumber = 15,
    kApplySnapshotChunkFieldNumber = 16,
  };
  // .tendermint.abci.ResponseException exception = 1;
  bool has_exception() const;
  private:
  bool _internal_has_exception() const;
  public:
  void clear_exception();
  const ::tendermint::abci::ResponseException& exception() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseException* release_exception();
  ::tendermint::abci::ResponseException* mutable_exception();
  void set_allocated_exception(::tendermint::abci::ResponseException* exception);
  private:
  const ::tendermint::abci::ResponseException& _internal_exception() const;
  ::tendermint::abci::ResponseException* _internal_mutable_exception();
  public:
  void unsafe_arena_set_allocated_exception(
      ::tendermint::abci::ResponseException* exception);
  ::tendermint::abci::ResponseException* unsafe_arena_release_exception();

  // .tendermint.abci.ResponseEcho echo = 2;
  bool has_echo() const;
  private:
  bool _internal_has_echo() const;
  public:
  void clear_echo();
  const ::tendermint::abci::ResponseEcho& echo() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseEcho* release_echo();
  ::tendermint::abci::ResponseEcho* mutable_echo();
  void set_allocated_echo(::tendermint::abci::ResponseEcho* echo);
  private:
  const ::tendermint::abci::ResponseEcho& _internal_echo() const;
  ::tendermint::abci::ResponseEcho* _internal_mutable_echo();
  public:
  void unsafe_arena_set_allocated_echo(
      ::tendermint::abci::ResponseEcho* echo);
  ::tendermint::abci::ResponseEcho* unsafe_arena_release_echo();

  // .tendermint.abci.ResponseFlush flush = 3;
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;
  public:
  void clear_flush();
  const ::tendermint::abci::ResponseFlush& flush() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseFlush* release_flush();
  ::tendermint::abci::ResponseFlush* mutable_flush();
  void set_allocated_flush(::tendermint::abci::ResponseFlush* flush);
  private:
  const ::tendermint::abci::ResponseFlush& _internal_flush() const;
  ::tendermint::abci::ResponseFlush* _internal_mutable_flush();
  public:
  void unsafe_arena_set_allocated_flush(
      ::tendermint::abci::ResponseFlush* flush);
  ::tendermint::abci::ResponseFlush* unsafe_arena_release_flush();

  // .tendermint.abci.ResponseInfo info = 4;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::tendermint::abci::ResponseInfo& info() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseInfo* release_info();
  ::tendermint::abci::ResponseInfo* mutable_info();
  void set_allocated_info(::tendermint::abci::ResponseInfo* info);
  private:
  const ::tendermint::abci::ResponseInfo& _internal_info() const;
  ::tendermint::abci::ResponseInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::tendermint::abci::ResponseInfo* info);
  ::tendermint::abci::ResponseInfo* unsafe_arena_release_info();

  // .tendermint.abci.ResponseSetOption set_option = 5;
  bool has_set_option() const;
  private:
  bool _internal_has_set_option() const;
  public:
  void clear_set_option();
  const ::tendermint::abci::ResponseSetOption& set_option() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseSetOption* release_set_option();
  ::tendermint::abci::ResponseSetOption* mutable_set_option();
  void set_allocated_set_option(::tendermint::abci::ResponseSetOption* set_option);
  private:
  const ::tendermint::abci::ResponseSetOption& _internal_set_option() const;
  ::tendermint::abci::ResponseSetOption* _internal_mutable_set_option();
  public:
  void unsafe_arena_set_allocated_set_option(
      ::tendermint::abci::ResponseSetOption* set_option);
  ::tendermint::abci::ResponseSetOption* unsafe_arena_release_set_option();

  // .tendermint.abci.ResponseInitChain init_chain = 6;
  bool has_init_chain() const;
  private:
  bool _internal_has_init_chain() const;
  public:
  void clear_init_chain();
  const ::tendermint::abci::ResponseInitChain& init_chain() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseInitChain* release_init_chain();
  ::tendermint::abci::ResponseInitChain* mutable_init_chain();
  void set_allocated_init_chain(::tendermint::abci::ResponseInitChain* init_chain);
  private:
  const ::tendermint::abci::ResponseInitChain& _internal_init_chain() const;
  ::tendermint::abci::ResponseInitChain* _internal_mutable_init_chain();
  public:
  void unsafe_arena_set_allocated_init_chain(
      ::tendermint::abci::ResponseInitChain* init_chain);
  ::tendermint::abci::ResponseInitChain* unsafe_arena_release_init_chain();

  // .tendermint.abci.ResponseQuery query = 7;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::tendermint::abci::ResponseQuery& query() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseQuery* release_query();
  ::tendermint::abci::ResponseQuery* mutable_query();
  void set_allocated_query(::tendermint::abci::ResponseQuery* query);
  private:
  const ::tendermint::abci::ResponseQuery& _internal_query() const;
  ::tendermint::abci::ResponseQuery* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::tendermint::abci::ResponseQuery* query);
  ::tendermint::abci::ResponseQuery* unsafe_arena_release_query();

  // .tendermint.abci.ResponseBeginBlock begin_block = 8;
  bool has_begin_block() const;
  private:
  bool _internal_has_begin_block() const;
  public:
  void clear_begin_block();
  const ::tendermint::abci::ResponseBeginBlock& begin_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseBeginBlock* release_begin_block();
  ::tendermint::abci::ResponseBeginBlock* mutable_begin_block();
  void set_allocated_begin_block(::tendermint::abci::ResponseBeginBlock* begin_block);
  private:
  const ::tendermint::abci::ResponseBeginBlock& _internal_begin_block() const;
  ::tendermint::abci::ResponseBeginBlock* _internal_mutable_begin_block();
  public:
  void unsafe_arena_set_allocated_begin_block(
      ::tendermint::abci::ResponseBeginBlock* begin_block);
  ::tendermint::abci::ResponseBeginBlock* unsafe_arena_release_begin_block();

  // .tendermint.abci.ResponseCheckTx check_tx = 9;
  bool has_check_tx() const;
  private:
  bool _internal_has_check_tx() const;
  public:
  void clear_check_tx();
  const ::tendermint::abci::ResponseCheckTx& check_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseCheckTx* release_check_tx();
  ::tendermint::abci::ResponseCheckTx* mutable_check_tx();
  void set_allocated_check_tx(::tendermint::abci::ResponseCheckTx* check_tx);
  private:
  const ::tendermint::abci::ResponseCheckTx& _internal_check_tx() const;
  ::tendermint::abci::ResponseCheckTx* _internal_mutable_check_tx();
  public:
  void unsafe_arena_set_allocated_check_tx(
      ::tendermint::abci::ResponseCheckTx* check_tx);
  ::tendermint::abci::ResponseCheckTx* unsafe_arena_release_check_tx();

  // .tendermint.abci.ResponseDeliverTx deliver_tx = 10;
  bool has_deliver_tx() const;
  private:
  bool _internal_has_deliver_tx() const;
  public:
  void clear_deliver_tx();
  const ::tendermint::abci::ResponseDeliverTx& deliver_tx() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseDeliverTx* release_deliver_tx();
  ::tendermint::abci::ResponseDeliverTx* mutable_deliver_tx();
  void set_allocated_deliver_tx(::tendermint::abci::ResponseDeliverTx* deliver_tx);
  private:
  const ::tendermint::abci::ResponseDeliverTx& _internal_deliver_tx() const;
  ::tendermint::abci::ResponseDeliverTx* _internal_mutable_deliver_tx();
  public:
  void unsafe_arena_set_allocated_deliver_tx(
      ::tendermint::abci::ResponseDeliverTx* deliver_tx);
  ::tendermint::abci::ResponseDeliverTx* unsafe_arena_release_deliver_tx();

  // .tendermint.abci.ResponseEndBlock end_block = 11;
  bool has_end_block() const;
  private:
  bool _internal_has_end_block() const;
  public:
  void clear_end_block();
  const ::tendermint::abci::ResponseEndBlock& end_block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseEndBlock* release_end_block();
  ::tendermint::abci::ResponseEndBlock* mutable_end_block();
  void set_allocated_end_block(::tendermint::abci::ResponseEndBlock* end_block);
  private:
  const ::tendermint::abci::ResponseEndBlock& _internal_end_block() const;
  ::tendermint::abci::ResponseEndBlock* _internal_mutable_end_block();
  public:
  void unsafe_arena_set_allocated_end_block(
      ::tendermint::abci::ResponseEndBlock* end_block);
  ::tendermint::abci::ResponseEndBlock* unsafe_arena_release_end_block();

  // .tendermint.abci.ResponseCommit commit = 12;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::tendermint::abci::ResponseCommit& commit() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseCommit* release_commit();
  ::tendermint::abci::ResponseCommit* mutable_commit();
  void set_allocated_commit(::tendermint::abci::ResponseCommit* commit);
  private:
  const ::tendermint::abci::ResponseCommit& _internal_commit() const;
  ::tendermint::abci::ResponseCommit* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::tendermint::abci::ResponseCommit* commit);
  ::tendermint::abci::ResponseCommit* unsafe_arena_release_commit();

  // .tendermint.abci.ResponseListSnapshots list_snapshots = 13;
  bool has_list_snapshots() const;
  private:
  bool _internal_has_list_snapshots() const;
  public:
  void clear_list_snapshots();
  const ::tendermint::abci::ResponseListSnapshots& list_snapshots() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseListSnapshots* release_list_snapshots();
  ::tendermint::abci::ResponseListSnapshots* mutable_list_snapshots();
  void set_allocated_list_snapshots(::tendermint::abci::ResponseListSnapshots* list_snapshots);
  private:
  const ::tendermint::abci::ResponseListSnapshots& _internal_list_snapshots() const;
  ::tendermint::abci::ResponseListSnapshots* _internal_mutable_list_snapshots();
  public:
  void unsafe_arena_set_allocated_list_snapshots(
      ::tendermint::abci::ResponseListSnapshots* list_snapshots);
  ::tendermint::abci::ResponseListSnapshots* unsafe_arena_release_list_snapshots();

  // .tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14;
  bool has_offer_snapshot() const;
  private:
  bool _internal_has_offer_snapshot() const;
  public:
  void clear_offer_snapshot();
  const ::tendermint::abci::ResponseOfferSnapshot& offer_snapshot() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseOfferSnapshot* release_offer_snapshot();
  ::tendermint::abci::ResponseOfferSnapshot* mutable_offer_snapshot();
  void set_allocated_offer_snapshot(::tendermint::abci::ResponseOfferSnapshot* offer_snapshot);
  private:
  const ::tendermint::abci::ResponseOfferSnapshot& _internal_offer_snapshot() const;
  ::tendermint::abci::ResponseOfferSnapshot* _internal_mutable_offer_snapshot();
  public:
  void unsafe_arena_set_allocated_offer_snapshot(
      ::tendermint::abci::ResponseOfferSnapshot* offer_snapshot);
  ::tendermint::abci::ResponseOfferSnapshot* unsafe_arena_release_offer_snapshot();

  // .tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15;
  bool has_load_snapshot_chunk() const;
  private:
  bool _internal_has_load_snapshot_chunk() const;
  public:
  void clear_load_snapshot_chunk();
  const ::tendermint::abci::ResponseLoadSnapshotChunk& load_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseLoadSnapshotChunk* release_load_snapshot_chunk();
  ::tendermint::abci::ResponseLoadSnapshotChunk* mutable_load_snapshot_chunk();
  void set_allocated_load_snapshot_chunk(::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk);
  private:
  const ::tendermint::abci::ResponseLoadSnapshotChunk& _internal_load_snapshot_chunk() const;
  ::tendermint::abci::ResponseLoadSnapshotChunk* _internal_mutable_load_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_load_snapshot_chunk(
      ::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk);
  ::tendermint::abci::ResponseLoadSnapshotChunk* unsafe_arena_release_load_snapshot_chunk();

  // .tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16;
  bool has_apply_snapshot_chunk() const;
  private:
  bool _internal_has_apply_snapshot_chunk() const;
  public:
  void clear_apply_snapshot_chunk();
  const ::tendermint::abci::ResponseApplySnapshotChunk& apply_snapshot_chunk() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseApplySnapshotChunk* release_apply_snapshot_chunk();
  ::tendermint::abci::ResponseApplySnapshotChunk* mutable_apply_snapshot_chunk();
  void set_allocated_apply_snapshot_chunk(::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk);
  private:
  const ::tendermint::abci::ResponseApplySnapshotChunk& _internal_apply_snapshot_chunk() const;
  ::tendermint::abci::ResponseApplySnapshotChunk* _internal_mutable_apply_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_apply_snapshot_chunk(
      ::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk);
  ::tendermint::abci::ResponseApplySnapshotChunk* unsafe_arena_release_apply_snapshot_chunk();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:tendermint.abci.Response)
 private:
  class _Internal;
  void set_has_exception();
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();
  void set_has_list_snapshots();
  void set_has_offer_snapshot();
  void set_has_load_snapshot_chunk();
  void set_has_apply_snapshot_chunk();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::tendermint::abci::ResponseException* exception_;
    ::tendermint::abci::ResponseEcho* echo_;
    ::tendermint::abci::ResponseFlush* flush_;
    ::tendermint::abci::ResponseInfo* info_;
    ::tendermint::abci::ResponseSetOption* set_option_;
    ::tendermint::abci::ResponseInitChain* init_chain_;
    ::tendermint::abci::ResponseQuery* query_;
    ::tendermint::abci::ResponseBeginBlock* begin_block_;
    ::tendermint::abci::ResponseCheckTx* check_tx_;
    ::tendermint::abci::ResponseDeliverTx* deliver_tx_;
    ::tendermint::abci::ResponseEndBlock* end_block_;
    ::tendermint::abci::ResponseCommit* commit_;
    ::tendermint::abci::ResponseListSnapshots* list_snapshots_;
    ::tendermint::abci::ResponseOfferSnapshot* offer_snapshot_;
    ::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk_;
    ::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseException final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseException) */ {
 public:
  inline ResponseException() : ResponseException(nullptr) {}
  ~ResponseException() override;
  explicit constexpr ResponseException(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseException(const ResponseException& from);
  ResponseException(ResponseException&& from) noexcept
    : ResponseException() {
    *this = ::std::move(from);
  }

  inline ResponseException& operator=(const ResponseException& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseException& operator=(ResponseException&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseException& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseException* internal_default_instance() {
    return reinterpret_cast<const ResponseException*>(
               &_ResponseException_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ResponseException& a, ResponseException& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseException* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseException* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseException* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseException>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseException& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseException& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseException* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseException";
  }
  protected:
  explicit ResponseException(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // string error = 1;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseException)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseEcho final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseEcho) */ {
 public:
  inline ResponseEcho() : ResponseEcho(nullptr) {}
  ~ResponseEcho() override;
  explicit constexpr ResponseEcho(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseEcho(const ResponseEcho& from);
  ResponseEcho(ResponseEcho&& from) noexcept
    : ResponseEcho() {
    *this = ::std::move(from);
  }

  inline ResponseEcho& operator=(const ResponseEcho& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseEcho& operator=(ResponseEcho&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseEcho& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseEcho* internal_default_instance() {
    return reinterpret_cast<const ResponseEcho*>(
               &_ResponseEcho_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ResponseEcho& a, ResponseEcho& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseEcho* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseEcho* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseEcho* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseEcho>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseEcho& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseEcho& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEcho* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseEcho";
  }
  protected:
  explicit ResponseEcho(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseEcho)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseFlush final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseFlush) */ {
 public:
  inline ResponseFlush() : ResponseFlush(nullptr) {}
  explicit constexpr ResponseFlush(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseFlush(const ResponseFlush& from);
  ResponseFlush(ResponseFlush&& from) noexcept
    : ResponseFlush() {
    *this = ::std::move(from);
  }

  inline ResponseFlush& operator=(const ResponseFlush& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseFlush& operator=(ResponseFlush&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseFlush& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseFlush* internal_default_instance() {
    return reinterpret_cast<const ResponseFlush*>(
               &_ResponseFlush_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ResponseFlush& a, ResponseFlush& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseFlush* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseFlush* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseFlush* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseFlush>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResponseFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResponseFlush& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseFlush";
  }
  protected:
  explicit ResponseFlush(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseFlush)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseInfo) */ {
 public:
  inline ResponseInfo() : ResponseInfo(nullptr) {}
  ~ResponseInfo() override;
  explicit constexpr ResponseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseInfo(const ResponseInfo& from);
  ResponseInfo(ResponseInfo&& from) noexcept
    : ResponseInfo() {
    *this = ::std::move(from);
  }

  inline ResponseInfo& operator=(const ResponseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseInfo& operator=(ResponseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseInfo*>(
               &_ResponseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ResponseInfo& a, ResponseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseInfo";
  }
  protected:
  explicit ResponseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kVersionFieldNumber = 2,
    kLastBlockAppHashFieldNumber = 5,
    kAppVersionFieldNumber = 3,
    kLastBlockHeightFieldNumber = 4,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string version = 2;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // bytes last_block_app_hash = 5;
  void clear_last_block_app_hash();
  const std::string& last_block_app_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_block_app_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_block_app_hash();
  PROTOBUF_NODISCARD std::string* release_last_block_app_hash();
  void set_allocated_last_block_app_hash(std::string* last_block_app_hash);
  private:
  const std::string& _internal_last_block_app_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_block_app_hash(const std::string& value);
  std::string* _internal_mutable_last_block_app_hash();
  public:

  // uint64 app_version = 3;
  void clear_app_version();
  uint64_t app_version() const;
  void set_app_version(uint64_t value);
  private:
  uint64_t _internal_app_version() const;
  void _internal_set_app_version(uint64_t value);
  public:

  // int64 last_block_height = 4;
  void clear_last_block_height();
  int64_t last_block_height() const;
  void set_last_block_height(int64_t value);
  private:
  int64_t _internal_last_block_height() const;
  void _internal_set_last_block_height(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_block_app_hash_;
  uint64_t app_version_;
  int64_t last_block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseSetOption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseSetOption) */ {
 public:
  inline ResponseSetOption() : ResponseSetOption(nullptr) {}
  ~ResponseSetOption() override;
  explicit constexpr ResponseSetOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseSetOption(const ResponseSetOption& from);
  ResponseSetOption(ResponseSetOption&& from) noexcept
    : ResponseSetOption() {
    *this = ::std::move(from);
  }

  inline ResponseSetOption& operator=(const ResponseSetOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseSetOption& operator=(ResponseSetOption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseSetOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseSetOption* internal_default_instance() {
    return reinterpret_cast<const ResponseSetOption*>(
               &_ResponseSetOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ResponseSetOption& a, ResponseSetOption& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseSetOption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseSetOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseSetOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseSetOption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseSetOption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseSetOption& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseSetOption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseSetOption";
  }
  protected:
  explicit ResponseSetOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 3,
    kInfoFieldNumber = 4,
    kCodeFieldNumber = 1,
  };
  // string log = 3;
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  // string info = 4;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseSetOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  uint32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseInitChain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseInitChain) */ {
 public:
  inline ResponseInitChain() : ResponseInitChain(nullptr) {}
  ~ResponseInitChain() override;
  explicit constexpr ResponseInitChain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseInitChain(const ResponseInitChain& from);
  ResponseInitChain(ResponseInitChain&& from) noexcept
    : ResponseInitChain() {
    *this = ::std::move(from);
  }

  inline ResponseInitChain& operator=(const ResponseInitChain& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseInitChain& operator=(ResponseInitChain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseInitChain& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseInitChain* internal_default_instance() {
    return reinterpret_cast<const ResponseInitChain*>(
               &_ResponseInitChain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ResponseInitChain& a, ResponseInitChain& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseInitChain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseInitChain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseInitChain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseInitChain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseInitChain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseInitChain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseInitChain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseInitChain";
  }
  protected:
  explicit ResponseInitChain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorsFieldNumber = 2,
    kAppHashFieldNumber = 3,
    kConsensusParamsFieldNumber = 1,
  };
  // repeated .tendermint.abci.ValidatorUpdate validators = 2 [(.gogoproto.nullable) = false];
  int validators_size() const;
  private:
  int _internal_validators_size() const;
  public:
  void clear_validators();
  ::tendermint::abci::ValidatorUpdate* mutable_validators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
      mutable_validators();
  private:
  const ::tendermint::abci::ValidatorUpdate& _internal_validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* _internal_add_validators();
  public:
  const ::tendermint::abci::ValidatorUpdate& validators(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_validators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
      validators() const;

  // bytes app_hash = 3;
  void clear_app_hash();
  const std::string& app_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_hash();
  PROTOBUF_NODISCARD std::string* release_app_hash();
  void set_allocated_app_hash(std::string* app_hash);
  private:
  const std::string& _internal_app_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_hash(const std::string& value);
  std::string* _internal_mutable_app_hash();
  public:

  // .tendermint.abci.ConsensusParams consensus_params = 1;
  bool has_consensus_params() const;
  private:
  bool _internal_has_consensus_params() const;
  public:
  void clear_consensus_params();
  const ::tendermint::abci::ConsensusParams& consensus_params() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ConsensusParams* release_consensus_params();
  ::tendermint::abci::ConsensusParams* mutable_consensus_params();
  void set_allocated_consensus_params(::tendermint::abci::ConsensusParams* consensus_params);
  private:
  const ::tendermint::abci::ConsensusParams& _internal_consensus_params() const;
  ::tendermint::abci::ConsensusParams* _internal_mutable_consensus_params();
  public:
  void unsafe_arena_set_allocated_consensus_params(
      ::tendermint::abci::ConsensusParams* consensus_params);
  ::tendermint::abci::ConsensusParams* unsafe_arena_release_consensus_params();

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseInitChain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > validators_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_hash_;
  ::tendermint::abci::ConsensusParams* consensus_params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseQuery) */ {
 public:
  inline ResponseQuery() : ResponseQuery(nullptr) {}
  ~ResponseQuery() override;
  explicit constexpr ResponseQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseQuery(const ResponseQuery& from);
  ResponseQuery(ResponseQuery&& from) noexcept
    : ResponseQuery() {
    *this = ::std::move(from);
  }

  inline ResponseQuery& operator=(const ResponseQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseQuery& operator=(ResponseQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseQuery* internal_default_instance() {
    return reinterpret_cast<const ResponseQuery*>(
               &_ResponseQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ResponseQuery& a, ResponseQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseQuery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseQuery";
  }
  protected:
  explicit ResponseQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 3,
    kInfoFieldNumber = 4,
    kKeyFieldNumber = 6,
    kValueFieldNumber = 7,
    kCodespaceFieldNumber = 10,
    kProofOpsFieldNumber = 8,
    kIndexFieldNumber = 5,
    kHeightFieldNumber = 9,
    kCodeFieldNumber = 1,
  };
  // string log = 3;
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  // string info = 4;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // bytes key = 6;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 7;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string codespace = 10;
  void clear_codespace();
  const std::string& codespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* codespace);
  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(const std::string& value);
  std::string* _internal_mutable_codespace();
  public:

  // .tendermint.crypto.ProofOps proof_ops = 8;
  bool has_proof_ops() const;
  private:
  bool _internal_has_proof_ops() const;
  public:
  void clear_proof_ops();
  const ::tendermint::crypto::ProofOps& proof_ops() const;
  PROTOBUF_NODISCARD ::tendermint::crypto::ProofOps* release_proof_ops();
  ::tendermint::crypto::ProofOps* mutable_proof_ops();
  void set_allocated_proof_ops(::tendermint::crypto::ProofOps* proof_ops);
  private:
  const ::tendermint::crypto::ProofOps& _internal_proof_ops() const;
  ::tendermint::crypto::ProofOps* _internal_mutable_proof_ops();
  public:
  void unsafe_arena_set_allocated_proof_ops(
      ::tendermint::crypto::ProofOps* proof_ops);
  ::tendermint::crypto::ProofOps* unsafe_arena_release_proof_ops();

  // int64 index = 5;
  void clear_index();
  int64_t index() const;
  void set_index(int64_t value);
  private:
  int64_t _internal_index() const;
  void _internal_set_index(int64_t value);
  public:

  // int64 height = 9;
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
  ::tendermint::crypto::ProofOps* proof_ops_;
  int64_t index_;
  int64_t height_;
  uint32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseBeginBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseBeginBlock) */ {
 public:
  inline ResponseBeginBlock() : ResponseBeginBlock(nullptr) {}
  ~ResponseBeginBlock() override;
  explicit constexpr ResponseBeginBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseBeginBlock(const ResponseBeginBlock& from);
  ResponseBeginBlock(ResponseBeginBlock&& from) noexcept
    : ResponseBeginBlock() {
    *this = ::std::move(from);
  }

  inline ResponseBeginBlock& operator=(const ResponseBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseBeginBlock& operator=(ResponseBeginBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseBeginBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseBeginBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseBeginBlock*>(
               &_ResponseBeginBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ResponseBeginBlock& a, ResponseBeginBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseBeginBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseBeginBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseBeginBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseBeginBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseBeginBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseBeginBlock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseBeginBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseBeginBlock";
  }
  protected:
  explicit ResponseBeginBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .tendermint.abci.Event events = 1 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseBeginBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseCheckTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseCheckTx) */ {
 public:
  inline ResponseCheckTx() : ResponseCheckTx(nullptr) {}
  ~ResponseCheckTx() override;
  explicit constexpr ResponseCheckTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseCheckTx(const ResponseCheckTx& from);
  ResponseCheckTx(ResponseCheckTx&& from) noexcept
    : ResponseCheckTx() {
    *this = ::std::move(from);
  }

  inline ResponseCheckTx& operator=(const ResponseCheckTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseCheckTx& operator=(ResponseCheckTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseCheckTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseCheckTx* internal_default_instance() {
    return reinterpret_cast<const ResponseCheckTx*>(
               &_ResponseCheckTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ResponseCheckTx& a, ResponseCheckTx& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseCheckTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseCheckTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseCheckTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseCheckTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseCheckTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseCheckTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCheckTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseCheckTx";
  }
  protected:
  explicit ResponseCheckTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 7,
    kDataFieldNumber = 2,
    kLogFieldNumber = 3,
    kInfoFieldNumber = 4,
    kCodespaceFieldNumber = 8,
    kGasWantedFieldNumber = 5,
    kGasUsedFieldNumber = 6,
    kCodeFieldNumber = 1,
  };
  // repeated .tendermint.abci.Event events = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string log = 3;
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  // string info = 4;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // string codespace = 8;
  void clear_codespace();
  const std::string& codespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* codespace);
  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(const std::string& value);
  std::string* _internal_mutable_codespace();
  public:

  // int64 gas_wanted = 5 [json_name = "gas_wanted"];
  void clear_gas_wanted();
  int64_t gas_wanted() const;
  void set_gas_wanted(int64_t value);
  private:
  int64_t _internal_gas_wanted() const;
  void _internal_set_gas_wanted(int64_t value);
  public:

  // int64 gas_used = 6 [json_name = "gas_used"];
  void clear_gas_used();
  int64_t gas_used() const;
  void set_gas_used(int64_t value);
  private:
  int64_t _internal_gas_used() const;
  void _internal_set_gas_used(int64_t value);
  public:

  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseCheckTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
  int64_t gas_wanted_;
  int64_t gas_used_;
  uint32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseDeliverTx final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseDeliverTx) */ {
 public:
  inline ResponseDeliverTx() : ResponseDeliverTx(nullptr) {}
  ~ResponseDeliverTx() override;
  explicit constexpr ResponseDeliverTx(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseDeliverTx(const ResponseDeliverTx& from);
  ResponseDeliverTx(ResponseDeliverTx&& from) noexcept
    : ResponseDeliverTx() {
    *this = ::std::move(from);
  }

  inline ResponseDeliverTx& operator=(const ResponseDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseDeliverTx& operator=(ResponseDeliverTx&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseDeliverTx& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseDeliverTx* internal_default_instance() {
    return reinterpret_cast<const ResponseDeliverTx*>(
               &_ResponseDeliverTx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResponseDeliverTx& a, ResponseDeliverTx& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseDeliverTx* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseDeliverTx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseDeliverTx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseDeliverTx>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseDeliverTx& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseDeliverTx& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseDeliverTx* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseDeliverTx";
  }
  protected:
  explicit ResponseDeliverTx(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 7,
    kDataFieldNumber = 2,
    kLogFieldNumber = 3,
    kInfoFieldNumber = 4,
    kCodespaceFieldNumber = 8,
    kGasWantedFieldNumber = 5,
    kGasUsedFieldNumber = 6,
    kCodeFieldNumber = 1,
  };
  // repeated .tendermint.abci.Event events = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string log = 3;
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  // string info = 4;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // string codespace = 8;
  void clear_codespace();
  const std::string& codespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codespace();
  PROTOBUF_NODISCARD std::string* release_codespace();
  void set_allocated_codespace(std::string* codespace);
  private:
  const std::string& _internal_codespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codespace(const std::string& value);
  std::string* _internal_mutable_codespace();
  public:

  // int64 gas_wanted = 5 [json_name = "gas_wanted"];
  void clear_gas_wanted();
  int64_t gas_wanted() const;
  void set_gas_wanted(int64_t value);
  private:
  int64_t _internal_gas_wanted() const;
  void _internal_set_gas_wanted(int64_t value);
  public:

  // int64 gas_used = 6 [json_name = "gas_used"];
  void clear_gas_used();
  int64_t gas_used() const;
  void set_gas_used(int64_t value);
  private:
  int64_t _internal_gas_used() const;
  void _internal_set_gas_used(int64_t value);
  public:

  // uint32 code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseDeliverTx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codespace_;
  int64_t gas_wanted_;
  int64_t gas_used_;
  uint32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseEndBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseEndBlock) */ {
 public:
  inline ResponseEndBlock() : ResponseEndBlock(nullptr) {}
  ~ResponseEndBlock() override;
  explicit constexpr ResponseEndBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseEndBlock(const ResponseEndBlock& from);
  ResponseEndBlock(ResponseEndBlock&& from) noexcept
    : ResponseEndBlock() {
    *this = ::std::move(from);
  }

  inline ResponseEndBlock& operator=(const ResponseEndBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseEndBlock& operator=(ResponseEndBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseEndBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseEndBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseEndBlock*>(
               &_ResponseEndBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ResponseEndBlock& a, ResponseEndBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseEndBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseEndBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseEndBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseEndBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseEndBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseEndBlock& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseEndBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseEndBlock";
  }
  protected:
  explicit ResponseEndBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorUpdatesFieldNumber = 1,
    kEventsFieldNumber = 3,
    kConsensusParamUpdatesFieldNumber = 2,
  };
  // repeated .tendermint.abci.ValidatorUpdate validator_updates = 1 [(.gogoproto.nullable) = false];
  int validator_updates_size() const;
  private:
  int _internal_validator_updates_size() const;
  public:
  void clear_validator_updates();
  ::tendermint::abci::ValidatorUpdate* mutable_validator_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
      mutable_validator_updates();
  private:
  const ::tendermint::abci::ValidatorUpdate& _internal_validator_updates(int index) const;
  ::tendermint::abci::ValidatorUpdate* _internal_add_validator_updates();
  public:
  const ::tendermint::abci::ValidatorUpdate& validator_updates(int index) const;
  ::tendermint::abci::ValidatorUpdate* add_validator_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
      validator_updates() const;

  // repeated .tendermint.abci.Event events = 3 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::tendermint::abci::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
      mutable_events();
  private:
  const ::tendermint::abci::Event& _internal_events(int index) const;
  ::tendermint::abci::Event* _internal_add_events();
  public:
  const ::tendermint::abci::Event& events(int index) const;
  ::tendermint::abci::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
      events() const;

  // .tendermint.abci.ConsensusParams consensus_param_updates = 2;
  bool has_consensus_param_updates() const;
  private:
  bool _internal_has_consensus_param_updates() const;
  public:
  void clear_consensus_param_updates();
  const ::tendermint::abci::ConsensusParams& consensus_param_updates() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ConsensusParams* release_consensus_param_updates();
  ::tendermint::abci::ConsensusParams* mutable_consensus_param_updates();
  void set_allocated_consensus_param_updates(::tendermint::abci::ConsensusParams* consensus_param_updates);
  private:
  const ::tendermint::abci::ConsensusParams& _internal_consensus_param_updates() const;
  ::tendermint::abci::ConsensusParams* _internal_mutable_consensus_param_updates();
  public:
  void unsafe_arena_set_allocated_consensus_param_updates(
      ::tendermint::abci::ConsensusParams* consensus_param_updates);
  ::tendermint::abci::ConsensusParams* unsafe_arena_release_consensus_param_updates();

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseEndBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate > validator_updates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event > events_;
  ::tendermint::abci::ConsensusParams* consensus_param_updates_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseCommit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseCommit) */ {
 public:
  inline ResponseCommit() : ResponseCommit(nullptr) {}
  ~ResponseCommit() override;
  explicit constexpr ResponseCommit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseCommit(const ResponseCommit& from);
  ResponseCommit(ResponseCommit&& from) noexcept
    : ResponseCommit() {
    *this = ::std::move(from);
  }

  inline ResponseCommit& operator=(const ResponseCommit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseCommit& operator=(ResponseCommit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseCommit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseCommit* internal_default_instance() {
    return reinterpret_cast<const ResponseCommit*>(
               &_ResponseCommit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ResponseCommit& a, ResponseCommit& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseCommit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseCommit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseCommit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseCommit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseCommit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseCommit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseCommit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseCommit";
  }
  protected:
  explicit ResponseCommit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kRetainHeightFieldNumber = 3,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 retain_height = 3;
  void clear_retain_height();
  int64_t retain_height() const;
  void set_retain_height(int64_t value);
  private:
  int64_t _internal_retain_height() const;
  void _internal_set_retain_height(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseCommit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int64_t retain_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseListSnapshots final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseListSnapshots) */ {
 public:
  inline ResponseListSnapshots() : ResponseListSnapshots(nullptr) {}
  ~ResponseListSnapshots() override;
  explicit constexpr ResponseListSnapshots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseListSnapshots(const ResponseListSnapshots& from);
  ResponseListSnapshots(ResponseListSnapshots&& from) noexcept
    : ResponseListSnapshots() {
    *this = ::std::move(from);
  }

  inline ResponseListSnapshots& operator=(const ResponseListSnapshots& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseListSnapshots& operator=(ResponseListSnapshots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseListSnapshots& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseListSnapshots* internal_default_instance() {
    return reinterpret_cast<const ResponseListSnapshots*>(
               &_ResponseListSnapshots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ResponseListSnapshots& a, ResponseListSnapshots& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseListSnapshots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseListSnapshots* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseListSnapshots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseListSnapshots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseListSnapshots& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseListSnapshots& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseListSnapshots* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseListSnapshots";
  }
  protected:
  explicit ResponseListSnapshots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotsFieldNumber = 1,
  };
  // repeated .tendermint.abci.Snapshot snapshots = 1;
  int snapshots_size() const;
  private:
  int _internal_snapshots_size() const;
  public:
  void clear_snapshots();
  ::tendermint::abci::Snapshot* mutable_snapshots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >*
      mutable_snapshots();
  private:
  const ::tendermint::abci::Snapshot& _internal_snapshots(int index) const;
  ::tendermint::abci::Snapshot* _internal_add_snapshots();
  public:
  const ::tendermint::abci::Snapshot& snapshots(int index) const;
  ::tendermint::abci::Snapshot* add_snapshots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >&
      snapshots() const;

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseListSnapshots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot > snapshots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseOfferSnapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseOfferSnapshot) */ {
 public:
  inline ResponseOfferSnapshot() : ResponseOfferSnapshot(nullptr) {}
  ~ResponseOfferSnapshot() override;
  explicit constexpr ResponseOfferSnapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseOfferSnapshot(const ResponseOfferSnapshot& from);
  ResponseOfferSnapshot(ResponseOfferSnapshot&& from) noexcept
    : ResponseOfferSnapshot() {
    *this = ::std::move(from);
  }

  inline ResponseOfferSnapshot& operator=(const ResponseOfferSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseOfferSnapshot& operator=(ResponseOfferSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseOfferSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseOfferSnapshot* internal_default_instance() {
    return reinterpret_cast<const ResponseOfferSnapshot*>(
               &_ResponseOfferSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ResponseOfferSnapshot& a, ResponseOfferSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseOfferSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseOfferSnapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseOfferSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseOfferSnapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseOfferSnapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseOfferSnapshot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseOfferSnapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseOfferSnapshot";
  }
  protected:
  explicit ResponseOfferSnapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseOfferSnapshot_Result Result;
  static constexpr Result UNKNOWN =
    ResponseOfferSnapshot_Result_UNKNOWN;
  static constexpr Result ACCEPT =
    ResponseOfferSnapshot_Result_ACCEPT;
  static constexpr Result ABORT =
    ResponseOfferSnapshot_Result_ABORT;
  static constexpr Result REJECT =
    ResponseOfferSnapshot_Result_REJECT;
  static constexpr Result REJECT_FORMAT =
    ResponseOfferSnapshot_Result_REJECT_FORMAT;
  static constexpr Result REJECT_SENDER =
    ResponseOfferSnapshot_Result_REJECT_SENDER;
  static inline bool Result_IsValid(int value) {
    return ResponseOfferSnapshot_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    ResponseOfferSnapshot_Result_Result_MIN;
  static constexpr Result Result_MAX =
    ResponseOfferSnapshot_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    ResponseOfferSnapshot_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return ResponseOfferSnapshot_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return ResponseOfferSnapshot_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return ResponseOfferSnapshot_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .tendermint.abci.ResponseOfferSnapshot.Result result = 1;
  void clear_result();
  ::tendermint::abci::ResponseOfferSnapshot_Result result() const;
  void set_result(::tendermint::abci::ResponseOfferSnapshot_Result value);
  private:
  ::tendermint::abci::ResponseOfferSnapshot_Result _internal_result() const;
  void _internal_set_result(::tendermint::abci::ResponseOfferSnapshot_Result value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseOfferSnapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseLoadSnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseLoadSnapshotChunk) */ {
 public:
  inline ResponseLoadSnapshotChunk() : ResponseLoadSnapshotChunk(nullptr) {}
  ~ResponseLoadSnapshotChunk() override;
  explicit constexpr ResponseLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseLoadSnapshotChunk(const ResponseLoadSnapshotChunk& from);
  ResponseLoadSnapshotChunk(ResponseLoadSnapshotChunk&& from) noexcept
    : ResponseLoadSnapshotChunk() {
    *this = ::std::move(from);
  }

  inline ResponseLoadSnapshotChunk& operator=(const ResponseLoadSnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseLoadSnapshotChunk& operator=(ResponseLoadSnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseLoadSnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseLoadSnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const ResponseLoadSnapshotChunk*>(
               &_ResponseLoadSnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ResponseLoadSnapshotChunk& a, ResponseLoadSnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseLoadSnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseLoadSnapshotChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseLoadSnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseLoadSnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseLoadSnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseLoadSnapshotChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseLoadSnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseLoadSnapshotChunk";
  }
  protected:
  explicit ResponseLoadSnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // bytes chunk = 1;
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseLoadSnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ResponseApplySnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ResponseApplySnapshotChunk) */ {
 public:
  inline ResponseApplySnapshotChunk() : ResponseApplySnapshotChunk(nullptr) {}
  ~ResponseApplySnapshotChunk() override;
  explicit constexpr ResponseApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResponseApplySnapshotChunk(const ResponseApplySnapshotChunk& from);
  ResponseApplySnapshotChunk(ResponseApplySnapshotChunk&& from) noexcept
    : ResponseApplySnapshotChunk() {
    *this = ::std::move(from);
  }

  inline ResponseApplySnapshotChunk& operator=(const ResponseApplySnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseApplySnapshotChunk& operator=(ResponseApplySnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseApplySnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResponseApplySnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const ResponseApplySnapshotChunk*>(
               &_ResponseApplySnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ResponseApplySnapshotChunk& a, ResponseApplySnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(ResponseApplySnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseApplySnapshotChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseApplySnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResponseApplySnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResponseApplySnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResponseApplySnapshotChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseApplySnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ResponseApplySnapshotChunk";
  }
  protected:
  explicit ResponseApplySnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResponseApplySnapshotChunk_Result Result;
  static constexpr Result UNKNOWN =
    ResponseApplySnapshotChunk_Result_UNKNOWN;
  static constexpr Result ACCEPT =
    ResponseApplySnapshotChunk_Result_ACCEPT;
  static constexpr Result ABORT =
    ResponseApplySnapshotChunk_Result_ABORT;
  static constexpr Result RETRY =
    ResponseApplySnapshotChunk_Result_RETRY;
  static constexpr Result RETRY_SNAPSHOT =
    ResponseApplySnapshotChunk_Result_RETRY_SNAPSHOT;
  static constexpr Result REJECT_SNAPSHOT =
    ResponseApplySnapshotChunk_Result_REJECT_SNAPSHOT;
  static inline bool Result_IsValid(int value) {
    return ResponseApplySnapshotChunk_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    ResponseApplySnapshotChunk_Result_Result_MIN;
  static constexpr Result Result_MAX =
    ResponseApplySnapshotChunk_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    ResponseApplySnapshotChunk_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return ResponseApplySnapshotChunk_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return ResponseApplySnapshotChunk_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Result* value) {
    return ResponseApplySnapshotChunk_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRefetchChunksFieldNumber = 2,
    kRejectSendersFieldNumber = 3,
    kResultFieldNumber = 1,
  };
  // repeated uint32 refetch_chunks = 2;
  int refetch_chunks_size() const;
  private:
  int _internal_refetch_chunks_size() const;
  public:
  void clear_refetch_chunks();
  private:
  uint32_t _internal_refetch_chunks(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_refetch_chunks() const;
  void _internal_add_refetch_chunks(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_refetch_chunks();
  public:
  uint32_t refetch_chunks(int index) const;
  void set_refetch_chunks(int index, uint32_t value);
  void add_refetch_chunks(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      refetch_chunks() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_refetch_chunks();

  // repeated string reject_senders = 3;
  int reject_senders_size() const;
  private:
  int _internal_reject_senders_size() const;
  public:
  void clear_reject_senders();
  const std::string& reject_senders(int index) const;
  std::string* mutable_reject_senders(int index);
  void set_reject_senders(int index, const std::string& value);
  void set_reject_senders(int index, std::string&& value);
  void set_reject_senders(int index, const char* value);
  void set_reject_senders(int index, const char* value, size_t size);
  std::string* add_reject_senders();
  void add_reject_senders(const std::string& value);
  void add_reject_senders(std::string&& value);
  void add_reject_senders(const char* value);
  void add_reject_senders(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& reject_senders() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_reject_senders();
  private:
  const std::string& _internal_reject_senders(int index) const;
  std::string* _internal_add_reject_senders();
  public:

  // .tendermint.abci.ResponseApplySnapshotChunk.Result result = 1;
  void clear_result();
  ::tendermint::abci::ResponseApplySnapshotChunk_Result result() const;
  void set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value);
  private:
  ::tendermint::abci::ResponseApplySnapshotChunk_Result _internal_result() const;
  void _internal_set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ResponseApplySnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > refetch_chunks_;
  mutable std::atomic<int> _refetch_chunks_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> reject_senders_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ConsensusParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ConsensusParams) */ {
 public:
  inline ConsensusParams() : ConsensusParams(nullptr) {}
  ~ConsensusParams() override;
  explicit constexpr ConsensusParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsensusParams(const ConsensusParams& from);
  ConsensusParams(ConsensusParams&& from) noexcept
    : ConsensusParams() {
    *this = ::std::move(from);
  }

  inline ConsensusParams& operator=(const ConsensusParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsensusParams& operator=(ConsensusParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsensusParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsensusParams* internal_default_instance() {
    return reinterpret_cast<const ConsensusParams*>(
               &_ConsensusParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ConsensusParams& a, ConsensusParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsensusParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsensusParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConsensusParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConsensusParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsensusParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsensusParams& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsensusParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ConsensusParams";
  }
  protected:
  explicit ConsensusParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
    kEvidenceFieldNumber = 2,
    kValidatorFieldNumber = 3,
    kVersionFieldNumber = 4,
  };
  // .tendermint.abci.BlockParams block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::tendermint::abci::BlockParams& block() const;
  PROTOBUF_NODISCARD ::tendermint::abci::BlockParams* release_block();
  ::tendermint::abci::BlockParams* mutable_block();
  void set_allocated_block(::tendermint::abci::BlockParams* block);
  private:
  const ::tendermint::abci::BlockParams& _internal_block() const;
  ::tendermint::abci::BlockParams* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::tendermint::abci::BlockParams* block);
  ::tendermint::abci::BlockParams* unsafe_arena_release_block();

  // .tendermint.types.EvidenceParams evidence = 2;
  bool has_evidence() const;
  private:
  bool _internal_has_evidence() const;
  public:
  void clear_evidence();
  const ::tendermint::types::EvidenceParams& evidence() const;
  PROTOBUF_NODISCARD ::tendermint::types::EvidenceParams* release_evidence();
  ::tendermint::types::EvidenceParams* mutable_evidence();
  void set_allocated_evidence(::tendermint::types::EvidenceParams* evidence);
  private:
  const ::tendermint::types::EvidenceParams& _internal_evidence() const;
  ::tendermint::types::EvidenceParams* _internal_mutable_evidence();
  public:
  void unsafe_arena_set_allocated_evidence(
      ::tendermint::types::EvidenceParams* evidence);
  ::tendermint::types::EvidenceParams* unsafe_arena_release_evidence();

  // .tendermint.types.ValidatorParams validator = 3;
  bool has_validator() const;
  private:
  bool _internal_has_validator() const;
  public:
  void clear_validator();
  const ::tendermint::types::ValidatorParams& validator() const;
  PROTOBUF_NODISCARD ::tendermint::types::ValidatorParams* release_validator();
  ::tendermint::types::ValidatorParams* mutable_validator();
  void set_allocated_validator(::tendermint::types::ValidatorParams* validator);
  private:
  const ::tendermint::types::ValidatorParams& _internal_validator() const;
  ::tendermint::types::ValidatorParams* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::tendermint::types::ValidatorParams* validator);
  ::tendermint::types::ValidatorParams* unsafe_arena_release_validator();

  // .tendermint.types.VersionParams version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::tendermint::types::VersionParams& version() const;
  PROTOBUF_NODISCARD ::tendermint::types::VersionParams* release_version();
  ::tendermint::types::VersionParams* mutable_version();
  void set_allocated_version(::tendermint::types::VersionParams* version);
  private:
  const ::tendermint::types::VersionParams& _internal_version() const;
  ::tendermint::types::VersionParams* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::tendermint::types::VersionParams* version);
  ::tendermint::types::VersionParams* unsafe_arena_release_version();

  // @@protoc_insertion_point(class_scope:tendermint.abci.ConsensusParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tendermint::abci::BlockParams* block_;
  ::tendermint::types::EvidenceParams* evidence_;
  ::tendermint::types::ValidatorParams* validator_;
  ::tendermint::types::VersionParams* version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class BlockParams final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.BlockParams) */ {
 public:
  inline BlockParams() : BlockParams(nullptr) {}
  ~BlockParams() override;
  explicit constexpr BlockParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockParams(const BlockParams& from);
  BlockParams(BlockParams&& from) noexcept
    : BlockParams() {
    *this = ::std::move(from);
  }

  inline BlockParams& operator=(const BlockParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockParams& operator=(BlockParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockParams* internal_default_instance() {
    return reinterpret_cast<const BlockParams*>(
               &_BlockParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(BlockParams& a, BlockParams& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockParams>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockParams& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockParams& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.BlockParams";
  }
  protected:
  explicit BlockParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxBytesFieldNumber = 1,
    kMaxGasFieldNumber = 2,
  };
  // int64 max_bytes = 1;
  void clear_max_bytes();
  int64_t max_bytes() const;
  void set_max_bytes(int64_t value);
  private:
  int64_t _internal_max_bytes() const;
  void _internal_set_max_bytes(int64_t value);
  public:

  // int64 max_gas = 2;
  void clear_max_gas();
  int64_t max_gas() const;
  void set_max_gas(int64_t value);
  private:
  int64_t _internal_max_gas() const;
  void _internal_set_max_gas(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.BlockParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t max_bytes_;
  int64_t max_gas_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class LastCommitInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.LastCommitInfo) */ {
 public:
  inline LastCommitInfo() : LastCommitInfo(nullptr) {}
  ~LastCommitInfo() override;
  explicit constexpr LastCommitInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LastCommitInfo(const LastCommitInfo& from);
  LastCommitInfo(LastCommitInfo&& from) noexcept
    : LastCommitInfo() {
    *this = ::std::move(from);
  }

  inline LastCommitInfo& operator=(const LastCommitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LastCommitInfo& operator=(LastCommitInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LastCommitInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LastCommitInfo* internal_default_instance() {
    return reinterpret_cast<const LastCommitInfo*>(
               &_LastCommitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(LastCommitInfo& a, LastCommitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LastCommitInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LastCommitInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LastCommitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LastCommitInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LastCommitInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LastCommitInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LastCommitInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.LastCommitInfo";
  }
  protected:
  explicit LastCommitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVotesFieldNumber = 2,
    kRoundFieldNumber = 1,
  };
  // repeated .tendermint.abci.VoteInfo votes = 2 [(.gogoproto.nullable) = false];
  int votes_size() const;
  private:
  int _internal_votes_size() const;
  public:
  void clear_votes();
  ::tendermint::abci::VoteInfo* mutable_votes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >*
      mutable_votes();
  private:
  const ::tendermint::abci::VoteInfo& _internal_votes(int index) const;
  ::tendermint::abci::VoteInfo* _internal_add_votes();
  public:
  const ::tendermint::abci::VoteInfo& votes(int index) const;
  ::tendermint::abci::VoteInfo* add_votes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >&
      votes() const;

  // int32 round = 1;
  void clear_round();
  int32_t round() const;
  void set_round(int32_t value);
  private:
  int32_t _internal_round() const;
  void _internal_set_round(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.LastCommitInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo > votes_;
  int32_t round_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .tendermint.abci.EventAttribute attributes = 2 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "attributes,omitempty"];
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::tendermint::abci::EventAttribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >*
      mutable_attributes();
  private:
  const ::tendermint::abci::EventAttribute& _internal_attributes(int index) const;
  ::tendermint::abci::EventAttribute* _internal_add_attributes();
  public:
  const ::tendermint::abci::EventAttribute& attributes(int index) const;
  ::tendermint::abci::EventAttribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >&
      attributes() const;

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class EventAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.EventAttribute) */ {
 public:
  inline EventAttribute() : EventAttribute(nullptr) {}
  ~EventAttribute() override;
  explicit constexpr EventAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventAttribute(const EventAttribute& from);
  EventAttribute(EventAttribute&& from) noexcept
    : EventAttribute() {
    *this = ::std::move(from);
  }

  inline EventAttribute& operator=(const EventAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventAttribute& operator=(EventAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventAttribute* internal_default_instance() {
    return reinterpret_cast<const EventAttribute*>(
               &_EventAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(EventAttribute& a, EventAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(EventAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventAttribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventAttribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventAttribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventAttribute& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventAttribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.EventAttribute";
  }
  protected:
  explicit EventAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  // bytes key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // bool index = 3;
  void clear_index();
  bool index() const;
  void set_index(bool value);
  private:
  bool _internal_index() const;
  void _internal_set_index(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.EventAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  bool index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class TxResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.TxResult) */ {
 public:
  inline TxResult() : TxResult(nullptr) {}
  ~TxResult() override;
  explicit constexpr TxResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxResult(const TxResult& from);
  TxResult(TxResult&& from) noexcept
    : TxResult() {
    *this = ::std::move(from);
  }

  inline TxResult& operator=(const TxResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxResult& operator=(TxResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxResult* internal_default_instance() {
    return reinterpret_cast<const TxResult*>(
               &_TxResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TxResult& a, TxResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TxResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TxResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.TxResult";
  }
  protected:
  explicit TxResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 3,
    kResultFieldNumber = 4,
    kHeightFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // bytes tx = 3;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // .tendermint.abci.ResponseDeliverTx result = 4 [(.gogoproto.nullable) = false];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::tendermint::abci::ResponseDeliverTx& result() const;
  PROTOBUF_NODISCARD ::tendermint::abci::ResponseDeliverTx* release_result();
  ::tendermint::abci::ResponseDeliverTx* mutable_result();
  void set_allocated_result(::tendermint::abci::ResponseDeliverTx* result);
  private:
  const ::tendermint::abci::ResponseDeliverTx& _internal_result() const;
  ::tendermint::abci::ResponseDeliverTx* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::tendermint::abci::ResponseDeliverTx* result);
  ::tendermint::abci::ResponseDeliverTx* unsafe_arena_release_result();

  // int64 height = 1;
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // uint32 index = 2;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.TxResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
  ::tendermint::abci::ResponseDeliverTx* result_;
  int64_t height_;
  uint32_t index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Validator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Validator) */ {
 public:
  inline Validator() : Validator(nullptr) {}
  ~Validator() override;
  explicit constexpr Validator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Validator(const Validator& from);
  Validator(Validator&& from) noexcept
    : Validator() {
    *this = ::std::move(from);
  }

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }
  inline Validator& operator=(Validator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Validator& default_instance() {
    return *internal_default_instance();
  }
  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Validator& a, Validator& b) {
    a.Swap(&b);
  }
  inline void Swap(Validator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Validator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Validator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Validator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Validator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Validator& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Validator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.Validator";
  }
  protected:
  explicit Validator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPowerFieldNumber = 3,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int64 power = 3;
  void clear_power();
  int64_t power() const;
  void set_power(int64_t value);
  private:
  int64_t _internal_power() const;
  void _internal_set_power(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.Validator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  int64_t power_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class ValidatorUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.ValidatorUpdate) */ {
 public:
  inline ValidatorUpdate() : ValidatorUpdate(nullptr) {}
  ~ValidatorUpdate() override;
  explicit constexpr ValidatorUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidatorUpdate(const ValidatorUpdate& from);
  ValidatorUpdate(ValidatorUpdate&& from) noexcept
    : ValidatorUpdate() {
    *this = ::std::move(from);
  }

  inline ValidatorUpdate& operator=(const ValidatorUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorUpdate& operator=(ValidatorUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidatorUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidatorUpdate* internal_default_instance() {
    return reinterpret_cast<const ValidatorUpdate*>(
               &_ValidatorUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ValidatorUpdate& a, ValidatorUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidatorUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidatorUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidatorUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidatorUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.ValidatorUpdate";
  }
  protected:
  explicit ValidatorUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPubKeyFieldNumber = 1,
    kPowerFieldNumber = 2,
  };
  // .tendermint.crypto.PublicKey pub_key = 1 [(.gogoproto.nullable) = false];
  bool has_pub_key() const;
  private:
  bool _internal_has_pub_key() const;
  public:
  void clear_pub_key();
  const ::tendermint::crypto::PublicKey& pub_key() const;
  PROTOBUF_NODISCARD ::tendermint::crypto::PublicKey* release_pub_key();
  ::tendermint::crypto::PublicKey* mutable_pub_key();
  void set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key);
  private:
  const ::tendermint::crypto::PublicKey& _internal_pub_key() const;
  ::tendermint::crypto::PublicKey* _internal_mutable_pub_key();
  public:
  void unsafe_arena_set_allocated_pub_key(
      ::tendermint::crypto::PublicKey* pub_key);
  ::tendermint::crypto::PublicKey* unsafe_arena_release_pub_key();

  // int64 power = 2;
  void clear_power();
  int64_t power() const;
  void set_power(int64_t value);
  private:
  int64_t _internal_power() const;
  void _internal_set_power(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.ValidatorUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tendermint::crypto::PublicKey* pub_key_;
  int64_t power_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class VoteInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.VoteInfo) */ {
 public:
  inline VoteInfo() : VoteInfo(nullptr) {}
  ~VoteInfo() override;
  explicit constexpr VoteInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteInfo(const VoteInfo& from);
  VoteInfo(VoteInfo&& from) noexcept
    : VoteInfo() {
    *this = ::std::move(from);
  }

  inline VoteInfo& operator=(const VoteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteInfo& operator=(VoteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteInfo* internal_default_instance() {
    return reinterpret_cast<const VoteInfo*>(
               &_VoteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(VoteInfo& a, VoteInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VoteInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VoteInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.VoteInfo";
  }
  protected:
  explicit VoteInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorFieldNumber = 1,
    kSignedLastBlockFieldNumber = 2,
  };
  // .tendermint.abci.Validator validator = 1 [(.gogoproto.nullable) = false];
  bool has_validator() const;
  private:
  bool _internal_has_validator() const;
  public:
  void clear_validator();
  const ::tendermint::abci::Validator& validator() const;
  PROTOBUF_NODISCARD ::tendermint::abci::Validator* release_validator();
  ::tendermint::abci::Validator* mutable_validator();
  void set_allocated_validator(::tendermint::abci::Validator* validator);
  private:
  const ::tendermint::abci::Validator& _internal_validator() const;
  ::tendermint::abci::Validator* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::tendermint::abci::Validator* validator);
  ::tendermint::abci::Validator* unsafe_arena_release_validator();

  // bool signed_last_block = 2;
  void clear_signed_last_block();
  bool signed_last_block() const;
  void set_signed_last_block(bool value);
  private:
  bool _internal_signed_last_block() const;
  void _internal_set_signed_last_block(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.VoteInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tendermint::abci::Validator* validator_;
  bool signed_last_block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Evidence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Evidence) */ {
 public:
  inline Evidence() : Evidence(nullptr) {}
  ~Evidence() override;
  explicit constexpr Evidence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Evidence(const Evidence& from);
  Evidence(Evidence&& from) noexcept
    : Evidence() {
    *this = ::std::move(from);
  }

  inline Evidence& operator=(const Evidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline Evidence& operator=(Evidence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Evidence& default_instance() {
    return *internal_default_instance();
  }
  static inline const Evidence* internal_default_instance() {
    return reinterpret_cast<const Evidence*>(
               &_Evidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(Evidence& a, Evidence& b) {
    a.Swap(&b);
  }
  inline void Swap(Evidence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Evidence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Evidence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Evidence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Evidence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Evidence& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Evidence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.Evidence";
  }
  protected:
  explicit Evidence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorFieldNumber = 2,
    kTimeFieldNumber = 4,
    kHeightFieldNumber = 3,
    kTotalVotingPowerFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // .tendermint.abci.Validator validator = 2 [(.gogoproto.nullable) = false];
  bool has_validator() const;
  private:
  bool _internal_has_validator() const;
  public:
  void clear_validator();
  const ::tendermint::abci::Validator& validator() const;
  PROTOBUF_NODISCARD ::tendermint::abci::Validator* release_validator();
  ::tendermint::abci::Validator* mutable_validator();
  void set_allocated_validator(::tendermint::abci::Validator* validator);
  private:
  const ::tendermint::abci::Validator& _internal_validator() const;
  ::tendermint::abci::Validator* _internal_mutable_validator();
  public:
  void unsafe_arena_set_allocated_validator(
      ::tendermint::abci::Validator* validator);
  ::tendermint::abci::Validator* unsafe_arena_release_validator();

  // .google.protobuf.Timestamp time = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // int64 height = 3;
  void clear_height();
  int64_t height() const;
  void set_height(int64_t value);
  private:
  int64_t _internal_height() const;
  void _internal_set_height(int64_t value);
  public:

  // int64 total_voting_power = 5;
  void clear_total_voting_power();
  int64_t total_voting_power() const;
  void set_total_voting_power(int64_t value);
  private:
  int64_t _internal_total_voting_power() const;
  void _internal_set_total_voting_power(int64_t value);
  public:

  // .tendermint.abci.EvidenceType type = 1;
  void clear_type();
  ::tendermint::abci::EvidenceType type() const;
  void set_type(::tendermint::abci::EvidenceType value);
  private:
  ::tendermint::abci::EvidenceType _internal_type() const;
  void _internal_set_type(::tendermint::abci::EvidenceType value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.Evidence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::tendermint::abci::Validator* validator_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* time_;
  int64_t height_;
  int64_t total_voting_power_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// -------------------------------------------------------------------

class Snapshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tendermint.abci.Snapshot) */ {
 public:
  inline Snapshot() : Snapshot(nullptr) {}
  ~Snapshot() override;
  explicit constexpr Snapshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Snapshot(const Snapshot& from);
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Snapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Snapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snapshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Snapshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Snapshot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snapshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tendermint.abci.Snapshot";
  }
  protected:
  explicit Snapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 4,
    kMetadataFieldNumber = 5,
    kHeightFieldNumber = 1,
    kFormatFieldNumber = 2,
    kChunksFieldNumber = 3,
  };
  // bytes hash = 4;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // bytes metadata = 5;
  void clear_metadata();
  const std::string& metadata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadata();
  PROTOBUF_NODISCARD std::string* release_metadata();
  void set_allocated_metadata(std::string* metadata);
  private:
  const std::string& _internal_metadata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadata(const std::string& value);
  std::string* _internal_mutable_metadata();
  public:

  // uint64 height = 1;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // uint32 format = 2;
  void clear_format();
  uint32_t format() const;
  void set_format(uint32_t value);
  private:
  uint32_t _internal_format() const;
  void _internal_set_format(uint32_t value);
  public:

  // uint32 chunks = 3;
  void clear_chunks();
  uint32_t chunks() const;
  void set_chunks(uint32_t value);
  private:
  uint32_t _internal_chunks() const;
  void _internal_set_chunks(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tendermint.abci.Snapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadata_;
  uint64_t height_;
  uint32_t format_;
  uint32_t chunks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tendermint_2fabci_2ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// .tendermint.abci.RequestEcho echo = 1;
inline bool Request::_internal_has_echo() const {
  return value_case() == kEcho;
}
inline bool Request::has_echo() const {
  return _internal_has_echo();
}
inline void Request::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Request::clear_echo() {
  if (_internal_has_echo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.echo_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestEcho* Request::release_echo() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.echo)
  if (_internal_has_echo()) {
    clear_has_value();
      ::tendermint::abci::RequestEcho* temp = value_.echo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestEcho& Request::_internal_echo() const {
  return _internal_has_echo()
      ? *value_.echo_
      : reinterpret_cast< ::tendermint::abci::RequestEcho&>(::tendermint::abci::_RequestEcho_default_instance_);
}
inline const ::tendermint::abci::RequestEcho& Request::echo() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.echo)
  return _internal_echo();
}
inline ::tendermint::abci::RequestEcho* Request::unsafe_arena_release_echo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.echo)
  if (_internal_has_echo()) {
    clear_has_value();
    ::tendermint::abci::RequestEcho* temp = value_.echo_;
    value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_echo(::tendermint::abci::RequestEcho* echo) {
  clear_value();
  if (echo) {
    set_has_echo();
    value_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.echo)
}
inline ::tendermint::abci::RequestEcho* Request::_internal_mutable_echo() {
  if (!_internal_has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = CreateMaybeMessage< ::tendermint::abci::RequestEcho >(GetArenaForAllocation());
  }
  return value_.echo_;
}
inline ::tendermint::abci::RequestEcho* Request::mutable_echo() {
  ::tendermint::abci::RequestEcho* _msg = _internal_mutable_echo();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.echo)
  return _msg;
}

// .tendermint.abci.RequestFlush flush = 2;
inline bool Request::_internal_has_flush() const {
  return value_case() == kFlush;
}
inline bool Request::has_flush() const {
  return _internal_has_flush();
}
inline void Request::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Request::clear_flush() {
  if (_internal_has_flush()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.flush_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestFlush* Request::release_flush() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.flush)
  if (_internal_has_flush()) {
    clear_has_value();
      ::tendermint::abci::RequestFlush* temp = value_.flush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestFlush& Request::_internal_flush() const {
  return _internal_has_flush()
      ? *value_.flush_
      : reinterpret_cast< ::tendermint::abci::RequestFlush&>(::tendermint::abci::_RequestFlush_default_instance_);
}
inline const ::tendermint::abci::RequestFlush& Request::flush() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.flush)
  return _internal_flush();
}
inline ::tendermint::abci::RequestFlush* Request::unsafe_arena_release_flush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.flush)
  if (_internal_has_flush()) {
    clear_has_value();
    ::tendermint::abci::RequestFlush* temp = value_.flush_;
    value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_flush(::tendermint::abci::RequestFlush* flush) {
  clear_value();
  if (flush) {
    set_has_flush();
    value_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.flush)
}
inline ::tendermint::abci::RequestFlush* Request::_internal_mutable_flush() {
  if (!_internal_has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = CreateMaybeMessage< ::tendermint::abci::RequestFlush >(GetArenaForAllocation());
  }
  return value_.flush_;
}
inline ::tendermint::abci::RequestFlush* Request::mutable_flush() {
  ::tendermint::abci::RequestFlush* _msg = _internal_mutable_flush();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.flush)
  return _msg;
}

// .tendermint.abci.RequestInfo info = 3;
inline bool Request::_internal_has_info() const {
  return value_case() == kInfo;
}
inline bool Request::has_info() const {
  return _internal_has_info();
}
inline void Request::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Request::clear_info() {
  if (_internal_has_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.info_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestInfo* Request::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.info)
  if (_internal_has_info()) {
    clear_has_value();
      ::tendermint::abci::RequestInfo* temp = value_.info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestInfo& Request::_internal_info() const {
  return _internal_has_info()
      ? *value_.info_
      : reinterpret_cast< ::tendermint::abci::RequestInfo&>(::tendermint::abci::_RequestInfo_default_instance_);
}
inline const ::tendermint::abci::RequestInfo& Request::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.info)
  return _internal_info();
}
inline ::tendermint::abci::RequestInfo* Request::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.info)
  if (_internal_has_info()) {
    clear_has_value();
    ::tendermint::abci::RequestInfo* temp = value_.info_;
    value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_info(::tendermint::abci::RequestInfo* info) {
  clear_value();
  if (info) {
    set_has_info();
    value_.info_ = info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.info)
}
inline ::tendermint::abci::RequestInfo* Request::_internal_mutable_info() {
  if (!_internal_has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = CreateMaybeMessage< ::tendermint::abci::RequestInfo >(GetArenaForAllocation());
  }
  return value_.info_;
}
inline ::tendermint::abci::RequestInfo* Request::mutable_info() {
  ::tendermint::abci::RequestInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.info)
  return _msg;
}

// .tendermint.abci.RequestSetOption set_option = 4;
inline bool Request::_internal_has_set_option() const {
  return value_case() == kSetOption;
}
inline bool Request::has_set_option() const {
  return _internal_has_set_option();
}
inline void Request::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Request::clear_set_option() {
  if (_internal_has_set_option()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.set_option_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestSetOption* Request::release_set_option() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.set_option)
  if (_internal_has_set_option()) {
    clear_has_value();
      ::tendermint::abci::RequestSetOption* temp = value_.set_option_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestSetOption& Request::_internal_set_option() const {
  return _internal_has_set_option()
      ? *value_.set_option_
      : reinterpret_cast< ::tendermint::abci::RequestSetOption&>(::tendermint::abci::_RequestSetOption_default_instance_);
}
inline const ::tendermint::abci::RequestSetOption& Request::set_option() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.set_option)
  return _internal_set_option();
}
inline ::tendermint::abci::RequestSetOption* Request::unsafe_arena_release_set_option() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.set_option)
  if (_internal_has_set_option()) {
    clear_has_value();
    ::tendermint::abci::RequestSetOption* temp = value_.set_option_;
    value_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_set_option(::tendermint::abci::RequestSetOption* set_option) {
  clear_value();
  if (set_option) {
    set_has_set_option();
    value_.set_option_ = set_option;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.set_option)
}
inline ::tendermint::abci::RequestSetOption* Request::_internal_mutable_set_option() {
  if (!_internal_has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = CreateMaybeMessage< ::tendermint::abci::RequestSetOption >(GetArenaForAllocation());
  }
  return value_.set_option_;
}
inline ::tendermint::abci::RequestSetOption* Request::mutable_set_option() {
  ::tendermint::abci::RequestSetOption* _msg = _internal_mutable_set_option();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.set_option)
  return _msg;
}

// .tendermint.abci.RequestInitChain init_chain = 5;
inline bool Request::_internal_has_init_chain() const {
  return value_case() == kInitChain;
}
inline bool Request::has_init_chain() const {
  return _internal_has_init_chain();
}
inline void Request::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Request::clear_init_chain() {
  if (_internal_has_init_chain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.init_chain_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestInitChain* Request::release_init_chain() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.init_chain)
  if (_internal_has_init_chain()) {
    clear_has_value();
      ::tendermint::abci::RequestInitChain* temp = value_.init_chain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestInitChain& Request::_internal_init_chain() const {
  return _internal_has_init_chain()
      ? *value_.init_chain_
      : reinterpret_cast< ::tendermint::abci::RequestInitChain&>(::tendermint::abci::_RequestInitChain_default_instance_);
}
inline const ::tendermint::abci::RequestInitChain& Request::init_chain() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.init_chain)
  return _internal_init_chain();
}
inline ::tendermint::abci::RequestInitChain* Request::unsafe_arena_release_init_chain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.init_chain)
  if (_internal_has_init_chain()) {
    clear_has_value();
    ::tendermint::abci::RequestInitChain* temp = value_.init_chain_;
    value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_init_chain(::tendermint::abci::RequestInitChain* init_chain) {
  clear_value();
  if (init_chain) {
    set_has_init_chain();
    value_.init_chain_ = init_chain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.init_chain)
}
inline ::tendermint::abci::RequestInitChain* Request::_internal_mutable_init_chain() {
  if (!_internal_has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = CreateMaybeMessage< ::tendermint::abci::RequestInitChain >(GetArenaForAllocation());
  }
  return value_.init_chain_;
}
inline ::tendermint::abci::RequestInitChain* Request::mutable_init_chain() {
  ::tendermint::abci::RequestInitChain* _msg = _internal_mutable_init_chain();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.init_chain)
  return _msg;
}

// .tendermint.abci.RequestQuery query = 6;
inline bool Request::_internal_has_query() const {
  return value_case() == kQuery;
}
inline bool Request::has_query() const {
  return _internal_has_query();
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Request::clear_query() {
  if (_internal_has_query()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.query_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.query)
  if (_internal_has_query()) {
    clear_has_value();
      ::tendermint::abci::RequestQuery* temp = value_.query_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestQuery& Request::_internal_query() const {
  return _internal_has_query()
      ? *value_.query_
      : reinterpret_cast< ::tendermint::abci::RequestQuery&>(::tendermint::abci::_RequestQuery_default_instance_);
}
inline const ::tendermint::abci::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.query)
  return _internal_query();
}
inline ::tendermint::abci::RequestQuery* Request::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.query)
  if (_internal_has_query()) {
    clear_has_value();
    ::tendermint::abci::RequestQuery* temp = value_.query_;
    value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_query(::tendermint::abci::RequestQuery* query) {
  clear_value();
  if (query) {
    set_has_query();
    value_.query_ = query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.query)
}
inline ::tendermint::abci::RequestQuery* Request::_internal_mutable_query() {
  if (!_internal_has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = CreateMaybeMessage< ::tendermint::abci::RequestQuery >(GetArenaForAllocation());
  }
  return value_.query_;
}
inline ::tendermint::abci::RequestQuery* Request::mutable_query() {
  ::tendermint::abci::RequestQuery* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.query)
  return _msg;
}

// .tendermint.abci.RequestBeginBlock begin_block = 7;
inline bool Request::_internal_has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline bool Request::has_begin_block() const {
  return _internal_has_begin_block();
}
inline void Request::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Request::clear_begin_block() {
  if (_internal_has_begin_block()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.begin_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestBeginBlock* Request::release_begin_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.begin_block)
  if (_internal_has_begin_block()) {
    clear_has_value();
      ::tendermint::abci::RequestBeginBlock* temp = value_.begin_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestBeginBlock& Request::_internal_begin_block() const {
  return _internal_has_begin_block()
      ? *value_.begin_block_
      : reinterpret_cast< ::tendermint::abci::RequestBeginBlock&>(::tendermint::abci::_RequestBeginBlock_default_instance_);
}
inline const ::tendermint::abci::RequestBeginBlock& Request::begin_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.begin_block)
  return _internal_begin_block();
}
inline ::tendermint::abci::RequestBeginBlock* Request::unsafe_arena_release_begin_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.begin_block)
  if (_internal_has_begin_block()) {
    clear_has_value();
    ::tendermint::abci::RequestBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_begin_block(::tendermint::abci::RequestBeginBlock* begin_block) {
  clear_value();
  if (begin_block) {
    set_has_begin_block();
    value_.begin_block_ = begin_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.begin_block)
}
inline ::tendermint::abci::RequestBeginBlock* Request::_internal_mutable_begin_block() {
  if (!_internal_has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = CreateMaybeMessage< ::tendermint::abci::RequestBeginBlock >(GetArenaForAllocation());
  }
  return value_.begin_block_;
}
inline ::tendermint::abci::RequestBeginBlock* Request::mutable_begin_block() {
  ::tendermint::abci::RequestBeginBlock* _msg = _internal_mutable_begin_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.begin_block)
  return _msg;
}

// .tendermint.abci.RequestCheckTx check_tx = 8;
inline bool Request::_internal_has_check_tx() const {
  return value_case() == kCheckTx;
}
inline bool Request::has_check_tx() const {
  return _internal_has_check_tx();
}
inline void Request::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Request::clear_check_tx() {
  if (_internal_has_check_tx()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.check_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestCheckTx* Request::release_check_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.check_tx)
  if (_internal_has_check_tx()) {
    clear_has_value();
      ::tendermint::abci::RequestCheckTx* temp = value_.check_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestCheckTx& Request::_internal_check_tx() const {
  return _internal_has_check_tx()
      ? *value_.check_tx_
      : reinterpret_cast< ::tendermint::abci::RequestCheckTx&>(::tendermint::abci::_RequestCheckTx_default_instance_);
}
inline const ::tendermint::abci::RequestCheckTx& Request::check_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.check_tx)
  return _internal_check_tx();
}
inline ::tendermint::abci::RequestCheckTx* Request::unsafe_arena_release_check_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.check_tx)
  if (_internal_has_check_tx()) {
    clear_has_value();
    ::tendermint::abci::RequestCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_check_tx(::tendermint::abci::RequestCheckTx* check_tx) {
  clear_value();
  if (check_tx) {
    set_has_check_tx();
    value_.check_tx_ = check_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.check_tx)
}
inline ::tendermint::abci::RequestCheckTx* Request::_internal_mutable_check_tx() {
  if (!_internal_has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = CreateMaybeMessage< ::tendermint::abci::RequestCheckTx >(GetArenaForAllocation());
  }
  return value_.check_tx_;
}
inline ::tendermint::abci::RequestCheckTx* Request::mutable_check_tx() {
  ::tendermint::abci::RequestCheckTx* _msg = _internal_mutable_check_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.check_tx)
  return _msg;
}

// .tendermint.abci.RequestDeliverTx deliver_tx = 9;
inline bool Request::_internal_has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline bool Request::has_deliver_tx() const {
  return _internal_has_deliver_tx();
}
inline void Request::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Request::clear_deliver_tx() {
  if (_internal_has_deliver_tx()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.deliver_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestDeliverTx* Request::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.deliver_tx)
  if (_internal_has_deliver_tx()) {
    clear_has_value();
      ::tendermint::abci::RequestDeliverTx* temp = value_.deliver_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestDeliverTx& Request::_internal_deliver_tx() const {
  return _internal_has_deliver_tx()
      ? *value_.deliver_tx_
      : reinterpret_cast< ::tendermint::abci::RequestDeliverTx&>(::tendermint::abci::_RequestDeliverTx_default_instance_);
}
inline const ::tendermint::abci::RequestDeliverTx& Request::deliver_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.deliver_tx)
  return _internal_deliver_tx();
}
inline ::tendermint::abci::RequestDeliverTx* Request::unsafe_arena_release_deliver_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.deliver_tx)
  if (_internal_has_deliver_tx()) {
    clear_has_value();
    ::tendermint::abci::RequestDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_deliver_tx(::tendermint::abci::RequestDeliverTx* deliver_tx) {
  clear_value();
  if (deliver_tx) {
    set_has_deliver_tx();
    value_.deliver_tx_ = deliver_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.deliver_tx)
}
inline ::tendermint::abci::RequestDeliverTx* Request::_internal_mutable_deliver_tx() {
  if (!_internal_has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = CreateMaybeMessage< ::tendermint::abci::RequestDeliverTx >(GetArenaForAllocation());
  }
  return value_.deliver_tx_;
}
inline ::tendermint::abci::RequestDeliverTx* Request::mutable_deliver_tx() {
  ::tendermint::abci::RequestDeliverTx* _msg = _internal_mutable_deliver_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.deliver_tx)
  return _msg;
}

// .tendermint.abci.RequestEndBlock end_block = 10;
inline bool Request::_internal_has_end_block() const {
  return value_case() == kEndBlock;
}
inline bool Request::has_end_block() const {
  return _internal_has_end_block();
}
inline void Request::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Request::clear_end_block() {
  if (_internal_has_end_block()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.end_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestEndBlock* Request::release_end_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.end_block)
  if (_internal_has_end_block()) {
    clear_has_value();
      ::tendermint::abci::RequestEndBlock* temp = value_.end_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestEndBlock& Request::_internal_end_block() const {
  return _internal_has_end_block()
      ? *value_.end_block_
      : reinterpret_cast< ::tendermint::abci::RequestEndBlock&>(::tendermint::abci::_RequestEndBlock_default_instance_);
}
inline const ::tendermint::abci::RequestEndBlock& Request::end_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.end_block)
  return _internal_end_block();
}
inline ::tendermint::abci::RequestEndBlock* Request::unsafe_arena_release_end_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.end_block)
  if (_internal_has_end_block()) {
    clear_has_value();
    ::tendermint::abci::RequestEndBlock* temp = value_.end_block_;
    value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_end_block(::tendermint::abci::RequestEndBlock* end_block) {
  clear_value();
  if (end_block) {
    set_has_end_block();
    value_.end_block_ = end_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.end_block)
}
inline ::tendermint::abci::RequestEndBlock* Request::_internal_mutable_end_block() {
  if (!_internal_has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = CreateMaybeMessage< ::tendermint::abci::RequestEndBlock >(GetArenaForAllocation());
  }
  return value_.end_block_;
}
inline ::tendermint::abci::RequestEndBlock* Request::mutable_end_block() {
  ::tendermint::abci::RequestEndBlock* _msg = _internal_mutable_end_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.end_block)
  return _msg;
}

// .tendermint.abci.RequestCommit commit = 11;
inline bool Request::_internal_has_commit() const {
  return value_case() == kCommit;
}
inline bool Request::has_commit() const {
  return _internal_has_commit();
}
inline void Request::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Request::clear_commit() {
  if (_internal_has_commit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.commit_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestCommit* Request::release_commit() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.commit)
  if (_internal_has_commit()) {
    clear_has_value();
      ::tendermint::abci::RequestCommit* temp = value_.commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestCommit& Request::_internal_commit() const {
  return _internal_has_commit()
      ? *value_.commit_
      : reinterpret_cast< ::tendermint::abci::RequestCommit&>(::tendermint::abci::_RequestCommit_default_instance_);
}
inline const ::tendermint::abci::RequestCommit& Request::commit() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.commit)
  return _internal_commit();
}
inline ::tendermint::abci::RequestCommit* Request::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.commit)
  if (_internal_has_commit()) {
    clear_has_value();
    ::tendermint::abci::RequestCommit* temp = value_.commit_;
    value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_commit(::tendermint::abci::RequestCommit* commit) {
  clear_value();
  if (commit) {
    set_has_commit();
    value_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.commit)
}
inline ::tendermint::abci::RequestCommit* Request::_internal_mutable_commit() {
  if (!_internal_has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = CreateMaybeMessage< ::tendermint::abci::RequestCommit >(GetArenaForAllocation());
  }
  return value_.commit_;
}
inline ::tendermint::abci::RequestCommit* Request::mutable_commit() {
  ::tendermint::abci::RequestCommit* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.commit)
  return _msg;
}

// .tendermint.abci.RequestListSnapshots list_snapshots = 12;
inline bool Request::_internal_has_list_snapshots() const {
  return value_case() == kListSnapshots;
}
inline bool Request::has_list_snapshots() const {
  return _internal_has_list_snapshots();
}
inline void Request::set_has_list_snapshots() {
  _oneof_case_[0] = kListSnapshots;
}
inline void Request::clear_list_snapshots() {
  if (_internal_has_list_snapshots()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.list_snapshots_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestListSnapshots* Request::release_list_snapshots() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.list_snapshots)
  if (_internal_has_list_snapshots()) {
    clear_has_value();
      ::tendermint::abci::RequestListSnapshots* temp = value_.list_snapshots_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestListSnapshots& Request::_internal_list_snapshots() const {
  return _internal_has_list_snapshots()
      ? *value_.list_snapshots_
      : reinterpret_cast< ::tendermint::abci::RequestListSnapshots&>(::tendermint::abci::_RequestListSnapshots_default_instance_);
}
inline const ::tendermint::abci::RequestListSnapshots& Request::list_snapshots() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.list_snapshots)
  return _internal_list_snapshots();
}
inline ::tendermint::abci::RequestListSnapshots* Request::unsafe_arena_release_list_snapshots() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.list_snapshots)
  if (_internal_has_list_snapshots()) {
    clear_has_value();
    ::tendermint::abci::RequestListSnapshots* temp = value_.list_snapshots_;
    value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_list_snapshots(::tendermint::abci::RequestListSnapshots* list_snapshots) {
  clear_value();
  if (list_snapshots) {
    set_has_list_snapshots();
    value_.list_snapshots_ = list_snapshots;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.list_snapshots)
}
inline ::tendermint::abci::RequestListSnapshots* Request::_internal_mutable_list_snapshots() {
  if (!_internal_has_list_snapshots()) {
    clear_value();
    set_has_list_snapshots();
    value_.list_snapshots_ = CreateMaybeMessage< ::tendermint::abci::RequestListSnapshots >(GetArenaForAllocation());
  }
  return value_.list_snapshots_;
}
inline ::tendermint::abci::RequestListSnapshots* Request::mutable_list_snapshots() {
  ::tendermint::abci::RequestListSnapshots* _msg = _internal_mutable_list_snapshots();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.list_snapshots)
  return _msg;
}

// .tendermint.abci.RequestOfferSnapshot offer_snapshot = 13;
inline bool Request::_internal_has_offer_snapshot() const {
  return value_case() == kOfferSnapshot;
}
inline bool Request::has_offer_snapshot() const {
  return _internal_has_offer_snapshot();
}
inline void Request::set_has_offer_snapshot() {
  _oneof_case_[0] = kOfferSnapshot;
}
inline void Request::clear_offer_snapshot() {
  if (_internal_has_offer_snapshot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.offer_snapshot_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::release_offer_snapshot() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.offer_snapshot)
  if (_internal_has_offer_snapshot()) {
    clear_has_value();
      ::tendermint::abci::RequestOfferSnapshot* temp = value_.offer_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestOfferSnapshot& Request::_internal_offer_snapshot() const {
  return _internal_has_offer_snapshot()
      ? *value_.offer_snapshot_
      : reinterpret_cast< ::tendermint::abci::RequestOfferSnapshot&>(::tendermint::abci::_RequestOfferSnapshot_default_instance_);
}
inline const ::tendermint::abci::RequestOfferSnapshot& Request::offer_snapshot() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.offer_snapshot)
  return _internal_offer_snapshot();
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::unsafe_arena_release_offer_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.offer_snapshot)
  if (_internal_has_offer_snapshot()) {
    clear_has_value();
    ::tendermint::abci::RequestOfferSnapshot* temp = value_.offer_snapshot_;
    value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_offer_snapshot(::tendermint::abci::RequestOfferSnapshot* offer_snapshot) {
  clear_value();
  if (offer_snapshot) {
    set_has_offer_snapshot();
    value_.offer_snapshot_ = offer_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.offer_snapshot)
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::_internal_mutable_offer_snapshot() {
  if (!_internal_has_offer_snapshot()) {
    clear_value();
    set_has_offer_snapshot();
    value_.offer_snapshot_ = CreateMaybeMessage< ::tendermint::abci::RequestOfferSnapshot >(GetArenaForAllocation());
  }
  return value_.offer_snapshot_;
}
inline ::tendermint::abci::RequestOfferSnapshot* Request::mutable_offer_snapshot() {
  ::tendermint::abci::RequestOfferSnapshot* _msg = _internal_mutable_offer_snapshot();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.offer_snapshot)
  return _msg;
}

// .tendermint.abci.RequestLoadSnapshotChunk load_snapshot_chunk = 14;
inline bool Request::_internal_has_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk;
}
inline bool Request::has_load_snapshot_chunk() const {
  return _internal_has_load_snapshot_chunk();
}
inline void Request::set_has_load_snapshot_chunk() {
  _oneof_case_[0] = kLoadSnapshotChunk;
}
inline void Request::clear_load_snapshot_chunk() {
  if (_internal_has_load_snapshot_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.load_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.load_snapshot_chunk)
  if (_internal_has_load_snapshot_chunk()) {
    clear_has_value();
      ::tendermint::abci::RequestLoadSnapshotChunk* temp = value_.load_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestLoadSnapshotChunk& Request::_internal_load_snapshot_chunk() const {
  return _internal_has_load_snapshot_chunk()
      ? *value_.load_snapshot_chunk_
      : reinterpret_cast< ::tendermint::abci::RequestLoadSnapshotChunk&>(::tendermint::abci::_RequestLoadSnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::RequestLoadSnapshotChunk& Request::load_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.load_snapshot_chunk)
  return _internal_load_snapshot_chunk();
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::unsafe_arena_release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.load_snapshot_chunk)
  if (_internal_has_load_snapshot_chunk()) {
    clear_has_value();
    ::tendermint::abci::RequestLoadSnapshotChunk* temp = value_.load_snapshot_chunk_;
    value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_load_snapshot_chunk(::tendermint::abci::RequestLoadSnapshotChunk* load_snapshot_chunk) {
  clear_value();
  if (load_snapshot_chunk) {
    set_has_load_snapshot_chunk();
    value_.load_snapshot_chunk_ = load_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.load_snapshot_chunk)
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::_internal_mutable_load_snapshot_chunk() {
  if (!_internal_has_load_snapshot_chunk()) {
    clear_value();
    set_has_load_snapshot_chunk();
    value_.load_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::RequestLoadSnapshotChunk >(GetArenaForAllocation());
  }
  return value_.load_snapshot_chunk_;
}
inline ::tendermint::abci::RequestLoadSnapshotChunk* Request::mutable_load_snapshot_chunk() {
  ::tendermint::abci::RequestLoadSnapshotChunk* _msg = _internal_mutable_load_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.load_snapshot_chunk)
  return _msg;
}

// .tendermint.abci.RequestApplySnapshotChunk apply_snapshot_chunk = 15;
inline bool Request::_internal_has_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk;
}
inline bool Request::has_apply_snapshot_chunk() const {
  return _internal_has_apply_snapshot_chunk();
}
inline void Request::set_has_apply_snapshot_chunk() {
  _oneof_case_[0] = kApplySnapshotChunk;
}
inline void Request::clear_apply_snapshot_chunk() {
  if (_internal_has_apply_snapshot_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.apply_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Request.apply_snapshot_chunk)
  if (_internal_has_apply_snapshot_chunk()) {
    clear_has_value();
      ::tendermint::abci::RequestApplySnapshotChunk* temp = value_.apply_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::RequestApplySnapshotChunk& Request::_internal_apply_snapshot_chunk() const {
  return _internal_has_apply_snapshot_chunk()
      ? *value_.apply_snapshot_chunk_
      : reinterpret_cast< ::tendermint::abci::RequestApplySnapshotChunk&>(::tendermint::abci::_RequestApplySnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::RequestApplySnapshotChunk& Request::apply_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Request.apply_snapshot_chunk)
  return _internal_apply_snapshot_chunk();
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::unsafe_arena_release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Request.apply_snapshot_chunk)
  if (_internal_has_apply_snapshot_chunk()) {
    clear_has_value();
    ::tendermint::abci::RequestApplySnapshotChunk* temp = value_.apply_snapshot_chunk_;
    value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_apply_snapshot_chunk(::tendermint::abci::RequestApplySnapshotChunk* apply_snapshot_chunk) {
  clear_value();
  if (apply_snapshot_chunk) {
    set_has_apply_snapshot_chunk();
    value_.apply_snapshot_chunk_ = apply_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Request.apply_snapshot_chunk)
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::_internal_mutable_apply_snapshot_chunk() {
  if (!_internal_has_apply_snapshot_chunk()) {
    clear_value();
    set_has_apply_snapshot_chunk();
    value_.apply_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::RequestApplySnapshotChunk >(GetArenaForAllocation());
  }
  return value_.apply_snapshot_chunk_;
}
inline ::tendermint::abci::RequestApplySnapshotChunk* Request::mutable_apply_snapshot_chunk() {
  ::tendermint::abci::RequestApplySnapshotChunk* _msg = _internal_mutable_apply_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Request.apply_snapshot_chunk)
  return _msg;
}

inline bool Request::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Request::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Request::ValueCase Request::value_case() const {
  return Request::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestEcho

// string message = 1;
inline void RequestEcho::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& RequestEcho::message() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestEcho.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestEcho::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestEcho.message)
}
inline std::string* RequestEcho::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestEcho.message)
  return _s;
}
inline const std::string& RequestEcho::_internal_message() const {
  return message_.Get();
}
inline void RequestEcho::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestEcho::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestEcho::release_message() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestEcho.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestEcho::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestEcho.message)
}

// -------------------------------------------------------------------

// RequestFlush

// -------------------------------------------------------------------

// RequestInfo

// string version = 1;
inline void RequestInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& RequestInfo::version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInfo.version)
}
inline std::string* RequestInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInfo.version)
  return _s;
}
inline const std::string& RequestInfo::_internal_version() const {
  return version_.Get();
}
inline void RequestInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestInfo::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestInfo::release_version() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInfo.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInfo.version)
}

// uint64 block_version = 2;
inline void RequestInfo::clear_block_version() {
  block_version_ = uint64_t{0u};
}
inline uint64_t RequestInfo::_internal_block_version() const {
  return block_version_;
}
inline uint64_t RequestInfo::block_version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInfo.block_version)
  return _internal_block_version();
}
inline void RequestInfo::_internal_set_block_version(uint64_t value) {
  
  block_version_ = value;
}
inline void RequestInfo::set_block_version(uint64_t value) {
  _internal_set_block_version(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInfo.block_version)
}

// uint64 p2p_version = 3;
inline void RequestInfo::clear_p2p_version() {
  p2p_version_ = uint64_t{0u};
}
inline uint64_t RequestInfo::_internal_p2p_version() const {
  return p2p_version_;
}
inline uint64_t RequestInfo::p2p_version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInfo.p2p_version)
  return _internal_p2p_version();
}
inline void RequestInfo::_internal_set_p2p_version(uint64_t value) {
  
  p2p_version_ = value;
}
inline void RequestInfo::set_p2p_version(uint64_t value) {
  _internal_set_p2p_version(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInfo.p2p_version)
}

// -------------------------------------------------------------------

// RequestSetOption

// string key = 1;
inline void RequestSetOption::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& RequestSetOption::key() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestSetOption.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestSetOption::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestSetOption.key)
}
inline std::string* RequestSetOption::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestSetOption.key)
  return _s;
}
inline const std::string& RequestSetOption::_internal_key() const {
  return key_.Get();
}
inline void RequestSetOption::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestSetOption::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestSetOption::release_key() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestSetOption.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestSetOption::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestSetOption.key)
}

// string value = 2;
inline void RequestSetOption::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& RequestSetOption::value() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestSetOption.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestSetOption::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestSetOption.value)
}
inline std::string* RequestSetOption::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestSetOption.value)
  return _s;
}
inline const std::string& RequestSetOption::_internal_value() const {
  return value_.Get();
}
inline void RequestSetOption::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestSetOption::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestSetOption::release_value() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestSetOption.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestSetOption::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestSetOption.value)
}

// -------------------------------------------------------------------

// RequestInitChain

// .google.protobuf.Timestamp time = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool RequestInitChain::_internal_has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline bool RequestInitChain::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestInitChain::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RequestInitChain::time() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.time)
  return _internal_time();
}
inline void RequestInitChain::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestInitChain.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::_internal_mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RequestInitChain::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.time)
  return _msg;
}
inline void RequestInitChain::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.time)
}

// string chain_id = 2;
inline void RequestInitChain::clear_chain_id() {
  chain_id_.ClearToEmpty();
}
inline const std::string& RequestInitChain::chain_id() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestInitChain::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInitChain.chain_id)
}
inline std::string* RequestInitChain::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.chain_id)
  return _s;
}
inline const std::string& RequestInitChain::_internal_chain_id() const {
  return chain_id_.Get();
}
inline void RequestInitChain::_internal_set_chain_id(const std::string& value) {
  
  chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestInitChain::_internal_mutable_chain_id() {
  
  return chain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestInitChain::release_chain_id() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.chain_id)
  return chain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestInitChain::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chain_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chain_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chain_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.chain_id)
}

// .tendermint.abci.ConsensusParams consensus_params = 3;
inline bool RequestInitChain::_internal_has_consensus_params() const {
  return this != internal_default_instance() && consensus_params_ != nullptr;
}
inline bool RequestInitChain::has_consensus_params() const {
  return _internal_has_consensus_params();
}
inline void RequestInitChain::clear_consensus_params() {
  if (GetArenaForAllocation() == nullptr && consensus_params_ != nullptr) {
    delete consensus_params_;
  }
  consensus_params_ = nullptr;
}
inline const ::tendermint::abci::ConsensusParams& RequestInitChain::_internal_consensus_params() const {
  const ::tendermint::abci::ConsensusParams* p = consensus_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::ConsensusParams&>(
      ::tendermint::abci::_ConsensusParams_default_instance_);
}
inline const ::tendermint::abci::ConsensusParams& RequestInitChain::consensus_params() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.consensus_params)
  return _internal_consensus_params();
}
inline void RequestInitChain::unsafe_arena_set_allocated_consensus_params(
    ::tendermint::abci::ConsensusParams* consensus_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_params_);
  }
  consensus_params_ = consensus_params;
  if (consensus_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestInitChain.consensus_params)
}
inline ::tendermint::abci::ConsensusParams* RequestInitChain::release_consensus_params() {
  
  ::tendermint::abci::ConsensusParams* temp = consensus_params_;
  consensus_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::ConsensusParams* RequestInitChain::unsafe_arena_release_consensus_params() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.consensus_params)
  
  ::tendermint::abci::ConsensusParams* temp = consensus_params_;
  consensus_params_ = nullptr;
  return temp;
}
inline ::tendermint::abci::ConsensusParams* RequestInitChain::_internal_mutable_consensus_params() {
  
  if (consensus_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::ConsensusParams>(GetArenaForAllocation());
    consensus_params_ = p;
  }
  return consensus_params_;
}
inline ::tendermint::abci::ConsensusParams* RequestInitChain::mutable_consensus_params() {
  ::tendermint::abci::ConsensusParams* _msg = _internal_mutable_consensus_params();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.consensus_params)
  return _msg;
}
inline void RequestInitChain::set_allocated_consensus_params(::tendermint::abci::ConsensusParams* consensus_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete consensus_params_;
  }
  if (consensus_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::ConsensusParams>::GetOwningArena(consensus_params);
    if (message_arena != submessage_arena) {
      consensus_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_params, submessage_arena);
    }
    
  } else {
    
  }
  consensus_params_ = consensus_params;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.consensus_params)
}

// repeated .tendermint.abci.ValidatorUpdate validators = 4 [(.gogoproto.nullable) = false];
inline int RequestInitChain::_internal_validators_size() const {
  return validators_.size();
}
inline int RequestInitChain::validators_size() const {
  return _internal_validators_size();
}
inline void RequestInitChain::clear_validators() {
  validators_.Clear();
}
inline ::tendermint::abci::ValidatorUpdate* RequestInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.validators)
  return validators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
RequestInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestInitChain.validators)
  return &validators_;
}
inline const ::tendermint::abci::ValidatorUpdate& RequestInitChain::_internal_validators(int index) const {
  return validators_.Get(index);
}
inline const ::tendermint::abci::ValidatorUpdate& RequestInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.validators)
  return _internal_validators(index);
}
inline ::tendermint::abci::ValidatorUpdate* RequestInitChain::_internal_add_validators() {
  return validators_.Add();
}
inline ::tendermint::abci::ValidatorUpdate* RequestInitChain::add_validators() {
  ::tendermint::abci::ValidatorUpdate* _add = _internal_add_validators();
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestInitChain.validators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
RequestInitChain::validators() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestInitChain.validators)
  return validators_;
}

// bytes app_state_bytes = 5;
inline void RequestInitChain::clear_app_state_bytes() {
  app_state_bytes_.ClearToEmpty();
}
inline const std::string& RequestInitChain::app_state_bytes() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.app_state_bytes)
  return _internal_app_state_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestInitChain::set_app_state_bytes(ArgT0&& arg0, ArgT... args) {
 
 app_state_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInitChain.app_state_bytes)
}
inline std::string* RequestInitChain::mutable_app_state_bytes() {
  std::string* _s = _internal_mutable_app_state_bytes();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestInitChain.app_state_bytes)
  return _s;
}
inline const std::string& RequestInitChain::_internal_app_state_bytes() const {
  return app_state_bytes_.Get();
}
inline void RequestInitChain::_internal_set_app_state_bytes(const std::string& value) {
  
  app_state_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestInitChain::_internal_mutable_app_state_bytes() {
  
  return app_state_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestInitChain::release_app_state_bytes() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestInitChain.app_state_bytes)
  return app_state_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestInitChain::set_allocated_app_state_bytes(std::string* app_state_bytes) {
  if (app_state_bytes != nullptr) {
    
  } else {
    
  }
  app_state_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_state_bytes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_state_bytes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_state_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestInitChain.app_state_bytes)
}

// int64 initial_height = 6;
inline void RequestInitChain::clear_initial_height() {
  initial_height_ = int64_t{0};
}
inline int64_t RequestInitChain::_internal_initial_height() const {
  return initial_height_;
}
inline int64_t RequestInitChain::initial_height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestInitChain.initial_height)
  return _internal_initial_height();
}
inline void RequestInitChain::_internal_set_initial_height(int64_t value) {
  
  initial_height_ = value;
}
inline void RequestInitChain::set_initial_height(int64_t value) {
  _internal_set_initial_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestInitChain.initial_height)
}

// -------------------------------------------------------------------

// RequestQuery

// bytes data = 1;
inline void RequestQuery::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& RequestQuery::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestQuery::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.data)
}
inline std::string* RequestQuery::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestQuery.data)
  return _s;
}
inline const std::string& RequestQuery::_internal_data() const {
  return data_.Get();
}
inline void RequestQuery::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestQuery::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestQuery::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestQuery.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestQuery::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestQuery.data)
}

// string path = 2;
inline void RequestQuery::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& RequestQuery::path() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestQuery::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.path)
}
inline std::string* RequestQuery::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestQuery.path)
  return _s;
}
inline const std::string& RequestQuery::_internal_path() const {
  return path_.Get();
}
inline void RequestQuery::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestQuery::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestQuery::release_path() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestQuery.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestQuery::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestQuery.path)
}

// int64 height = 3;
inline void RequestQuery::clear_height() {
  height_ = int64_t{0};
}
inline int64_t RequestQuery::_internal_height() const {
  return height_;
}
inline int64_t RequestQuery::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.height)
  return _internal_height();
}
inline void RequestQuery::_internal_set_height(int64_t value) {
  
  height_ = value;
}
inline void RequestQuery::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.height)
}

// bool prove = 4;
inline void RequestQuery::clear_prove() {
  prove_ = false;
}
inline bool RequestQuery::_internal_prove() const {
  return prove_;
}
inline bool RequestQuery::prove() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestQuery.prove)
  return _internal_prove();
}
inline void RequestQuery::_internal_set_prove(bool value) {
  
  prove_ = value;
}
inline void RequestQuery::set_prove(bool value) {
  _internal_set_prove(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestQuery.prove)
}

// -------------------------------------------------------------------

// RequestBeginBlock

// bytes hash = 1;
inline void RequestBeginBlock::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& RequestBeginBlock::hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestBeginBlock::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestBeginBlock.hash)
}
inline std::string* RequestBeginBlock::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.hash)
  return _s;
}
inline const std::string& RequestBeginBlock::_internal_hash() const {
  return hash_.Get();
}
inline void RequestBeginBlock::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestBeginBlock::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestBeginBlock::release_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestBeginBlock.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestBeginBlock::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestBeginBlock.hash)
}

// .tendermint.types.Header header = 2 [(.gogoproto.nullable) = false];
inline bool RequestBeginBlock::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool RequestBeginBlock::has_header() const {
  return _internal_has_header();
}
inline const ::tendermint::types::Header& RequestBeginBlock::_internal_header() const {
  const ::tendermint::types::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::Header&>(
      ::tendermint::types::_Header_default_instance_);
}
inline const ::tendermint::types::Header& RequestBeginBlock::header() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.header)
  return _internal_header();
}
inline void RequestBeginBlock::unsafe_arena_set_allocated_header(
    ::tendermint::types::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestBeginBlock.header)
}
inline ::tendermint::types::Header* RequestBeginBlock::release_header() {
  
  ::tendermint::types::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::Header* RequestBeginBlock::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestBeginBlock.header)
  
  ::tendermint::types::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::tendermint::types::Header* RequestBeginBlock::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::tendermint::types::Header* RequestBeginBlock::mutable_header() {
  ::tendermint::types::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.header)
  return _msg;
}
inline void RequestBeginBlock::set_allocated_header(::tendermint::types::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestBeginBlock.header)
}

// .tendermint.abci.LastCommitInfo last_commit_info = 3 [(.gogoproto.nullable) = false];
inline bool RequestBeginBlock::_internal_has_last_commit_info() const {
  return this != internal_default_instance() && last_commit_info_ != nullptr;
}
inline bool RequestBeginBlock::has_last_commit_info() const {
  return _internal_has_last_commit_info();
}
inline void RequestBeginBlock::clear_last_commit_info() {
  if (GetArenaForAllocation() == nullptr && last_commit_info_ != nullptr) {
    delete last_commit_info_;
  }
  last_commit_info_ = nullptr;
}
inline const ::tendermint::abci::LastCommitInfo& RequestBeginBlock::_internal_last_commit_info() const {
  const ::tendermint::abci::LastCommitInfo* p = last_commit_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::LastCommitInfo&>(
      ::tendermint::abci::_LastCommitInfo_default_instance_);
}
inline const ::tendermint::abci::LastCommitInfo& RequestBeginBlock::last_commit_info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.last_commit_info)
  return _internal_last_commit_info();
}
inline void RequestBeginBlock::unsafe_arena_set_allocated_last_commit_info(
    ::tendermint::abci::LastCommitInfo* last_commit_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_commit_info_);
  }
  last_commit_info_ = last_commit_info;
  if (last_commit_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestBeginBlock.last_commit_info)
}
inline ::tendermint::abci::LastCommitInfo* RequestBeginBlock::release_last_commit_info() {
  
  ::tendermint::abci::LastCommitInfo* temp = last_commit_info_;
  last_commit_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::LastCommitInfo* RequestBeginBlock::unsafe_arena_release_last_commit_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestBeginBlock.last_commit_info)
  
  ::tendermint::abci::LastCommitInfo* temp = last_commit_info_;
  last_commit_info_ = nullptr;
  return temp;
}
inline ::tendermint::abci::LastCommitInfo* RequestBeginBlock::_internal_mutable_last_commit_info() {
  
  if (last_commit_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::LastCommitInfo>(GetArenaForAllocation());
    last_commit_info_ = p;
  }
  return last_commit_info_;
}
inline ::tendermint::abci::LastCommitInfo* RequestBeginBlock::mutable_last_commit_info() {
  ::tendermint::abci::LastCommitInfo* _msg = _internal_mutable_last_commit_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.last_commit_info)
  return _msg;
}
inline void RequestBeginBlock::set_allocated_last_commit_info(::tendermint::abci::LastCommitInfo* last_commit_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete last_commit_info_;
  }
  if (last_commit_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::LastCommitInfo>::GetOwningArena(last_commit_info);
    if (message_arena != submessage_arena) {
      last_commit_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_commit_info, submessage_arena);
    }
    
  } else {
    
  }
  last_commit_info_ = last_commit_info;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestBeginBlock.last_commit_info)
}

// repeated .tendermint.abci.Evidence byzantine_validators = 4 [(.gogoproto.nullable) = false];
inline int RequestBeginBlock::_internal_byzantine_validators_size() const {
  return byzantine_validators_.size();
}
inline int RequestBeginBlock::byzantine_validators_size() const {
  return _internal_byzantine_validators_size();
}
inline void RequestBeginBlock::clear_byzantine_validators() {
  byzantine_validators_.Clear();
}
inline ::tendermint::abci::Evidence* RequestBeginBlock::mutable_byzantine_validators(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Evidence >*
RequestBeginBlock::mutable_byzantine_validators() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return &byzantine_validators_;
}
inline const ::tendermint::abci::Evidence& RequestBeginBlock::_internal_byzantine_validators(int index) const {
  return byzantine_validators_.Get(index);
}
inline const ::tendermint::abci::Evidence& RequestBeginBlock::byzantine_validators(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return _internal_byzantine_validators(index);
}
inline ::tendermint::abci::Evidence* RequestBeginBlock::_internal_add_byzantine_validators() {
  return byzantine_validators_.Add();
}
inline ::tendermint::abci::Evidence* RequestBeginBlock::add_byzantine_validators() {
  ::tendermint::abci::Evidence* _add = _internal_add_byzantine_validators();
  // @@protoc_insertion_point(field_add:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Evidence >&
RequestBeginBlock::byzantine_validators() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_;
}

// -------------------------------------------------------------------

// RequestCheckTx

// bytes tx = 1;
inline void RequestCheckTx::clear_tx() {
  tx_.ClearToEmpty();
}
inline const std::string& RequestCheckTx::tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestCheckTx.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestCheckTx::set_tx(ArgT0&& arg0, ArgT... args) {
 
 tx_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestCheckTx.tx)
}
inline std::string* RequestCheckTx::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestCheckTx.tx)
  return _s;
}
inline const std::string& RequestCheckTx::_internal_tx() const {
  return tx_.Get();
}
inline void RequestCheckTx::_internal_set_tx(const std::string& value) {
  
  tx_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestCheckTx::_internal_mutable_tx() {
  
  return tx_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestCheckTx::release_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestCheckTx.tx)
  return tx_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestCheckTx::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  tx_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tx_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tx_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestCheckTx.tx)
}

// .tendermint.abci.CheckTxType type = 2;
inline void RequestCheckTx::clear_type() {
  type_ = 0;
}
inline ::tendermint::abci::CheckTxType RequestCheckTx::_internal_type() const {
  return static_cast< ::tendermint::abci::CheckTxType >(type_);
}
inline ::tendermint::abci::CheckTxType RequestCheckTx::type() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestCheckTx.type)
  return _internal_type();
}
inline void RequestCheckTx::_internal_set_type(::tendermint::abci::CheckTxType value) {
  
  type_ = value;
}
inline void RequestCheckTx::set_type(::tendermint::abci::CheckTxType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestCheckTx.type)
}

// -------------------------------------------------------------------

// RequestDeliverTx

// bytes tx = 1;
inline void RequestDeliverTx::clear_tx() {
  tx_.ClearToEmpty();
}
inline const std::string& RequestDeliverTx::tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestDeliverTx.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestDeliverTx::set_tx(ArgT0&& arg0, ArgT... args) {
 
 tx_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestDeliverTx.tx)
}
inline std::string* RequestDeliverTx::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestDeliverTx.tx)
  return _s;
}
inline const std::string& RequestDeliverTx::_internal_tx() const {
  return tx_.Get();
}
inline void RequestDeliverTx::_internal_set_tx(const std::string& value) {
  
  tx_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestDeliverTx::_internal_mutable_tx() {
  
  return tx_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestDeliverTx::release_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestDeliverTx.tx)
  return tx_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestDeliverTx::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  tx_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tx_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tx_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestDeliverTx.tx)
}

// -------------------------------------------------------------------

// RequestEndBlock

// int64 height = 1;
inline void RequestEndBlock::clear_height() {
  height_ = int64_t{0};
}
inline int64_t RequestEndBlock::_internal_height() const {
  return height_;
}
inline int64_t RequestEndBlock::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestEndBlock.height)
  return _internal_height();
}
inline void RequestEndBlock::_internal_set_height(int64_t value) {
  
  height_ = value;
}
inline void RequestEndBlock::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestEndBlock.height)
}

// -------------------------------------------------------------------

// RequestCommit

// -------------------------------------------------------------------

// RequestListSnapshots

// -------------------------------------------------------------------

// RequestOfferSnapshot

// .tendermint.abci.Snapshot snapshot = 1;
inline bool RequestOfferSnapshot::_internal_has_snapshot() const {
  return this != internal_default_instance() && snapshot_ != nullptr;
}
inline bool RequestOfferSnapshot::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void RequestOfferSnapshot::clear_snapshot() {
  if (GetArenaForAllocation() == nullptr && snapshot_ != nullptr) {
    delete snapshot_;
  }
  snapshot_ = nullptr;
}
inline const ::tendermint::abci::Snapshot& RequestOfferSnapshot::_internal_snapshot() const {
  const ::tendermint::abci::Snapshot* p = snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::Snapshot&>(
      ::tendermint::abci::_Snapshot_default_instance_);
}
inline const ::tendermint::abci::Snapshot& RequestOfferSnapshot::snapshot() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestOfferSnapshot.snapshot)
  return _internal_snapshot();
}
inline void RequestOfferSnapshot::unsafe_arena_set_allocated_snapshot(
    ::tendermint::abci::Snapshot* snapshot) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(snapshot_);
  }
  snapshot_ = snapshot;
  if (snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.RequestOfferSnapshot.snapshot)
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::release_snapshot() {
  
  ::tendermint::abci::Snapshot* temp = snapshot_;
  snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestOfferSnapshot.snapshot)
  
  ::tendermint::abci::Snapshot* temp = snapshot_;
  snapshot_ = nullptr;
  return temp;
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::_internal_mutable_snapshot() {
  
  if (snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::Snapshot>(GetArenaForAllocation());
    snapshot_ = p;
  }
  return snapshot_;
}
inline ::tendermint::abci::Snapshot* RequestOfferSnapshot::mutable_snapshot() {
  ::tendermint::abci::Snapshot* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestOfferSnapshot.snapshot)
  return _msg;
}
inline void RequestOfferSnapshot::set_allocated_snapshot(::tendermint::abci::Snapshot* snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete snapshot_;
  }
  if (snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::Snapshot>::GetOwningArena(snapshot);
    if (message_arena != submessage_arena) {
      snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot, submessage_arena);
    }
    
  } else {
    
  }
  snapshot_ = snapshot;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestOfferSnapshot.snapshot)
}

// bytes app_hash = 2;
inline void RequestOfferSnapshot::clear_app_hash() {
  app_hash_.ClearToEmpty();
}
inline const std::string& RequestOfferSnapshot::app_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestOfferSnapshot.app_hash)
  return _internal_app_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestOfferSnapshot::set_app_hash(ArgT0&& arg0, ArgT... args) {
 
 app_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestOfferSnapshot.app_hash)
}
inline std::string* RequestOfferSnapshot::mutable_app_hash() {
  std::string* _s = _internal_mutable_app_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestOfferSnapshot.app_hash)
  return _s;
}
inline const std::string& RequestOfferSnapshot::_internal_app_hash() const {
  return app_hash_.Get();
}
inline void RequestOfferSnapshot::_internal_set_app_hash(const std::string& value) {
  
  app_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestOfferSnapshot::_internal_mutable_app_hash() {
  
  return app_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestOfferSnapshot::release_app_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestOfferSnapshot.app_hash)
  return app_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestOfferSnapshot::set_allocated_app_hash(std::string* app_hash) {
  if (app_hash != nullptr) {
    
  } else {
    
  }
  app_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestOfferSnapshot.app_hash)
}

// -------------------------------------------------------------------

// RequestLoadSnapshotChunk

// uint64 height = 1;
inline void RequestLoadSnapshotChunk::clear_height() {
  height_ = uint64_t{0u};
}
inline uint64_t RequestLoadSnapshotChunk::_internal_height() const {
  return height_;
}
inline uint64_t RequestLoadSnapshotChunk::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestLoadSnapshotChunk.height)
  return _internal_height();
}
inline void RequestLoadSnapshotChunk::_internal_set_height(uint64_t value) {
  
  height_ = value;
}
inline void RequestLoadSnapshotChunk::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestLoadSnapshotChunk.height)
}

// uint32 format = 2;
inline void RequestLoadSnapshotChunk::clear_format() {
  format_ = 0u;
}
inline uint32_t RequestLoadSnapshotChunk::_internal_format() const {
  return format_;
}
inline uint32_t RequestLoadSnapshotChunk::format() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestLoadSnapshotChunk.format)
  return _internal_format();
}
inline void RequestLoadSnapshotChunk::_internal_set_format(uint32_t value) {
  
  format_ = value;
}
inline void RequestLoadSnapshotChunk::set_format(uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestLoadSnapshotChunk.format)
}

// uint32 chunk = 3;
inline void RequestLoadSnapshotChunk::clear_chunk() {
  chunk_ = 0u;
}
inline uint32_t RequestLoadSnapshotChunk::_internal_chunk() const {
  return chunk_;
}
inline uint32_t RequestLoadSnapshotChunk::chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestLoadSnapshotChunk.chunk)
  return _internal_chunk();
}
inline void RequestLoadSnapshotChunk::_internal_set_chunk(uint32_t value) {
  
  chunk_ = value;
}
inline void RequestLoadSnapshotChunk::set_chunk(uint32_t value) {
  _internal_set_chunk(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestLoadSnapshotChunk.chunk)
}

// -------------------------------------------------------------------

// RequestApplySnapshotChunk

// uint32 index = 1;
inline void RequestApplySnapshotChunk::clear_index() {
  index_ = 0u;
}
inline uint32_t RequestApplySnapshotChunk::_internal_index() const {
  return index_;
}
inline uint32_t RequestApplySnapshotChunk::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestApplySnapshotChunk.index)
  return _internal_index();
}
inline void RequestApplySnapshotChunk::_internal_set_index(uint32_t value) {
  
  index_ = value;
}
inline void RequestApplySnapshotChunk::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestApplySnapshotChunk.index)
}

// bytes chunk = 2;
inline void RequestApplySnapshotChunk::clear_chunk() {
  chunk_.ClearToEmpty();
}
inline const std::string& RequestApplySnapshotChunk::chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestApplySnapshotChunk.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestApplySnapshotChunk::set_chunk(ArgT0&& arg0, ArgT... args) {
 
 chunk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestApplySnapshotChunk.chunk)
}
inline std::string* RequestApplySnapshotChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestApplySnapshotChunk.chunk)
  return _s;
}
inline const std::string& RequestApplySnapshotChunk::_internal_chunk() const {
  return chunk_.Get();
}
inline void RequestApplySnapshotChunk::_internal_set_chunk(const std::string& value) {
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::_internal_mutable_chunk() {
  
  return chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestApplySnapshotChunk.chunk)
  return chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestApplySnapshotChunk::set_allocated_chunk(std::string* chunk) {
  if (chunk != nullptr) {
    
  } else {
    
  }
  chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chunk_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chunk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestApplySnapshotChunk.chunk)
}

// string sender = 3;
inline void RequestApplySnapshotChunk::clear_sender() {
  sender_.ClearToEmpty();
}
inline const std::string& RequestApplySnapshotChunk::sender() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.RequestApplySnapshotChunk.sender)
  return _internal_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestApplySnapshotChunk::set_sender(ArgT0&& arg0, ArgT... args) {
 
 sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.RequestApplySnapshotChunk.sender)
}
inline std::string* RequestApplySnapshotChunk::mutable_sender() {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.RequestApplySnapshotChunk.sender)
  return _s;
}
inline const std::string& RequestApplySnapshotChunk::_internal_sender() const {
  return sender_.Get();
}
inline void RequestApplySnapshotChunk::_internal_set_sender(const std::string& value) {
  
  sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::_internal_mutable_sender() {
  
  return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RequestApplySnapshotChunk::release_sender() {
  // @@protoc_insertion_point(field_release:tendermint.abci.RequestApplySnapshotChunk.sender)
  return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RequestApplySnapshotChunk::set_allocated_sender(std::string* sender) {
  if (sender != nullptr) {
    
  } else {
    
  }
  sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.RequestApplySnapshotChunk.sender)
}

// -------------------------------------------------------------------

// Response

// .tendermint.abci.ResponseException exception = 1;
inline bool Response::_internal_has_exception() const {
  return value_case() == kException;
}
inline bool Response::has_exception() const {
  return _internal_has_exception();
}
inline void Response::set_has_exception() {
  _oneof_case_[0] = kException;
}
inline void Response::clear_exception() {
  if (_internal_has_exception()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.exception_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseException* Response::release_exception() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.exception)
  if (_internal_has_exception()) {
    clear_has_value();
      ::tendermint::abci::ResponseException* temp = value_.exception_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.exception_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseException& Response::_internal_exception() const {
  return _internal_has_exception()
      ? *value_.exception_
      : reinterpret_cast< ::tendermint::abci::ResponseException&>(::tendermint::abci::_ResponseException_default_instance_);
}
inline const ::tendermint::abci::ResponseException& Response::exception() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.exception)
  return _internal_exception();
}
inline ::tendermint::abci::ResponseException* Response::unsafe_arena_release_exception() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.exception)
  if (_internal_has_exception()) {
    clear_has_value();
    ::tendermint::abci::ResponseException* temp = value_.exception_;
    value_.exception_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_exception(::tendermint::abci::ResponseException* exception) {
  clear_value();
  if (exception) {
    set_has_exception();
    value_.exception_ = exception;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.exception)
}
inline ::tendermint::abci::ResponseException* Response::_internal_mutable_exception() {
  if (!_internal_has_exception()) {
    clear_value();
    set_has_exception();
    value_.exception_ = CreateMaybeMessage< ::tendermint::abci::ResponseException >(GetArenaForAllocation());
  }
  return value_.exception_;
}
inline ::tendermint::abci::ResponseException* Response::mutable_exception() {
  ::tendermint::abci::ResponseException* _msg = _internal_mutable_exception();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.exception)
  return _msg;
}

// .tendermint.abci.ResponseEcho echo = 2;
inline bool Response::_internal_has_echo() const {
  return value_case() == kEcho;
}
inline bool Response::has_echo() const {
  return _internal_has_echo();
}
inline void Response::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Response::clear_echo() {
  if (_internal_has_echo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.echo_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseEcho* Response::release_echo() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.echo)
  if (_internal_has_echo()) {
    clear_has_value();
      ::tendermint::abci::ResponseEcho* temp = value_.echo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseEcho& Response::_internal_echo() const {
  return _internal_has_echo()
      ? *value_.echo_
      : reinterpret_cast< ::tendermint::abci::ResponseEcho&>(::tendermint::abci::_ResponseEcho_default_instance_);
}
inline const ::tendermint::abci::ResponseEcho& Response::echo() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.echo)
  return _internal_echo();
}
inline ::tendermint::abci::ResponseEcho* Response::unsafe_arena_release_echo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.echo)
  if (_internal_has_echo()) {
    clear_has_value();
    ::tendermint::abci::ResponseEcho* temp = value_.echo_;
    value_.echo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_echo(::tendermint::abci::ResponseEcho* echo) {
  clear_value();
  if (echo) {
    set_has_echo();
    value_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.echo)
}
inline ::tendermint::abci::ResponseEcho* Response::_internal_mutable_echo() {
  if (!_internal_has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = CreateMaybeMessage< ::tendermint::abci::ResponseEcho >(GetArenaForAllocation());
  }
  return value_.echo_;
}
inline ::tendermint::abci::ResponseEcho* Response::mutable_echo() {
  ::tendermint::abci::ResponseEcho* _msg = _internal_mutable_echo();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.echo)
  return _msg;
}

// .tendermint.abci.ResponseFlush flush = 3;
inline bool Response::_internal_has_flush() const {
  return value_case() == kFlush;
}
inline bool Response::has_flush() const {
  return _internal_has_flush();
}
inline void Response::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Response::clear_flush() {
  if (_internal_has_flush()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.flush_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseFlush* Response::release_flush() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.flush)
  if (_internal_has_flush()) {
    clear_has_value();
      ::tendermint::abci::ResponseFlush* temp = value_.flush_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseFlush& Response::_internal_flush() const {
  return _internal_has_flush()
      ? *value_.flush_
      : reinterpret_cast< ::tendermint::abci::ResponseFlush&>(::tendermint::abci::_ResponseFlush_default_instance_);
}
inline const ::tendermint::abci::ResponseFlush& Response::flush() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.flush)
  return _internal_flush();
}
inline ::tendermint::abci::ResponseFlush* Response::unsafe_arena_release_flush() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.flush)
  if (_internal_has_flush()) {
    clear_has_value();
    ::tendermint::abci::ResponseFlush* temp = value_.flush_;
    value_.flush_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_flush(::tendermint::abci::ResponseFlush* flush) {
  clear_value();
  if (flush) {
    set_has_flush();
    value_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.flush)
}
inline ::tendermint::abci::ResponseFlush* Response::_internal_mutable_flush() {
  if (!_internal_has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = CreateMaybeMessage< ::tendermint::abci::ResponseFlush >(GetArenaForAllocation());
  }
  return value_.flush_;
}
inline ::tendermint::abci::ResponseFlush* Response::mutable_flush() {
  ::tendermint::abci::ResponseFlush* _msg = _internal_mutable_flush();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.flush)
  return _msg;
}

// .tendermint.abci.ResponseInfo info = 4;
inline bool Response::_internal_has_info() const {
  return value_case() == kInfo;
}
inline bool Response::has_info() const {
  return _internal_has_info();
}
inline void Response::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Response::clear_info() {
  if (_internal_has_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.info_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseInfo* Response::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.info)
  if (_internal_has_info()) {
    clear_has_value();
      ::tendermint::abci::ResponseInfo* temp = value_.info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseInfo& Response::_internal_info() const {
  return _internal_has_info()
      ? *value_.info_
      : reinterpret_cast< ::tendermint::abci::ResponseInfo&>(::tendermint::abci::_ResponseInfo_default_instance_);
}
inline const ::tendermint::abci::ResponseInfo& Response::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.info)
  return _internal_info();
}
inline ::tendermint::abci::ResponseInfo* Response::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.info)
  if (_internal_has_info()) {
    clear_has_value();
    ::tendermint::abci::ResponseInfo* temp = value_.info_;
    value_.info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_info(::tendermint::abci::ResponseInfo* info) {
  clear_value();
  if (info) {
    set_has_info();
    value_.info_ = info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.info)
}
inline ::tendermint::abci::ResponseInfo* Response::_internal_mutable_info() {
  if (!_internal_has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = CreateMaybeMessage< ::tendermint::abci::ResponseInfo >(GetArenaForAllocation());
  }
  return value_.info_;
}
inline ::tendermint::abci::ResponseInfo* Response::mutable_info() {
  ::tendermint::abci::ResponseInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.info)
  return _msg;
}

// .tendermint.abci.ResponseSetOption set_option = 5;
inline bool Response::_internal_has_set_option() const {
  return value_case() == kSetOption;
}
inline bool Response::has_set_option() const {
  return _internal_has_set_option();
}
inline void Response::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Response::clear_set_option() {
  if (_internal_has_set_option()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.set_option_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseSetOption* Response::release_set_option() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.set_option)
  if (_internal_has_set_option()) {
    clear_has_value();
      ::tendermint::abci::ResponseSetOption* temp = value_.set_option_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseSetOption& Response::_internal_set_option() const {
  return _internal_has_set_option()
      ? *value_.set_option_
      : reinterpret_cast< ::tendermint::abci::ResponseSetOption&>(::tendermint::abci::_ResponseSetOption_default_instance_);
}
inline const ::tendermint::abci::ResponseSetOption& Response::set_option() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.set_option)
  return _internal_set_option();
}
inline ::tendermint::abci::ResponseSetOption* Response::unsafe_arena_release_set_option() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.set_option)
  if (_internal_has_set_option()) {
    clear_has_value();
    ::tendermint::abci::ResponseSetOption* temp = value_.set_option_;
    value_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_set_option(::tendermint::abci::ResponseSetOption* set_option) {
  clear_value();
  if (set_option) {
    set_has_set_option();
    value_.set_option_ = set_option;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.set_option)
}
inline ::tendermint::abci::ResponseSetOption* Response::_internal_mutable_set_option() {
  if (!_internal_has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = CreateMaybeMessage< ::tendermint::abci::ResponseSetOption >(GetArenaForAllocation());
  }
  return value_.set_option_;
}
inline ::tendermint::abci::ResponseSetOption* Response::mutable_set_option() {
  ::tendermint::abci::ResponseSetOption* _msg = _internal_mutable_set_option();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.set_option)
  return _msg;
}

// .tendermint.abci.ResponseInitChain init_chain = 6;
inline bool Response::_internal_has_init_chain() const {
  return value_case() == kInitChain;
}
inline bool Response::has_init_chain() const {
  return _internal_has_init_chain();
}
inline void Response::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Response::clear_init_chain() {
  if (_internal_has_init_chain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.init_chain_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseInitChain* Response::release_init_chain() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.init_chain)
  if (_internal_has_init_chain()) {
    clear_has_value();
      ::tendermint::abci::ResponseInitChain* temp = value_.init_chain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseInitChain& Response::_internal_init_chain() const {
  return _internal_has_init_chain()
      ? *value_.init_chain_
      : reinterpret_cast< ::tendermint::abci::ResponseInitChain&>(::tendermint::abci::_ResponseInitChain_default_instance_);
}
inline const ::tendermint::abci::ResponseInitChain& Response::init_chain() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.init_chain)
  return _internal_init_chain();
}
inline ::tendermint::abci::ResponseInitChain* Response::unsafe_arena_release_init_chain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.init_chain)
  if (_internal_has_init_chain()) {
    clear_has_value();
    ::tendermint::abci::ResponseInitChain* temp = value_.init_chain_;
    value_.init_chain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_init_chain(::tendermint::abci::ResponseInitChain* init_chain) {
  clear_value();
  if (init_chain) {
    set_has_init_chain();
    value_.init_chain_ = init_chain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.init_chain)
}
inline ::tendermint::abci::ResponseInitChain* Response::_internal_mutable_init_chain() {
  if (!_internal_has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = CreateMaybeMessage< ::tendermint::abci::ResponseInitChain >(GetArenaForAllocation());
  }
  return value_.init_chain_;
}
inline ::tendermint::abci::ResponseInitChain* Response::mutable_init_chain() {
  ::tendermint::abci::ResponseInitChain* _msg = _internal_mutable_init_chain();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.init_chain)
  return _msg;
}

// .tendermint.abci.ResponseQuery query = 7;
inline bool Response::_internal_has_query() const {
  return value_case() == kQuery;
}
inline bool Response::has_query() const {
  return _internal_has_query();
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Response::clear_query() {
  if (_internal_has_query()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.query_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.query)
  if (_internal_has_query()) {
    clear_has_value();
      ::tendermint::abci::ResponseQuery* temp = value_.query_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseQuery& Response::_internal_query() const {
  return _internal_has_query()
      ? *value_.query_
      : reinterpret_cast< ::tendermint::abci::ResponseQuery&>(::tendermint::abci::_ResponseQuery_default_instance_);
}
inline const ::tendermint::abci::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.query)
  return _internal_query();
}
inline ::tendermint::abci::ResponseQuery* Response::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.query)
  if (_internal_has_query()) {
    clear_has_value();
    ::tendermint::abci::ResponseQuery* temp = value_.query_;
    value_.query_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_query(::tendermint::abci::ResponseQuery* query) {
  clear_value();
  if (query) {
    set_has_query();
    value_.query_ = query;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.query)
}
inline ::tendermint::abci::ResponseQuery* Response::_internal_mutable_query() {
  if (!_internal_has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = CreateMaybeMessage< ::tendermint::abci::ResponseQuery >(GetArenaForAllocation());
  }
  return value_.query_;
}
inline ::tendermint::abci::ResponseQuery* Response::mutable_query() {
  ::tendermint::abci::ResponseQuery* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.query)
  return _msg;
}

// .tendermint.abci.ResponseBeginBlock begin_block = 8;
inline bool Response::_internal_has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline bool Response::has_begin_block() const {
  return _internal_has_begin_block();
}
inline void Response::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Response::clear_begin_block() {
  if (_internal_has_begin_block()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.begin_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseBeginBlock* Response::release_begin_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.begin_block)
  if (_internal_has_begin_block()) {
    clear_has_value();
      ::tendermint::abci::ResponseBeginBlock* temp = value_.begin_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseBeginBlock& Response::_internal_begin_block() const {
  return _internal_has_begin_block()
      ? *value_.begin_block_
      : reinterpret_cast< ::tendermint::abci::ResponseBeginBlock&>(::tendermint::abci::_ResponseBeginBlock_default_instance_);
}
inline const ::tendermint::abci::ResponseBeginBlock& Response::begin_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.begin_block)
  return _internal_begin_block();
}
inline ::tendermint::abci::ResponseBeginBlock* Response::unsafe_arena_release_begin_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.begin_block)
  if (_internal_has_begin_block()) {
    clear_has_value();
    ::tendermint::abci::ResponseBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_begin_block(::tendermint::abci::ResponseBeginBlock* begin_block) {
  clear_value();
  if (begin_block) {
    set_has_begin_block();
    value_.begin_block_ = begin_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.begin_block)
}
inline ::tendermint::abci::ResponseBeginBlock* Response::_internal_mutable_begin_block() {
  if (!_internal_has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = CreateMaybeMessage< ::tendermint::abci::ResponseBeginBlock >(GetArenaForAllocation());
  }
  return value_.begin_block_;
}
inline ::tendermint::abci::ResponseBeginBlock* Response::mutable_begin_block() {
  ::tendermint::abci::ResponseBeginBlock* _msg = _internal_mutable_begin_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.begin_block)
  return _msg;
}

// .tendermint.abci.ResponseCheckTx check_tx = 9;
inline bool Response::_internal_has_check_tx() const {
  return value_case() == kCheckTx;
}
inline bool Response::has_check_tx() const {
  return _internal_has_check_tx();
}
inline void Response::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Response::clear_check_tx() {
  if (_internal_has_check_tx()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.check_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseCheckTx* Response::release_check_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.check_tx)
  if (_internal_has_check_tx()) {
    clear_has_value();
      ::tendermint::abci::ResponseCheckTx* temp = value_.check_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseCheckTx& Response::_internal_check_tx() const {
  return _internal_has_check_tx()
      ? *value_.check_tx_
      : reinterpret_cast< ::tendermint::abci::ResponseCheckTx&>(::tendermint::abci::_ResponseCheckTx_default_instance_);
}
inline const ::tendermint::abci::ResponseCheckTx& Response::check_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.check_tx)
  return _internal_check_tx();
}
inline ::tendermint::abci::ResponseCheckTx* Response::unsafe_arena_release_check_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.check_tx)
  if (_internal_has_check_tx()) {
    clear_has_value();
    ::tendermint::abci::ResponseCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_check_tx(::tendermint::abci::ResponseCheckTx* check_tx) {
  clear_value();
  if (check_tx) {
    set_has_check_tx();
    value_.check_tx_ = check_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.check_tx)
}
inline ::tendermint::abci::ResponseCheckTx* Response::_internal_mutable_check_tx() {
  if (!_internal_has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = CreateMaybeMessage< ::tendermint::abci::ResponseCheckTx >(GetArenaForAllocation());
  }
  return value_.check_tx_;
}
inline ::tendermint::abci::ResponseCheckTx* Response::mutable_check_tx() {
  ::tendermint::abci::ResponseCheckTx* _msg = _internal_mutable_check_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.check_tx)
  return _msg;
}

// .tendermint.abci.ResponseDeliverTx deliver_tx = 10;
inline bool Response::_internal_has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline bool Response::has_deliver_tx() const {
  return _internal_has_deliver_tx();
}
inline void Response::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Response::clear_deliver_tx() {
  if (_internal_has_deliver_tx()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.deliver_tx_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseDeliverTx* Response::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.deliver_tx)
  if (_internal_has_deliver_tx()) {
    clear_has_value();
      ::tendermint::abci::ResponseDeliverTx* temp = value_.deliver_tx_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseDeliverTx& Response::_internal_deliver_tx() const {
  return _internal_has_deliver_tx()
      ? *value_.deliver_tx_
      : reinterpret_cast< ::tendermint::abci::ResponseDeliverTx&>(::tendermint::abci::_ResponseDeliverTx_default_instance_);
}
inline const ::tendermint::abci::ResponseDeliverTx& Response::deliver_tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.deliver_tx)
  return _internal_deliver_tx();
}
inline ::tendermint::abci::ResponseDeliverTx* Response::unsafe_arena_release_deliver_tx() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.deliver_tx)
  if (_internal_has_deliver_tx()) {
    clear_has_value();
    ::tendermint::abci::ResponseDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_deliver_tx(::tendermint::abci::ResponseDeliverTx* deliver_tx) {
  clear_value();
  if (deliver_tx) {
    set_has_deliver_tx();
    value_.deliver_tx_ = deliver_tx;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.deliver_tx)
}
inline ::tendermint::abci::ResponseDeliverTx* Response::_internal_mutable_deliver_tx() {
  if (!_internal_has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = CreateMaybeMessage< ::tendermint::abci::ResponseDeliverTx >(GetArenaForAllocation());
  }
  return value_.deliver_tx_;
}
inline ::tendermint::abci::ResponseDeliverTx* Response::mutable_deliver_tx() {
  ::tendermint::abci::ResponseDeliverTx* _msg = _internal_mutable_deliver_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.deliver_tx)
  return _msg;
}

// .tendermint.abci.ResponseEndBlock end_block = 11;
inline bool Response::_internal_has_end_block() const {
  return value_case() == kEndBlock;
}
inline bool Response::has_end_block() const {
  return _internal_has_end_block();
}
inline void Response::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Response::clear_end_block() {
  if (_internal_has_end_block()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.end_block_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseEndBlock* Response::release_end_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.end_block)
  if (_internal_has_end_block()) {
    clear_has_value();
      ::tendermint::abci::ResponseEndBlock* temp = value_.end_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseEndBlock& Response::_internal_end_block() const {
  return _internal_has_end_block()
      ? *value_.end_block_
      : reinterpret_cast< ::tendermint::abci::ResponseEndBlock&>(::tendermint::abci::_ResponseEndBlock_default_instance_);
}
inline const ::tendermint::abci::ResponseEndBlock& Response::end_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.end_block)
  return _internal_end_block();
}
inline ::tendermint::abci::ResponseEndBlock* Response::unsafe_arena_release_end_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.end_block)
  if (_internal_has_end_block()) {
    clear_has_value();
    ::tendermint::abci::ResponseEndBlock* temp = value_.end_block_;
    value_.end_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_end_block(::tendermint::abci::ResponseEndBlock* end_block) {
  clear_value();
  if (end_block) {
    set_has_end_block();
    value_.end_block_ = end_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.end_block)
}
inline ::tendermint::abci::ResponseEndBlock* Response::_internal_mutable_end_block() {
  if (!_internal_has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = CreateMaybeMessage< ::tendermint::abci::ResponseEndBlock >(GetArenaForAllocation());
  }
  return value_.end_block_;
}
inline ::tendermint::abci::ResponseEndBlock* Response::mutable_end_block() {
  ::tendermint::abci::ResponseEndBlock* _msg = _internal_mutable_end_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.end_block)
  return _msg;
}

// .tendermint.abci.ResponseCommit commit = 12;
inline bool Response::_internal_has_commit() const {
  return value_case() == kCommit;
}
inline bool Response::has_commit() const {
  return _internal_has_commit();
}
inline void Response::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Response::clear_commit() {
  if (_internal_has_commit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.commit_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseCommit* Response::release_commit() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.commit)
  if (_internal_has_commit()) {
    clear_has_value();
      ::tendermint::abci::ResponseCommit* temp = value_.commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseCommit& Response::_internal_commit() const {
  return _internal_has_commit()
      ? *value_.commit_
      : reinterpret_cast< ::tendermint::abci::ResponseCommit&>(::tendermint::abci::_ResponseCommit_default_instance_);
}
inline const ::tendermint::abci::ResponseCommit& Response::commit() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.commit)
  return _internal_commit();
}
inline ::tendermint::abci::ResponseCommit* Response::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.commit)
  if (_internal_has_commit()) {
    clear_has_value();
    ::tendermint::abci::ResponseCommit* temp = value_.commit_;
    value_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_commit(::tendermint::abci::ResponseCommit* commit) {
  clear_value();
  if (commit) {
    set_has_commit();
    value_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.commit)
}
inline ::tendermint::abci::ResponseCommit* Response::_internal_mutable_commit() {
  if (!_internal_has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = CreateMaybeMessage< ::tendermint::abci::ResponseCommit >(GetArenaForAllocation());
  }
  return value_.commit_;
}
inline ::tendermint::abci::ResponseCommit* Response::mutable_commit() {
  ::tendermint::abci::ResponseCommit* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.commit)
  return _msg;
}

// .tendermint.abci.ResponseListSnapshots list_snapshots = 13;
inline bool Response::_internal_has_list_snapshots() const {
  return value_case() == kListSnapshots;
}
inline bool Response::has_list_snapshots() const {
  return _internal_has_list_snapshots();
}
inline void Response::set_has_list_snapshots() {
  _oneof_case_[0] = kListSnapshots;
}
inline void Response::clear_list_snapshots() {
  if (_internal_has_list_snapshots()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.list_snapshots_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseListSnapshots* Response::release_list_snapshots() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.list_snapshots)
  if (_internal_has_list_snapshots()) {
    clear_has_value();
      ::tendermint::abci::ResponseListSnapshots* temp = value_.list_snapshots_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseListSnapshots& Response::_internal_list_snapshots() const {
  return _internal_has_list_snapshots()
      ? *value_.list_snapshots_
      : reinterpret_cast< ::tendermint::abci::ResponseListSnapshots&>(::tendermint::abci::_ResponseListSnapshots_default_instance_);
}
inline const ::tendermint::abci::ResponseListSnapshots& Response::list_snapshots() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.list_snapshots)
  return _internal_list_snapshots();
}
inline ::tendermint::abci::ResponseListSnapshots* Response::unsafe_arena_release_list_snapshots() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.list_snapshots)
  if (_internal_has_list_snapshots()) {
    clear_has_value();
    ::tendermint::abci::ResponseListSnapshots* temp = value_.list_snapshots_;
    value_.list_snapshots_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_list_snapshots(::tendermint::abci::ResponseListSnapshots* list_snapshots) {
  clear_value();
  if (list_snapshots) {
    set_has_list_snapshots();
    value_.list_snapshots_ = list_snapshots;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.list_snapshots)
}
inline ::tendermint::abci::ResponseListSnapshots* Response::_internal_mutable_list_snapshots() {
  if (!_internal_has_list_snapshots()) {
    clear_value();
    set_has_list_snapshots();
    value_.list_snapshots_ = CreateMaybeMessage< ::tendermint::abci::ResponseListSnapshots >(GetArenaForAllocation());
  }
  return value_.list_snapshots_;
}
inline ::tendermint::abci::ResponseListSnapshots* Response::mutable_list_snapshots() {
  ::tendermint::abci::ResponseListSnapshots* _msg = _internal_mutable_list_snapshots();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.list_snapshots)
  return _msg;
}

// .tendermint.abci.ResponseOfferSnapshot offer_snapshot = 14;
inline bool Response::_internal_has_offer_snapshot() const {
  return value_case() == kOfferSnapshot;
}
inline bool Response::has_offer_snapshot() const {
  return _internal_has_offer_snapshot();
}
inline void Response::set_has_offer_snapshot() {
  _oneof_case_[0] = kOfferSnapshot;
}
inline void Response::clear_offer_snapshot() {
  if (_internal_has_offer_snapshot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.offer_snapshot_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::release_offer_snapshot() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.offer_snapshot)
  if (_internal_has_offer_snapshot()) {
    clear_has_value();
      ::tendermint::abci::ResponseOfferSnapshot* temp = value_.offer_snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseOfferSnapshot& Response::_internal_offer_snapshot() const {
  return _internal_has_offer_snapshot()
      ? *value_.offer_snapshot_
      : reinterpret_cast< ::tendermint::abci::ResponseOfferSnapshot&>(::tendermint::abci::_ResponseOfferSnapshot_default_instance_);
}
inline const ::tendermint::abci::ResponseOfferSnapshot& Response::offer_snapshot() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.offer_snapshot)
  return _internal_offer_snapshot();
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::unsafe_arena_release_offer_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.offer_snapshot)
  if (_internal_has_offer_snapshot()) {
    clear_has_value();
    ::tendermint::abci::ResponseOfferSnapshot* temp = value_.offer_snapshot_;
    value_.offer_snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_offer_snapshot(::tendermint::abci::ResponseOfferSnapshot* offer_snapshot) {
  clear_value();
  if (offer_snapshot) {
    set_has_offer_snapshot();
    value_.offer_snapshot_ = offer_snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.offer_snapshot)
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::_internal_mutable_offer_snapshot() {
  if (!_internal_has_offer_snapshot()) {
    clear_value();
    set_has_offer_snapshot();
    value_.offer_snapshot_ = CreateMaybeMessage< ::tendermint::abci::ResponseOfferSnapshot >(GetArenaForAllocation());
  }
  return value_.offer_snapshot_;
}
inline ::tendermint::abci::ResponseOfferSnapshot* Response::mutable_offer_snapshot() {
  ::tendermint::abci::ResponseOfferSnapshot* _msg = _internal_mutable_offer_snapshot();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.offer_snapshot)
  return _msg;
}

// .tendermint.abci.ResponseLoadSnapshotChunk load_snapshot_chunk = 15;
inline bool Response::_internal_has_load_snapshot_chunk() const {
  return value_case() == kLoadSnapshotChunk;
}
inline bool Response::has_load_snapshot_chunk() const {
  return _internal_has_load_snapshot_chunk();
}
inline void Response::set_has_load_snapshot_chunk() {
  _oneof_case_[0] = kLoadSnapshotChunk;
}
inline void Response::clear_load_snapshot_chunk() {
  if (_internal_has_load_snapshot_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.load_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.load_snapshot_chunk)
  if (_internal_has_load_snapshot_chunk()) {
    clear_has_value();
      ::tendermint::abci::ResponseLoadSnapshotChunk* temp = value_.load_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseLoadSnapshotChunk& Response::_internal_load_snapshot_chunk() const {
  return _internal_has_load_snapshot_chunk()
      ? *value_.load_snapshot_chunk_
      : reinterpret_cast< ::tendermint::abci::ResponseLoadSnapshotChunk&>(::tendermint::abci::_ResponseLoadSnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::ResponseLoadSnapshotChunk& Response::load_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.load_snapshot_chunk)
  return _internal_load_snapshot_chunk();
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::unsafe_arena_release_load_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.load_snapshot_chunk)
  if (_internal_has_load_snapshot_chunk()) {
    clear_has_value();
    ::tendermint::abci::ResponseLoadSnapshotChunk* temp = value_.load_snapshot_chunk_;
    value_.load_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_load_snapshot_chunk(::tendermint::abci::ResponseLoadSnapshotChunk* load_snapshot_chunk) {
  clear_value();
  if (load_snapshot_chunk) {
    set_has_load_snapshot_chunk();
    value_.load_snapshot_chunk_ = load_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.load_snapshot_chunk)
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::_internal_mutable_load_snapshot_chunk() {
  if (!_internal_has_load_snapshot_chunk()) {
    clear_value();
    set_has_load_snapshot_chunk();
    value_.load_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::ResponseLoadSnapshotChunk >(GetArenaForAllocation());
  }
  return value_.load_snapshot_chunk_;
}
inline ::tendermint::abci::ResponseLoadSnapshotChunk* Response::mutable_load_snapshot_chunk() {
  ::tendermint::abci::ResponseLoadSnapshotChunk* _msg = _internal_mutable_load_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.load_snapshot_chunk)
  return _msg;
}

// .tendermint.abci.ResponseApplySnapshotChunk apply_snapshot_chunk = 16;
inline bool Response::_internal_has_apply_snapshot_chunk() const {
  return value_case() == kApplySnapshotChunk;
}
inline bool Response::has_apply_snapshot_chunk() const {
  return _internal_has_apply_snapshot_chunk();
}
inline void Response::set_has_apply_snapshot_chunk() {
  _oneof_case_[0] = kApplySnapshotChunk;
}
inline void Response::clear_apply_snapshot_chunk() {
  if (_internal_has_apply_snapshot_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete value_.apply_snapshot_chunk_;
    }
    clear_has_value();
  }
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Response.apply_snapshot_chunk)
  if (_internal_has_apply_snapshot_chunk()) {
    clear_has_value();
      ::tendermint::abci::ResponseApplySnapshotChunk* temp = value_.apply_snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tendermint::abci::ResponseApplySnapshotChunk& Response::_internal_apply_snapshot_chunk() const {
  return _internal_has_apply_snapshot_chunk()
      ? *value_.apply_snapshot_chunk_
      : reinterpret_cast< ::tendermint::abci::ResponseApplySnapshotChunk&>(::tendermint::abci::_ResponseApplySnapshotChunk_default_instance_);
}
inline const ::tendermint::abci::ResponseApplySnapshotChunk& Response::apply_snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Response.apply_snapshot_chunk)
  return _internal_apply_snapshot_chunk();
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::unsafe_arena_release_apply_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tendermint.abci.Response.apply_snapshot_chunk)
  if (_internal_has_apply_snapshot_chunk()) {
    clear_has_value();
    ::tendermint::abci::ResponseApplySnapshotChunk* temp = value_.apply_snapshot_chunk_;
    value_.apply_snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_apply_snapshot_chunk(::tendermint::abci::ResponseApplySnapshotChunk* apply_snapshot_chunk) {
  clear_value();
  if (apply_snapshot_chunk) {
    set_has_apply_snapshot_chunk();
    value_.apply_snapshot_chunk_ = apply_snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Response.apply_snapshot_chunk)
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::_internal_mutable_apply_snapshot_chunk() {
  if (!_internal_has_apply_snapshot_chunk()) {
    clear_value();
    set_has_apply_snapshot_chunk();
    value_.apply_snapshot_chunk_ = CreateMaybeMessage< ::tendermint::abci::ResponseApplySnapshotChunk >(GetArenaForAllocation());
  }
  return value_.apply_snapshot_chunk_;
}
inline ::tendermint::abci::ResponseApplySnapshotChunk* Response::mutable_apply_snapshot_chunk() {
  ::tendermint::abci::ResponseApplySnapshotChunk* _msg = _internal_mutable_apply_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Response.apply_snapshot_chunk)
  return _msg;
}

inline bool Response::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Response::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Response::ValueCase Response::value_case() const {
  return Response::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseException

// string error = 1;
inline void ResponseException::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& ResponseException::error() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseException.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseException::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseException.error)
}
inline std::string* ResponseException::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseException.error)
  return _s;
}
inline const std::string& ResponseException::_internal_error() const {
  return error_.Get();
}
inline void ResponseException::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseException::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseException::release_error() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseException.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseException::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseException.error)
}

// -------------------------------------------------------------------

// ResponseEcho

// string message = 1;
inline void ResponseEcho::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& ResponseEcho::message() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEcho.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseEcho::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseEcho.message)
}
inline std::string* ResponseEcho::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEcho.message)
  return _s;
}
inline const std::string& ResponseEcho::_internal_message() const {
  return message_.Get();
}
inline void ResponseEcho::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseEcho::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseEcho::release_message() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseEcho.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseEcho::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseEcho.message)
}

// -------------------------------------------------------------------

// ResponseFlush

// -------------------------------------------------------------------

// ResponseInfo

// string data = 1;
inline void ResponseInfo::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ResponseInfo::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseInfo::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.data)
}
inline std::string* ResponseInfo::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInfo.data)
  return _s;
}
inline const std::string& ResponseInfo::_internal_data() const {
  return data_.Get();
}
inline void ResponseInfo::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInfo.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseInfo::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInfo.data)
}

// string version = 2;
inline void ResponseInfo::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& ResponseInfo::version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseInfo::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.version)
}
inline std::string* ResponseInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInfo.version)
  return _s;
}
inline const std::string& ResponseInfo::_internal_version() const {
  return version_.Get();
}
inline void ResponseInfo::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_version() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInfo.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInfo.version)
}

// uint64 app_version = 3;
inline void ResponseInfo::clear_app_version() {
  app_version_ = uint64_t{0u};
}
inline uint64_t ResponseInfo::_internal_app_version() const {
  return app_version_;
}
inline uint64_t ResponseInfo::app_version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.app_version)
  return _internal_app_version();
}
inline void ResponseInfo::_internal_set_app_version(uint64_t value) {
  
  app_version_ = value;
}
inline void ResponseInfo::set_app_version(uint64_t value) {
  _internal_set_app_version(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.app_version)
}

// int64 last_block_height = 4;
inline void ResponseInfo::clear_last_block_height() {
  last_block_height_ = int64_t{0};
}
inline int64_t ResponseInfo::_internal_last_block_height() const {
  return last_block_height_;
}
inline int64_t ResponseInfo::last_block_height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.last_block_height)
  return _internal_last_block_height();
}
inline void ResponseInfo::_internal_set_last_block_height(int64_t value) {
  
  last_block_height_ = value;
}
inline void ResponseInfo::set_last_block_height(int64_t value) {
  _internal_set_last_block_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.last_block_height)
}

// bytes last_block_app_hash = 5;
inline void ResponseInfo::clear_last_block_app_hash() {
  last_block_app_hash_.ClearToEmpty();
}
inline const std::string& ResponseInfo::last_block_app_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInfo.last_block_app_hash)
  return _internal_last_block_app_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseInfo::set_last_block_app_hash(ArgT0&& arg0, ArgT... args) {
 
 last_block_app_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInfo.last_block_app_hash)
}
inline std::string* ResponseInfo::mutable_last_block_app_hash() {
  std::string* _s = _internal_mutable_last_block_app_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInfo.last_block_app_hash)
  return _s;
}
inline const std::string& ResponseInfo::_internal_last_block_app_hash() const {
  return last_block_app_hash_.Get();
}
inline void ResponseInfo::_internal_set_last_block_app_hash(const std::string& value) {
  
  last_block_app_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseInfo::_internal_mutable_last_block_app_hash() {
  
  return last_block_app_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseInfo::release_last_block_app_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInfo.last_block_app_hash)
  return last_block_app_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseInfo::set_allocated_last_block_app_hash(std::string* last_block_app_hash) {
  if (last_block_app_hash != nullptr) {
    
  } else {
    
  }
  last_block_app_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_block_app_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_block_app_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_block_app_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInfo.last_block_app_hash)
}

// -------------------------------------------------------------------

// ResponseSetOption

// uint32 code = 1;
inline void ResponseSetOption::clear_code() {
  code_ = 0u;
}
inline uint32_t ResponseSetOption::_internal_code() const {
  return code_;
}
inline uint32_t ResponseSetOption::code() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseSetOption.code)
  return _internal_code();
}
inline void ResponseSetOption::_internal_set_code(uint32_t value) {
  
  code_ = value;
}
inline void ResponseSetOption::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseSetOption.code)
}

// string log = 3;
inline void ResponseSetOption::clear_log() {
  log_.ClearToEmpty();
}
inline const std::string& ResponseSetOption::log() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseSetOption.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseSetOption::set_log(ArgT0&& arg0, ArgT... args) {
 
 log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseSetOption.log)
}
inline std::string* ResponseSetOption::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseSetOption.log)
  return _s;
}
inline const std::string& ResponseSetOption::_internal_log() const {
  return log_.Get();
}
inline void ResponseSetOption::_internal_set_log(const std::string& value) {
  
  log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseSetOption::_internal_mutable_log() {
  
  return log_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseSetOption::release_log() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseSetOption.log)
  return log_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseSetOption::set_allocated_log(std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseSetOption.log)
}

// string info = 4;
inline void ResponseSetOption::clear_info() {
  info_.ClearToEmpty();
}
inline const std::string& ResponseSetOption::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseSetOption.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseSetOption::set_info(ArgT0&& arg0, ArgT... args) {
 
 info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseSetOption.info)
}
inline std::string* ResponseSetOption::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseSetOption.info)
  return _s;
}
inline const std::string& ResponseSetOption::_internal_info() const {
  return info_.Get();
}
inline void ResponseSetOption::_internal_set_info(const std::string& value) {
  
  info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseSetOption::_internal_mutable_info() {
  
  return info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseSetOption::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseSetOption.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseSetOption::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseSetOption.info)
}

// -------------------------------------------------------------------

// ResponseInitChain

// .tendermint.abci.ConsensusParams consensus_params = 1;
inline bool ResponseInitChain::_internal_has_consensus_params() const {
  return this != internal_default_instance() && consensus_params_ != nullptr;
}
inline bool ResponseInitChain::has_consensus_params() const {
  return _internal_has_consensus_params();
}
inline void ResponseInitChain::clear_consensus_params() {
  if (GetArenaForAllocation() == nullptr && consensus_params_ != nullptr) {
    delete consensus_params_;
  }
  consensus_params_ = nullptr;
}
inline const ::tendermint::abci::ConsensusParams& ResponseInitChain::_internal_consensus_params() const {
  const ::tendermint::abci::ConsensusParams* p = consensus_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::ConsensusParams&>(
      ::tendermint::abci::_ConsensusParams_default_instance_);
}
inline const ::tendermint::abci::ConsensusParams& ResponseInitChain::consensus_params() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInitChain.consensus_params)
  return _internal_consensus_params();
}
inline void ResponseInitChain::unsafe_arena_set_allocated_consensus_params(
    ::tendermint::abci::ConsensusParams* consensus_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_params_);
  }
  consensus_params_ = consensus_params;
  if (consensus_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ResponseInitChain.consensus_params)
}
inline ::tendermint::abci::ConsensusParams* ResponseInitChain::release_consensus_params() {
  
  ::tendermint::abci::ConsensusParams* temp = consensus_params_;
  consensus_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::ConsensusParams* ResponseInitChain::unsafe_arena_release_consensus_params() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInitChain.consensus_params)
  
  ::tendermint::abci::ConsensusParams* temp = consensus_params_;
  consensus_params_ = nullptr;
  return temp;
}
inline ::tendermint::abci::ConsensusParams* ResponseInitChain::_internal_mutable_consensus_params() {
  
  if (consensus_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::ConsensusParams>(GetArenaForAllocation());
    consensus_params_ = p;
  }
  return consensus_params_;
}
inline ::tendermint::abci::ConsensusParams* ResponseInitChain::mutable_consensus_params() {
  ::tendermint::abci::ConsensusParams* _msg = _internal_mutable_consensus_params();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInitChain.consensus_params)
  return _msg;
}
inline void ResponseInitChain::set_allocated_consensus_params(::tendermint::abci::ConsensusParams* consensus_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete consensus_params_;
  }
  if (consensus_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::ConsensusParams>::GetOwningArena(consensus_params);
    if (message_arena != submessage_arena) {
      consensus_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_params, submessage_arena);
    }
    
  } else {
    
  }
  consensus_params_ = consensus_params;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInitChain.consensus_params)
}

// repeated .tendermint.abci.ValidatorUpdate validators = 2 [(.gogoproto.nullable) = false];
inline int ResponseInitChain::_internal_validators_size() const {
  return validators_.size();
}
inline int ResponseInitChain::validators_size() const {
  return _internal_validators_size();
}
inline void ResponseInitChain::clear_validators() {
  validators_.Clear();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInitChain.validators)
  return validators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
ResponseInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseInitChain.validators)
  return &validators_;
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseInitChain::_internal_validators(int index) const {
  return validators_.Get(index);
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInitChain.validators)
  return _internal_validators(index);
}
inline ::tendermint::abci::ValidatorUpdate* ResponseInitChain::_internal_add_validators() {
  return validators_.Add();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseInitChain::add_validators() {
  ::tendermint::abci::ValidatorUpdate* _add = _internal_add_validators();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseInitChain.validators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
ResponseInitChain::validators() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseInitChain.validators)
  return validators_;
}

// bytes app_hash = 3;
inline void ResponseInitChain::clear_app_hash() {
  app_hash_.ClearToEmpty();
}
inline const std::string& ResponseInitChain::app_hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseInitChain.app_hash)
  return _internal_app_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseInitChain::set_app_hash(ArgT0&& arg0, ArgT... args) {
 
 app_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseInitChain.app_hash)
}
inline std::string* ResponseInitChain::mutable_app_hash() {
  std::string* _s = _internal_mutable_app_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseInitChain.app_hash)
  return _s;
}
inline const std::string& ResponseInitChain::_internal_app_hash() const {
  return app_hash_.Get();
}
inline void ResponseInitChain::_internal_set_app_hash(const std::string& value) {
  
  app_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseInitChain::_internal_mutable_app_hash() {
  
  return app_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseInitChain::release_app_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseInitChain.app_hash)
  return app_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseInitChain::set_allocated_app_hash(std::string* app_hash) {
  if (app_hash != nullptr) {
    
  } else {
    
  }
  app_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseInitChain.app_hash)
}

// -------------------------------------------------------------------

// ResponseQuery

// uint32 code = 1;
inline void ResponseQuery::clear_code() {
  code_ = 0u;
}
inline uint32_t ResponseQuery::_internal_code() const {
  return code_;
}
inline uint32_t ResponseQuery::code() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.code)
  return _internal_code();
}
inline void ResponseQuery::_internal_set_code(uint32_t value) {
  
  code_ = value;
}
inline void ResponseQuery::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.code)
}

// string log = 3;
inline void ResponseQuery::clear_log() {
  log_.ClearToEmpty();
}
inline const std::string& ResponseQuery::log() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseQuery::set_log(ArgT0&& arg0, ArgT... args) {
 
 log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.log)
}
inline std::string* ResponseQuery::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.log)
  return _s;
}
inline const std::string& ResponseQuery::_internal_log() const {
  return log_.Get();
}
inline void ResponseQuery::_internal_set_log(const std::string& value) {
  
  log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_log() {
  
  return log_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_log() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.log)
  return log_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseQuery::set_allocated_log(std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.log)
}

// string info = 4;
inline void ResponseQuery::clear_info() {
  info_.ClearToEmpty();
}
inline const std::string& ResponseQuery::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseQuery::set_info(ArgT0&& arg0, ArgT... args) {
 
 info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.info)
}
inline std::string* ResponseQuery::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.info)
  return _s;
}
inline const std::string& ResponseQuery::_internal_info() const {
  return info_.Get();
}
inline void ResponseQuery::_internal_set_info(const std::string& value) {
  
  info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_info() {
  
  return info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseQuery::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.info)
}

// int64 index = 5;
inline void ResponseQuery::clear_index() {
  index_ = int64_t{0};
}
inline int64_t ResponseQuery::_internal_index() const {
  return index_;
}
inline int64_t ResponseQuery::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.index)
  return _internal_index();
}
inline void ResponseQuery::_internal_set_index(int64_t value) {
  
  index_ = value;
}
inline void ResponseQuery::set_index(int64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.index)
}

// bytes key = 6;
inline void ResponseQuery::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& ResponseQuery::key() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseQuery::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.key)
}
inline std::string* ResponseQuery::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.key)
  return _s;
}
inline const std::string& ResponseQuery::_internal_key() const {
  return key_.Get();
}
inline void ResponseQuery::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_key() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseQuery::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.key)
}

// bytes value = 7;
inline void ResponseQuery::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& ResponseQuery::value() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseQuery::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.value)
}
inline std::string* ResponseQuery::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.value)
  return _s;
}
inline const std::string& ResponseQuery::_internal_value() const {
  return value_.Get();
}
inline void ResponseQuery::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_value() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseQuery::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.value)
}

// .tendermint.crypto.ProofOps proof_ops = 8;
inline bool ResponseQuery::_internal_has_proof_ops() const {
  return this != internal_default_instance() && proof_ops_ != nullptr;
}
inline bool ResponseQuery::has_proof_ops() const {
  return _internal_has_proof_ops();
}
inline const ::tendermint::crypto::ProofOps& ResponseQuery::_internal_proof_ops() const {
  const ::tendermint::crypto::ProofOps* p = proof_ops_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::crypto::ProofOps&>(
      ::tendermint::crypto::_ProofOps_default_instance_);
}
inline const ::tendermint::crypto::ProofOps& ResponseQuery::proof_ops() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.proof_ops)
  return _internal_proof_ops();
}
inline void ResponseQuery::unsafe_arena_set_allocated_proof_ops(
    ::tendermint::crypto::ProofOps* proof_ops) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_ops_);
  }
  proof_ops_ = proof_ops;
  if (proof_ops) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ResponseQuery.proof_ops)
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::release_proof_ops() {
  
  ::tendermint::crypto::ProofOps* temp = proof_ops_;
  proof_ops_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::unsafe_arena_release_proof_ops() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.proof_ops)
  
  ::tendermint::crypto::ProofOps* temp = proof_ops_;
  proof_ops_ = nullptr;
  return temp;
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::_internal_mutable_proof_ops() {
  
  if (proof_ops_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::crypto::ProofOps>(GetArenaForAllocation());
    proof_ops_ = p;
  }
  return proof_ops_;
}
inline ::tendermint::crypto::ProofOps* ResponseQuery::mutable_proof_ops() {
  ::tendermint::crypto::ProofOps* _msg = _internal_mutable_proof_ops();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.proof_ops)
  return _msg;
}
inline void ResponseQuery::set_allocated_proof_ops(::tendermint::crypto::ProofOps* proof_ops) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_ops_);
  }
  if (proof_ops) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_ops));
    if (message_arena != submessage_arena) {
      proof_ops = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof_ops, submessage_arena);
    }
    
  } else {
    
  }
  proof_ops_ = proof_ops;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.proof_ops)
}

// int64 height = 9;
inline void ResponseQuery::clear_height() {
  height_ = int64_t{0};
}
inline int64_t ResponseQuery::_internal_height() const {
  return height_;
}
inline int64_t ResponseQuery::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.height)
  return _internal_height();
}
inline void ResponseQuery::_internal_set_height(int64_t value) {
  
  height_ = value;
}
inline void ResponseQuery::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.height)
}

// string codespace = 10;
inline void ResponseQuery::clear_codespace() {
  codespace_.ClearToEmpty();
}
inline const std::string& ResponseQuery::codespace() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseQuery.codespace)
  return _internal_codespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseQuery::set_codespace(ArgT0&& arg0, ArgT... args) {
 
 codespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseQuery.codespace)
}
inline std::string* ResponseQuery::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseQuery.codespace)
  return _s;
}
inline const std::string& ResponseQuery::_internal_codespace() const {
  return codespace_.Get();
}
inline void ResponseQuery::_internal_set_codespace(const std::string& value) {
  
  codespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseQuery::_internal_mutable_codespace() {
  
  return codespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseQuery::release_codespace() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseQuery.codespace)
  return codespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseQuery::set_allocated_codespace(std::string* codespace) {
  if (codespace != nullptr) {
    
  } else {
    
  }
  codespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), codespace,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codespace_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codespace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseQuery.codespace)
}

// -------------------------------------------------------------------

// ResponseBeginBlock

// repeated .tendermint.abci.Event events = 1 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseBeginBlock::_internal_events_size() const {
  return events_.size();
}
inline int ResponseBeginBlock::events_size() const {
  return _internal_events_size();
}
inline void ResponseBeginBlock::clear_events() {
  events_.Clear();
}
inline ::tendermint::abci::Event* ResponseBeginBlock::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseBeginBlock.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseBeginBlock::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseBeginBlock.events)
  return &events_;
}
inline const ::tendermint::abci::Event& ResponseBeginBlock::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::tendermint::abci::Event& ResponseBeginBlock::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseBeginBlock.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseBeginBlock::_internal_add_events() {
  return events_.Add();
}
inline ::tendermint::abci::Event* ResponseBeginBlock::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseBeginBlock.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseBeginBlock::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseBeginBlock.events)
  return events_;
}

// -------------------------------------------------------------------

// ResponseCheckTx

// uint32 code = 1;
inline void ResponseCheckTx::clear_code() {
  code_ = 0u;
}
inline uint32_t ResponseCheckTx::_internal_code() const {
  return code_;
}
inline uint32_t ResponseCheckTx::code() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.code)
  return _internal_code();
}
inline void ResponseCheckTx::_internal_set_code(uint32_t value) {
  
  code_ = value;
}
inline void ResponseCheckTx::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.code)
}

// bytes data = 2;
inline void ResponseCheckTx::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseCheckTx::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.data)
}
inline std::string* ResponseCheckTx::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.data)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_data() const {
  return data_.Get();
}
inline void ResponseCheckTx::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseCheckTx::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.data)
}

// string log = 3;
inline void ResponseCheckTx::clear_log() {
  log_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::log() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseCheckTx::set_log(ArgT0&& arg0, ArgT... args) {
 
 log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.log)
}
inline std::string* ResponseCheckTx::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.log)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_log() const {
  return log_.Get();
}
inline void ResponseCheckTx::_internal_set_log(const std::string& value) {
  
  log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_log() {
  
  return log_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_log() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.log)
  return log_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseCheckTx::set_allocated_log(std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.log)
}

// string info = 4;
inline void ResponseCheckTx::clear_info() {
  info_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseCheckTx::set_info(ArgT0&& arg0, ArgT... args) {
 
 info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.info)
}
inline std::string* ResponseCheckTx::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.info)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_info() const {
  return info_.Get();
}
inline void ResponseCheckTx::_internal_set_info(const std::string& value) {
  
  info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_info() {
  
  return info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseCheckTx::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.info)
}

// int64 gas_wanted = 5 [json_name = "gas_wanted"];
inline void ResponseCheckTx::clear_gas_wanted() {
  gas_wanted_ = int64_t{0};
}
inline int64_t ResponseCheckTx::_internal_gas_wanted() const {
  return gas_wanted_;
}
inline int64_t ResponseCheckTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.gas_wanted)
  return _internal_gas_wanted();
}
inline void ResponseCheckTx::_internal_set_gas_wanted(int64_t value) {
  
  gas_wanted_ = value;
}
inline void ResponseCheckTx::set_gas_wanted(int64_t value) {
  _internal_set_gas_wanted(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.gas_wanted)
}

// int64 gas_used = 6 [json_name = "gas_used"];
inline void ResponseCheckTx::clear_gas_used() {
  gas_used_ = int64_t{0};
}
inline int64_t ResponseCheckTx::_internal_gas_used() const {
  return gas_used_;
}
inline int64_t ResponseCheckTx::gas_used() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.gas_used)
  return _internal_gas_used();
}
inline void ResponseCheckTx::_internal_set_gas_used(int64_t value) {
  
  gas_used_ = value;
}
inline void ResponseCheckTx::set_gas_used(int64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.gas_used)
}

// repeated .tendermint.abci.Event events = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseCheckTx::_internal_events_size() const {
  return events_.size();
}
inline int ResponseCheckTx::events_size() const {
  return _internal_events_size();
}
inline void ResponseCheckTx::clear_events() {
  events_.Clear();
}
inline ::tendermint::abci::Event* ResponseCheckTx::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseCheckTx::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseCheckTx.events)
  return &events_;
}
inline const ::tendermint::abci::Event& ResponseCheckTx::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::tendermint::abci::Event& ResponseCheckTx::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseCheckTx::_internal_add_events() {
  return events_.Add();
}
inline ::tendermint::abci::Event* ResponseCheckTx::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseCheckTx.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseCheckTx::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseCheckTx.events)
  return events_;
}

// string codespace = 8;
inline void ResponseCheckTx::clear_codespace() {
  codespace_.ClearToEmpty();
}
inline const std::string& ResponseCheckTx::codespace() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCheckTx.codespace)
  return _internal_codespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseCheckTx::set_codespace(ArgT0&& arg0, ArgT... args) {
 
 codespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCheckTx.codespace)
}
inline std::string* ResponseCheckTx::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCheckTx.codespace)
  return _s;
}
inline const std::string& ResponseCheckTx::_internal_codespace() const {
  return codespace_.Get();
}
inline void ResponseCheckTx::_internal_set_codespace(const std::string& value) {
  
  codespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::_internal_mutable_codespace() {
  
  return codespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseCheckTx::release_codespace() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCheckTx.codespace)
  return codespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseCheckTx::set_allocated_codespace(std::string* codespace) {
  if (codespace != nullptr) {
    
  } else {
    
  }
  codespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), codespace,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codespace_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codespace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCheckTx.codespace)
}

// -------------------------------------------------------------------

// ResponseDeliverTx

// uint32 code = 1;
inline void ResponseDeliverTx::clear_code() {
  code_ = 0u;
}
inline uint32_t ResponseDeliverTx::_internal_code() const {
  return code_;
}
inline uint32_t ResponseDeliverTx::code() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.code)
  return _internal_code();
}
inline void ResponseDeliverTx::_internal_set_code(uint32_t value) {
  
  code_ = value;
}
inline void ResponseDeliverTx::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.code)
}

// bytes data = 2;
inline void ResponseDeliverTx::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseDeliverTx::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.data)
}
inline std::string* ResponseDeliverTx::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.data)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_data() const {
  return data_.Get();
}
inline void ResponseDeliverTx::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseDeliverTx::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.data)
}

// string log = 3;
inline void ResponseDeliverTx::clear_log() {
  log_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::log() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseDeliverTx::set_log(ArgT0&& arg0, ArgT... args) {
 
 log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.log)
}
inline std::string* ResponseDeliverTx::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.log)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_log() const {
  return log_.Get();
}
inline void ResponseDeliverTx::_internal_set_log(const std::string& value) {
  
  log_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_log() {
  
  return log_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_log() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.log)
  return log_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseDeliverTx::set_allocated_log(std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.log)
}

// string info = 4;
inline void ResponseDeliverTx::clear_info() {
  info_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::info() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseDeliverTx::set_info(ArgT0&& arg0, ArgT... args) {
 
 info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.info)
}
inline std::string* ResponseDeliverTx::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.info)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_info() const {
  return info_.Get();
}
inline void ResponseDeliverTx::_internal_set_info(const std::string& value) {
  
  info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_info() {
  
  return info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_info() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.info)
  return info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseDeliverTx::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.info)
}

// int64 gas_wanted = 5 [json_name = "gas_wanted"];
inline void ResponseDeliverTx::clear_gas_wanted() {
  gas_wanted_ = int64_t{0};
}
inline int64_t ResponseDeliverTx::_internal_gas_wanted() const {
  return gas_wanted_;
}
inline int64_t ResponseDeliverTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.gas_wanted)
  return _internal_gas_wanted();
}
inline void ResponseDeliverTx::_internal_set_gas_wanted(int64_t value) {
  
  gas_wanted_ = value;
}
inline void ResponseDeliverTx::set_gas_wanted(int64_t value) {
  _internal_set_gas_wanted(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.gas_wanted)
}

// int64 gas_used = 6 [json_name = "gas_used"];
inline void ResponseDeliverTx::clear_gas_used() {
  gas_used_ = int64_t{0};
}
inline int64_t ResponseDeliverTx::_internal_gas_used() const {
  return gas_used_;
}
inline int64_t ResponseDeliverTx::gas_used() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.gas_used)
  return _internal_gas_used();
}
inline void ResponseDeliverTx::_internal_set_gas_used(int64_t value) {
  
  gas_used_ = value;
}
inline void ResponseDeliverTx::set_gas_used(int64_t value) {
  _internal_set_gas_used(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.gas_used)
}

// repeated .tendermint.abci.Event events = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseDeliverTx::_internal_events_size() const {
  return events_.size();
}
inline int ResponseDeliverTx::events_size() const {
  return _internal_events_size();
}
inline void ResponseDeliverTx::clear_events() {
  events_.Clear();
}
inline ::tendermint::abci::Event* ResponseDeliverTx::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseDeliverTx::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseDeliverTx.events)
  return &events_;
}
inline const ::tendermint::abci::Event& ResponseDeliverTx::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::tendermint::abci::Event& ResponseDeliverTx::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseDeliverTx::_internal_add_events() {
  return events_.Add();
}
inline ::tendermint::abci::Event* ResponseDeliverTx::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseDeliverTx.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseDeliverTx::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseDeliverTx.events)
  return events_;
}

// string codespace = 8;
inline void ResponseDeliverTx::clear_codespace() {
  codespace_.ClearToEmpty();
}
inline const std::string& ResponseDeliverTx::codespace() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseDeliverTx.codespace)
  return _internal_codespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseDeliverTx::set_codespace(ArgT0&& arg0, ArgT... args) {
 
 codespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseDeliverTx.codespace)
}
inline std::string* ResponseDeliverTx::mutable_codespace() {
  std::string* _s = _internal_mutable_codespace();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseDeliverTx.codespace)
  return _s;
}
inline const std::string& ResponseDeliverTx::_internal_codespace() const {
  return codespace_.Get();
}
inline void ResponseDeliverTx::_internal_set_codespace(const std::string& value) {
  
  codespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::_internal_mutable_codespace() {
  
  return codespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseDeliverTx::release_codespace() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseDeliverTx.codespace)
  return codespace_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseDeliverTx::set_allocated_codespace(std::string* codespace) {
  if (codespace != nullptr) {
    
  } else {
    
  }
  codespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), codespace,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codespace_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codespace_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseDeliverTx.codespace)
}

// -------------------------------------------------------------------

// ResponseEndBlock

// repeated .tendermint.abci.ValidatorUpdate validator_updates = 1 [(.gogoproto.nullable) = false];
inline int ResponseEndBlock::_internal_validator_updates_size() const {
  return validator_updates_.size();
}
inline int ResponseEndBlock::validator_updates_size() const {
  return _internal_validator_updates_size();
}
inline void ResponseEndBlock::clear_validator_updates() {
  validator_updates_.Clear();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseEndBlock::mutable_validator_updates(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEndBlock.validator_updates)
  return validator_updates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >*
ResponseEndBlock::mutable_validator_updates() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseEndBlock.validator_updates)
  return &validator_updates_;
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseEndBlock::_internal_validator_updates(int index) const {
  return validator_updates_.Get(index);
}
inline const ::tendermint::abci::ValidatorUpdate& ResponseEndBlock::validator_updates(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEndBlock.validator_updates)
  return _internal_validator_updates(index);
}
inline ::tendermint::abci::ValidatorUpdate* ResponseEndBlock::_internal_add_validator_updates() {
  return validator_updates_.Add();
}
inline ::tendermint::abci::ValidatorUpdate* ResponseEndBlock::add_validator_updates() {
  ::tendermint::abci::ValidatorUpdate* _add = _internal_add_validator_updates();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseEndBlock.validator_updates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::ValidatorUpdate >&
ResponseEndBlock::validator_updates() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseEndBlock.validator_updates)
  return validator_updates_;
}

// .tendermint.abci.ConsensusParams consensus_param_updates = 2;
inline bool ResponseEndBlock::_internal_has_consensus_param_updates() const {
  return this != internal_default_instance() && consensus_param_updates_ != nullptr;
}
inline bool ResponseEndBlock::has_consensus_param_updates() const {
  return _internal_has_consensus_param_updates();
}
inline void ResponseEndBlock::clear_consensus_param_updates() {
  if (GetArenaForAllocation() == nullptr && consensus_param_updates_ != nullptr) {
    delete consensus_param_updates_;
  }
  consensus_param_updates_ = nullptr;
}
inline const ::tendermint::abci::ConsensusParams& ResponseEndBlock::_internal_consensus_param_updates() const {
  const ::tendermint::abci::ConsensusParams* p = consensus_param_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::ConsensusParams&>(
      ::tendermint::abci::_ConsensusParams_default_instance_);
}
inline const ::tendermint::abci::ConsensusParams& ResponseEndBlock::consensus_param_updates() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEndBlock.consensus_param_updates)
  return _internal_consensus_param_updates();
}
inline void ResponseEndBlock::unsafe_arena_set_allocated_consensus_param_updates(
    ::tendermint::abci::ConsensusParams* consensus_param_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(consensus_param_updates_);
  }
  consensus_param_updates_ = consensus_param_updates;
  if (consensus_param_updates) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ResponseEndBlock.consensus_param_updates)
}
inline ::tendermint::abci::ConsensusParams* ResponseEndBlock::release_consensus_param_updates() {
  
  ::tendermint::abci::ConsensusParams* temp = consensus_param_updates_;
  consensus_param_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::ConsensusParams* ResponseEndBlock::unsafe_arena_release_consensus_param_updates() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseEndBlock.consensus_param_updates)
  
  ::tendermint::abci::ConsensusParams* temp = consensus_param_updates_;
  consensus_param_updates_ = nullptr;
  return temp;
}
inline ::tendermint::abci::ConsensusParams* ResponseEndBlock::_internal_mutable_consensus_param_updates() {
  
  if (consensus_param_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::ConsensusParams>(GetArenaForAllocation());
    consensus_param_updates_ = p;
  }
  return consensus_param_updates_;
}
inline ::tendermint::abci::ConsensusParams* ResponseEndBlock::mutable_consensus_param_updates() {
  ::tendermint::abci::ConsensusParams* _msg = _internal_mutable_consensus_param_updates();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEndBlock.consensus_param_updates)
  return _msg;
}
inline void ResponseEndBlock::set_allocated_consensus_param_updates(::tendermint::abci::ConsensusParams* consensus_param_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete consensus_param_updates_;
  }
  if (consensus_param_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::ConsensusParams>::GetOwningArena(consensus_param_updates);
    if (message_arena != submessage_arena) {
      consensus_param_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, consensus_param_updates, submessage_arena);
    }
    
  } else {
    
  }
  consensus_param_updates_ = consensus_param_updates;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseEndBlock.consensus_param_updates)
}

// repeated .tendermint.abci.Event events = 3 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "events,omitempty"];
inline int ResponseEndBlock::_internal_events_size() const {
  return events_.size();
}
inline int ResponseEndBlock::events_size() const {
  return _internal_events_size();
}
inline void ResponseEndBlock::clear_events() {
  events_.Clear();
}
inline ::tendermint::abci::Event* ResponseEndBlock::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseEndBlock.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >*
ResponseEndBlock::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseEndBlock.events)
  return &events_;
}
inline const ::tendermint::abci::Event& ResponseEndBlock::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::tendermint::abci::Event& ResponseEndBlock::events(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseEndBlock.events)
  return _internal_events(index);
}
inline ::tendermint::abci::Event* ResponseEndBlock::_internal_add_events() {
  return events_.Add();
}
inline ::tendermint::abci::Event* ResponseEndBlock::add_events() {
  ::tendermint::abci::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseEndBlock.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Event >&
ResponseEndBlock::events() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseEndBlock.events)
  return events_;
}

// -------------------------------------------------------------------

// ResponseCommit

// bytes data = 2;
inline void ResponseCommit::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ResponseCommit::data() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCommit.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseCommit::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCommit.data)
}
inline std::string* ResponseCommit::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseCommit.data)
  return _s;
}
inline const std::string& ResponseCommit::_internal_data() const {
  return data_.Get();
}
inline void ResponseCommit::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseCommit::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseCommit::release_data() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseCommit.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseCommit::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseCommit.data)
}

// int64 retain_height = 3;
inline void ResponseCommit::clear_retain_height() {
  retain_height_ = int64_t{0};
}
inline int64_t ResponseCommit::_internal_retain_height() const {
  return retain_height_;
}
inline int64_t ResponseCommit::retain_height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseCommit.retain_height)
  return _internal_retain_height();
}
inline void ResponseCommit::_internal_set_retain_height(int64_t value) {
  
  retain_height_ = value;
}
inline void ResponseCommit::set_retain_height(int64_t value) {
  _internal_set_retain_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseCommit.retain_height)
}

// -------------------------------------------------------------------

// ResponseListSnapshots

// repeated .tendermint.abci.Snapshot snapshots = 1;
inline int ResponseListSnapshots::_internal_snapshots_size() const {
  return snapshots_.size();
}
inline int ResponseListSnapshots::snapshots_size() const {
  return _internal_snapshots_size();
}
inline void ResponseListSnapshots::clear_snapshots() {
  snapshots_.Clear();
}
inline ::tendermint::abci::Snapshot* ResponseListSnapshots::mutable_snapshots(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseListSnapshots.snapshots)
  return snapshots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >*
ResponseListSnapshots::mutable_snapshots() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseListSnapshots.snapshots)
  return &snapshots_;
}
inline const ::tendermint::abci::Snapshot& ResponseListSnapshots::_internal_snapshots(int index) const {
  return snapshots_.Get(index);
}
inline const ::tendermint::abci::Snapshot& ResponseListSnapshots::snapshots(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseListSnapshots.snapshots)
  return _internal_snapshots(index);
}
inline ::tendermint::abci::Snapshot* ResponseListSnapshots::_internal_add_snapshots() {
  return snapshots_.Add();
}
inline ::tendermint::abci::Snapshot* ResponseListSnapshots::add_snapshots() {
  ::tendermint::abci::Snapshot* _add = _internal_add_snapshots();
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseListSnapshots.snapshots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::Snapshot >&
ResponseListSnapshots::snapshots() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseListSnapshots.snapshots)
  return snapshots_;
}

// -------------------------------------------------------------------

// ResponseOfferSnapshot

// .tendermint.abci.ResponseOfferSnapshot.Result result = 1;
inline void ResponseOfferSnapshot::clear_result() {
  result_ = 0;
}
inline ::tendermint::abci::ResponseOfferSnapshot_Result ResponseOfferSnapshot::_internal_result() const {
  return static_cast< ::tendermint::abci::ResponseOfferSnapshot_Result >(result_);
}
inline ::tendermint::abci::ResponseOfferSnapshot_Result ResponseOfferSnapshot::result() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseOfferSnapshot.result)
  return _internal_result();
}
inline void ResponseOfferSnapshot::_internal_set_result(::tendermint::abci::ResponseOfferSnapshot_Result value) {
  
  result_ = value;
}
inline void ResponseOfferSnapshot::set_result(::tendermint::abci::ResponseOfferSnapshot_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseOfferSnapshot.result)
}

// -------------------------------------------------------------------

// ResponseLoadSnapshotChunk

// bytes chunk = 1;
inline void ResponseLoadSnapshotChunk::clear_chunk() {
  chunk_.ClearToEmpty();
}
inline const std::string& ResponseLoadSnapshotChunk::chunk() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResponseLoadSnapshotChunk::set_chunk(ArgT0&& arg0, ArgT... args) {
 
 chunk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
}
inline std::string* ResponseLoadSnapshotChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
  return _s;
}
inline const std::string& ResponseLoadSnapshotChunk::_internal_chunk() const {
  return chunk_.Get();
}
inline void ResponseLoadSnapshotChunk::_internal_set_chunk(const std::string& value) {
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResponseLoadSnapshotChunk::_internal_mutable_chunk() {
  
  return chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResponseLoadSnapshotChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
  return chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResponseLoadSnapshotChunk::set_allocated_chunk(std::string* chunk) {
  if (chunk != nullptr) {
    
  } else {
    
  }
  chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chunk_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chunk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ResponseLoadSnapshotChunk.chunk)
}

// -------------------------------------------------------------------

// ResponseApplySnapshotChunk

// .tendermint.abci.ResponseApplySnapshotChunk.Result result = 1;
inline void ResponseApplySnapshotChunk::clear_result() {
  result_ = 0;
}
inline ::tendermint::abci::ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk::_internal_result() const {
  return static_cast< ::tendermint::abci::ResponseApplySnapshotChunk_Result >(result_);
}
inline ::tendermint::abci::ResponseApplySnapshotChunk_Result ResponseApplySnapshotChunk::result() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseApplySnapshotChunk.result)
  return _internal_result();
}
inline void ResponseApplySnapshotChunk::_internal_set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value) {
  
  result_ = value;
}
inline void ResponseApplySnapshotChunk::set_result(::tendermint::abci::ResponseApplySnapshotChunk_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.result)
}

// repeated uint32 refetch_chunks = 2;
inline int ResponseApplySnapshotChunk::_internal_refetch_chunks_size() const {
  return refetch_chunks_.size();
}
inline int ResponseApplySnapshotChunk::refetch_chunks_size() const {
  return _internal_refetch_chunks_size();
}
inline void ResponseApplySnapshotChunk::clear_refetch_chunks() {
  refetch_chunks_.Clear();
}
inline uint32_t ResponseApplySnapshotChunk::_internal_refetch_chunks(int index) const {
  return refetch_chunks_.Get(index);
}
inline uint32_t ResponseApplySnapshotChunk::refetch_chunks(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
  return _internal_refetch_chunks(index);
}
inline void ResponseApplySnapshotChunk::set_refetch_chunks(int index, uint32_t value) {
  refetch_chunks_.Set(index, value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
}
inline void ResponseApplySnapshotChunk::_internal_add_refetch_chunks(uint32_t value) {
  refetch_chunks_.Add(value);
}
inline void ResponseApplySnapshotChunk::add_refetch_chunks(uint32_t value) {
  _internal_add_refetch_chunks(value);
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ResponseApplySnapshotChunk::_internal_refetch_chunks() const {
  return refetch_chunks_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ResponseApplySnapshotChunk::refetch_chunks() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
  return _internal_refetch_chunks();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ResponseApplySnapshotChunk::_internal_mutable_refetch_chunks() {
  return &refetch_chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ResponseApplySnapshotChunk::mutable_refetch_chunks() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseApplySnapshotChunk.refetch_chunks)
  return _internal_mutable_refetch_chunks();
}

// repeated string reject_senders = 3;
inline int ResponseApplySnapshotChunk::_internal_reject_senders_size() const {
  return reject_senders_.size();
}
inline int ResponseApplySnapshotChunk::reject_senders_size() const {
  return _internal_reject_senders_size();
}
inline void ResponseApplySnapshotChunk::clear_reject_senders() {
  reject_senders_.Clear();
}
inline std::string* ResponseApplySnapshotChunk::add_reject_senders() {
  std::string* _s = _internal_add_reject_senders();
  // @@protoc_insertion_point(field_add_mutable:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return _s;
}
inline const std::string& ResponseApplySnapshotChunk::_internal_reject_senders(int index) const {
  return reject_senders_.Get(index);
}
inline const std::string& ResponseApplySnapshotChunk::reject_senders(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return _internal_reject_senders(index);
}
inline std::string* ResponseApplySnapshotChunk::mutable_reject_senders(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return reject_senders_.Mutable(index);
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, const std::string& value) {
  reject_senders_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, std::string&& value) {
  reject_senders_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  reject_senders_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::set_reject_senders(int index, const char* value, size_t size) {
  reject_senders_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline std::string* ResponseApplySnapshotChunk::_internal_add_reject_senders() {
  return reject_senders_.Add();
}
inline void ResponseApplySnapshotChunk::add_reject_senders(const std::string& value) {
  reject_senders_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(std::string&& value) {
  reject_senders_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  reject_senders_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline void ResponseApplySnapshotChunk::add_reject_senders(const char* value, size_t size) {
  reject_senders_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ResponseApplySnapshotChunk::reject_senders() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return reject_senders_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ResponseApplySnapshotChunk::mutable_reject_senders() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.ResponseApplySnapshotChunk.reject_senders)
  return &reject_senders_;
}

// -------------------------------------------------------------------

// ConsensusParams

// .tendermint.abci.BlockParams block = 1;
inline bool ConsensusParams::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool ConsensusParams::has_block() const {
  return _internal_has_block();
}
inline void ConsensusParams::clear_block() {
  if (GetArenaForAllocation() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::tendermint::abci::BlockParams& ConsensusParams::_internal_block() const {
  const ::tendermint::abci::BlockParams* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::BlockParams&>(
      ::tendermint::abci::_BlockParams_default_instance_);
}
inline const ::tendermint::abci::BlockParams& ConsensusParams::block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ConsensusParams.block)
  return _internal_block();
}
inline void ConsensusParams::unsafe_arena_set_allocated_block(
    ::tendermint::abci::BlockParams* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ConsensusParams.block)
}
inline ::tendermint::abci::BlockParams* ConsensusParams::release_block() {
  
  ::tendermint::abci::BlockParams* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::BlockParams* ConsensusParams::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ConsensusParams.block)
  
  ::tendermint::abci::BlockParams* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::tendermint::abci::BlockParams* ConsensusParams::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::BlockParams>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::tendermint::abci::BlockParams* ConsensusParams::mutable_block() {
  ::tendermint::abci::BlockParams* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ConsensusParams.block)
  return _msg;
}
inline void ConsensusParams::set_allocated_block(::tendermint::abci::BlockParams* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::BlockParams>::GetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ConsensusParams.block)
}

// .tendermint.types.EvidenceParams evidence = 2;
inline bool ConsensusParams::_internal_has_evidence() const {
  return this != internal_default_instance() && evidence_ != nullptr;
}
inline bool ConsensusParams::has_evidence() const {
  return _internal_has_evidence();
}
inline const ::tendermint::types::EvidenceParams& ConsensusParams::_internal_evidence() const {
  const ::tendermint::types::EvidenceParams* p = evidence_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::EvidenceParams&>(
      ::tendermint::types::_EvidenceParams_default_instance_);
}
inline const ::tendermint::types::EvidenceParams& ConsensusParams::evidence() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ConsensusParams.evidence)
  return _internal_evidence();
}
inline void ConsensusParams::unsafe_arena_set_allocated_evidence(
    ::tendermint::types::EvidenceParams* evidence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(evidence_);
  }
  evidence_ = evidence;
  if (evidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ConsensusParams.evidence)
}
inline ::tendermint::types::EvidenceParams* ConsensusParams::release_evidence() {
  
  ::tendermint::types::EvidenceParams* temp = evidence_;
  evidence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::EvidenceParams* ConsensusParams::unsafe_arena_release_evidence() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ConsensusParams.evidence)
  
  ::tendermint::types::EvidenceParams* temp = evidence_;
  evidence_ = nullptr;
  return temp;
}
inline ::tendermint::types::EvidenceParams* ConsensusParams::_internal_mutable_evidence() {
  
  if (evidence_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::EvidenceParams>(GetArenaForAllocation());
    evidence_ = p;
  }
  return evidence_;
}
inline ::tendermint::types::EvidenceParams* ConsensusParams::mutable_evidence() {
  ::tendermint::types::EvidenceParams* _msg = _internal_mutable_evidence();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ConsensusParams.evidence)
  return _msg;
}
inline void ConsensusParams::set_allocated_evidence(::tendermint::types::EvidenceParams* evidence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(evidence_);
  }
  if (evidence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(evidence));
    if (message_arena != submessage_arena) {
      evidence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, evidence, submessage_arena);
    }
    
  } else {
    
  }
  evidence_ = evidence;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ConsensusParams.evidence)
}

// .tendermint.types.ValidatorParams validator = 3;
inline bool ConsensusParams::_internal_has_validator() const {
  return this != internal_default_instance() && validator_ != nullptr;
}
inline bool ConsensusParams::has_validator() const {
  return _internal_has_validator();
}
inline const ::tendermint::types::ValidatorParams& ConsensusParams::_internal_validator() const {
  const ::tendermint::types::ValidatorParams* p = validator_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::ValidatorParams&>(
      ::tendermint::types::_ValidatorParams_default_instance_);
}
inline const ::tendermint::types::ValidatorParams& ConsensusParams::validator() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ConsensusParams.validator)
  return _internal_validator();
}
inline void ConsensusParams::unsafe_arena_set_allocated_validator(
    ::tendermint::types::ValidatorParams* validator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(validator_);
  }
  validator_ = validator;
  if (validator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ConsensusParams.validator)
}
inline ::tendermint::types::ValidatorParams* ConsensusParams::release_validator() {
  
  ::tendermint::types::ValidatorParams* temp = validator_;
  validator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::ValidatorParams* ConsensusParams::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ConsensusParams.validator)
  
  ::tendermint::types::ValidatorParams* temp = validator_;
  validator_ = nullptr;
  return temp;
}
inline ::tendermint::types::ValidatorParams* ConsensusParams::_internal_mutable_validator() {
  
  if (validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::ValidatorParams>(GetArenaForAllocation());
    validator_ = p;
  }
  return validator_;
}
inline ::tendermint::types::ValidatorParams* ConsensusParams::mutable_validator() {
  ::tendermint::types::ValidatorParams* _msg = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ConsensusParams.validator)
  return _msg;
}
inline void ConsensusParams::set_allocated_validator(::tendermint::types::ValidatorParams* validator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(validator_);
  }
  if (validator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(validator));
    if (message_arena != submessage_arena) {
      validator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    
  } else {
    
  }
  validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ConsensusParams.validator)
}

// .tendermint.types.VersionParams version = 4;
inline bool ConsensusParams::_internal_has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline bool ConsensusParams::has_version() const {
  return _internal_has_version();
}
inline const ::tendermint::types::VersionParams& ConsensusParams::_internal_version() const {
  const ::tendermint::types::VersionParams* p = version_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::types::VersionParams&>(
      ::tendermint::types::_VersionParams_default_instance_);
}
inline const ::tendermint::types::VersionParams& ConsensusParams::version() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ConsensusParams.version)
  return _internal_version();
}
inline void ConsensusParams::unsafe_arena_set_allocated_version(
    ::tendermint::types::VersionParams* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ConsensusParams.version)
}
inline ::tendermint::types::VersionParams* ConsensusParams::release_version() {
  
  ::tendermint::types::VersionParams* temp = version_;
  version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::types::VersionParams* ConsensusParams::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ConsensusParams.version)
  
  ::tendermint::types::VersionParams* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::tendermint::types::VersionParams* ConsensusParams::_internal_mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::types::VersionParams>(GetArenaForAllocation());
    version_ = p;
  }
  return version_;
}
inline ::tendermint::types::VersionParams* ConsensusParams::mutable_version() {
  ::tendermint::types::VersionParams* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ConsensusParams.version)
  return _msg;
}
inline void ConsensusParams::set_allocated_version(::tendermint::types::VersionParams* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version));
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ConsensusParams.version)
}

// -------------------------------------------------------------------

// BlockParams

// int64 max_bytes = 1;
inline void BlockParams::clear_max_bytes() {
  max_bytes_ = int64_t{0};
}
inline int64_t BlockParams::_internal_max_bytes() const {
  return max_bytes_;
}
inline int64_t BlockParams::max_bytes() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.BlockParams.max_bytes)
  return _internal_max_bytes();
}
inline void BlockParams::_internal_set_max_bytes(int64_t value) {
  
  max_bytes_ = value;
}
inline void BlockParams::set_max_bytes(int64_t value) {
  _internal_set_max_bytes(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.BlockParams.max_bytes)
}

// int64 max_gas = 2;
inline void BlockParams::clear_max_gas() {
  max_gas_ = int64_t{0};
}
inline int64_t BlockParams::_internal_max_gas() const {
  return max_gas_;
}
inline int64_t BlockParams::max_gas() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.BlockParams.max_gas)
  return _internal_max_gas();
}
inline void BlockParams::_internal_set_max_gas(int64_t value) {
  
  max_gas_ = value;
}
inline void BlockParams::set_max_gas(int64_t value) {
  _internal_set_max_gas(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.BlockParams.max_gas)
}

// -------------------------------------------------------------------

// LastCommitInfo

// int32 round = 1;
inline void LastCommitInfo::clear_round() {
  round_ = 0;
}
inline int32_t LastCommitInfo::_internal_round() const {
  return round_;
}
inline int32_t LastCommitInfo::round() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.LastCommitInfo.round)
  return _internal_round();
}
inline void LastCommitInfo::_internal_set_round(int32_t value) {
  
  round_ = value;
}
inline void LastCommitInfo::set_round(int32_t value) {
  _internal_set_round(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.LastCommitInfo.round)
}

// repeated .tendermint.abci.VoteInfo votes = 2 [(.gogoproto.nullable) = false];
inline int LastCommitInfo::_internal_votes_size() const {
  return votes_.size();
}
inline int LastCommitInfo::votes_size() const {
  return _internal_votes_size();
}
inline void LastCommitInfo::clear_votes() {
  votes_.Clear();
}
inline ::tendermint::abci::VoteInfo* LastCommitInfo::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.LastCommitInfo.votes)
  return votes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >*
LastCommitInfo::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.LastCommitInfo.votes)
  return &votes_;
}
inline const ::tendermint::abci::VoteInfo& LastCommitInfo::_internal_votes(int index) const {
  return votes_.Get(index);
}
inline const ::tendermint::abci::VoteInfo& LastCommitInfo::votes(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.LastCommitInfo.votes)
  return _internal_votes(index);
}
inline ::tendermint::abci::VoteInfo* LastCommitInfo::_internal_add_votes() {
  return votes_.Add();
}
inline ::tendermint::abci::VoteInfo* LastCommitInfo::add_votes() {
  ::tendermint::abci::VoteInfo* _add = _internal_add_votes();
  // @@protoc_insertion_point(field_add:tendermint.abci.LastCommitInfo.votes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::VoteInfo >&
LastCommitInfo::votes() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.LastCommitInfo.votes)
  return votes_;
}

// -------------------------------------------------------------------

// Event

// string type = 1;
inline void Event::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Event.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Event.type)
}
inline std::string* Event::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Event.type)
  return _s;
}
inline const std::string& Event::_internal_type() const {
  return type_.Get();
}
inline void Event::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Event.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Event.type)
}

// repeated .tendermint.abci.EventAttribute attributes = 2 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "attributes,omitempty"];
inline int Event::_internal_attributes_size() const {
  return attributes_.size();
}
inline int Event::attributes_size() const {
  return _internal_attributes_size();
}
inline void Event::clear_attributes() {
  attributes_.Clear();
}
inline ::tendermint::abci::EventAttribute* Event::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Event.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >*
Event::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:tendermint.abci.Event.attributes)
  return &attributes_;
}
inline const ::tendermint::abci::EventAttribute& Event::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::tendermint::abci::EventAttribute& Event::attributes(int index) const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Event.attributes)
  return _internal_attributes(index);
}
inline ::tendermint::abci::EventAttribute* Event::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::tendermint::abci::EventAttribute* Event::add_attributes() {
  ::tendermint::abci::EventAttribute* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:tendermint.abci.Event.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tendermint::abci::EventAttribute >&
Event::attributes() const {
  // @@protoc_insertion_point(field_list:tendermint.abci.Event.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// EventAttribute

// bytes key = 1;
inline void EventAttribute::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& EventAttribute::key() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.EventAttribute.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventAttribute::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.EventAttribute.key)
}
inline std::string* EventAttribute::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.EventAttribute.key)
  return _s;
}
inline const std::string& EventAttribute::_internal_key() const {
  return key_.Get();
}
inline void EventAttribute::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventAttribute::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventAttribute::release_key() {
  // @@protoc_insertion_point(field_release:tendermint.abci.EventAttribute.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventAttribute::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.EventAttribute.key)
}

// bytes value = 2;
inline void EventAttribute::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& EventAttribute::value() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.EventAttribute.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventAttribute::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.EventAttribute.value)
}
inline std::string* EventAttribute::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.EventAttribute.value)
  return _s;
}
inline const std::string& EventAttribute::_internal_value() const {
  return value_.Get();
}
inline void EventAttribute::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventAttribute::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventAttribute::release_value() {
  // @@protoc_insertion_point(field_release:tendermint.abci.EventAttribute.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventAttribute::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.EventAttribute.value)
}

// bool index = 3;
inline void EventAttribute::clear_index() {
  index_ = false;
}
inline bool EventAttribute::_internal_index() const {
  return index_;
}
inline bool EventAttribute::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.EventAttribute.index)
  return _internal_index();
}
inline void EventAttribute::_internal_set_index(bool value) {
  
  index_ = value;
}
inline void EventAttribute::set_index(bool value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.EventAttribute.index)
}

// -------------------------------------------------------------------

// TxResult

// int64 height = 1;
inline void TxResult::clear_height() {
  height_ = int64_t{0};
}
inline int64_t TxResult::_internal_height() const {
  return height_;
}
inline int64_t TxResult::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.height)
  return _internal_height();
}
inline void TxResult::_internal_set_height(int64_t value) {
  
  height_ = value;
}
inline void TxResult::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.TxResult.height)
}

// uint32 index = 2;
inline void TxResult::clear_index() {
  index_ = 0u;
}
inline uint32_t TxResult::_internal_index() const {
  return index_;
}
inline uint32_t TxResult::index() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.index)
  return _internal_index();
}
inline void TxResult::_internal_set_index(uint32_t value) {
  
  index_ = value;
}
inline void TxResult::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.TxResult.index)
}

// bytes tx = 3;
inline void TxResult::clear_tx() {
  tx_.ClearToEmpty();
}
inline const std::string& TxResult::tx() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxResult::set_tx(ArgT0&& arg0, ArgT... args) {
 
 tx_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.TxResult.tx)
}
inline std::string* TxResult::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.TxResult.tx)
  return _s;
}
inline const std::string& TxResult::_internal_tx() const {
  return tx_.Get();
}
inline void TxResult::_internal_set_tx(const std::string& value) {
  
  tx_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TxResult::_internal_mutable_tx() {
  
  return tx_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TxResult::release_tx() {
  // @@protoc_insertion_point(field_release:tendermint.abci.TxResult.tx)
  return tx_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TxResult::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  tx_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tx,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tx_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tx_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.TxResult.tx)
}

// .tendermint.abci.ResponseDeliverTx result = 4 [(.gogoproto.nullable) = false];
inline bool TxResult::_internal_has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline bool TxResult::has_result() const {
  return _internal_has_result();
}
inline void TxResult::clear_result() {
  if (GetArenaForAllocation() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::tendermint::abci::ResponseDeliverTx& TxResult::_internal_result() const {
  const ::tendermint::abci::ResponseDeliverTx* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::ResponseDeliverTx&>(
      ::tendermint::abci::_ResponseDeliverTx_default_instance_);
}
inline const ::tendermint::abci::ResponseDeliverTx& TxResult::result() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.TxResult.result)
  return _internal_result();
}
inline void TxResult::unsafe_arena_set_allocated_result(
    ::tendermint::abci::ResponseDeliverTx* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.TxResult.result)
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::release_result() {
  
  ::tendermint::abci::ResponseDeliverTx* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:tendermint.abci.TxResult.result)
  
  ::tendermint::abci::ResponseDeliverTx* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::_internal_mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::ResponseDeliverTx>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::tendermint::abci::ResponseDeliverTx* TxResult::mutable_result() {
  ::tendermint::abci::ResponseDeliverTx* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.TxResult.result)
  return _msg;
}
inline void TxResult::set_allocated_result(::tendermint::abci::ResponseDeliverTx* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::ResponseDeliverTx>::GetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.TxResult.result)
}

// -------------------------------------------------------------------

// Validator

// bytes address = 1;
inline void Validator::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& Validator::address() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Validator.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Validator::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Validator.address)
}
inline std::string* Validator::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Validator.address)
  return _s;
}
inline const std::string& Validator::_internal_address() const {
  return address_.Get();
}
inline void Validator::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Validator::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Validator::release_address() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Validator.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Validator::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Validator.address)
}

// int64 power = 3;
inline void Validator::clear_power() {
  power_ = int64_t{0};
}
inline int64_t Validator::_internal_power() const {
  return power_;
}
inline int64_t Validator::power() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Validator.power)
  return _internal_power();
}
inline void Validator::_internal_set_power(int64_t value) {
  
  power_ = value;
}
inline void Validator::set_power(int64_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Validator.power)
}

// -------------------------------------------------------------------

// ValidatorUpdate

// .tendermint.crypto.PublicKey pub_key = 1 [(.gogoproto.nullable) = false];
inline bool ValidatorUpdate::_internal_has_pub_key() const {
  return this != internal_default_instance() && pub_key_ != nullptr;
}
inline bool ValidatorUpdate::has_pub_key() const {
  return _internal_has_pub_key();
}
inline const ::tendermint::crypto::PublicKey& ValidatorUpdate::_internal_pub_key() const {
  const ::tendermint::crypto::PublicKey* p = pub_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::crypto::PublicKey&>(
      ::tendermint::crypto::_PublicKey_default_instance_);
}
inline const ::tendermint::crypto::PublicKey& ValidatorUpdate::pub_key() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ValidatorUpdate.pub_key)
  return _internal_pub_key();
}
inline void ValidatorUpdate::unsafe_arena_set_allocated_pub_key(
    ::tendermint::crypto::PublicKey* pub_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key_);
  }
  pub_key_ = pub_key;
  if (pub_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.ValidatorUpdate.pub_key)
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::release_pub_key() {
  
  ::tendermint::crypto::PublicKey* temp = pub_key_;
  pub_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::unsafe_arena_release_pub_key() {
  // @@protoc_insertion_point(field_release:tendermint.abci.ValidatorUpdate.pub_key)
  
  ::tendermint::crypto::PublicKey* temp = pub_key_;
  pub_key_ = nullptr;
  return temp;
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::_internal_mutable_pub_key() {
  
  if (pub_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::crypto::PublicKey>(GetArenaForAllocation());
    pub_key_ = p;
  }
  return pub_key_;
}
inline ::tendermint::crypto::PublicKey* ValidatorUpdate::mutable_pub_key() {
  ::tendermint::crypto::PublicKey* _msg = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.ValidatorUpdate.pub_key)
  return _msg;
}
inline void ValidatorUpdate::set_allocated_pub_key(::tendermint::crypto::PublicKey* pub_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key_);
  }
  if (pub_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pub_key));
    if (message_arena != submessage_arena) {
      pub_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pub_key, submessage_arena);
    }
    
  } else {
    
  }
  pub_key_ = pub_key;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.ValidatorUpdate.pub_key)
}

// int64 power = 2;
inline void ValidatorUpdate::clear_power() {
  power_ = int64_t{0};
}
inline int64_t ValidatorUpdate::_internal_power() const {
  return power_;
}
inline int64_t ValidatorUpdate::power() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.ValidatorUpdate.power)
  return _internal_power();
}
inline void ValidatorUpdate::_internal_set_power(int64_t value) {
  
  power_ = value;
}
inline void ValidatorUpdate::set_power(int64_t value) {
  _internal_set_power(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.ValidatorUpdate.power)
}

// -------------------------------------------------------------------

// VoteInfo

// .tendermint.abci.Validator validator = 1 [(.gogoproto.nullable) = false];
inline bool VoteInfo::_internal_has_validator() const {
  return this != internal_default_instance() && validator_ != nullptr;
}
inline bool VoteInfo::has_validator() const {
  return _internal_has_validator();
}
inline void VoteInfo::clear_validator() {
  if (GetArenaForAllocation() == nullptr && validator_ != nullptr) {
    delete validator_;
  }
  validator_ = nullptr;
}
inline const ::tendermint::abci::Validator& VoteInfo::_internal_validator() const {
  const ::tendermint::abci::Validator* p = validator_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::Validator&>(
      ::tendermint::abci::_Validator_default_instance_);
}
inline const ::tendermint::abci::Validator& VoteInfo::validator() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.VoteInfo.validator)
  return _internal_validator();
}
inline void VoteInfo::unsafe_arena_set_allocated_validator(
    ::tendermint::abci::Validator* validator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(validator_);
  }
  validator_ = validator;
  if (validator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.VoteInfo.validator)
}
inline ::tendermint::abci::Validator* VoteInfo::release_validator() {
  
  ::tendermint::abci::Validator* temp = validator_;
  validator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::Validator* VoteInfo::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_release:tendermint.abci.VoteInfo.validator)
  
  ::tendermint::abci::Validator* temp = validator_;
  validator_ = nullptr;
  return temp;
}
inline ::tendermint::abci::Validator* VoteInfo::_internal_mutable_validator() {
  
  if (validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::Validator>(GetArenaForAllocation());
    validator_ = p;
  }
  return validator_;
}
inline ::tendermint::abci::Validator* VoteInfo::mutable_validator() {
  ::tendermint::abci::Validator* _msg = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.VoteInfo.validator)
  return _msg;
}
inline void VoteInfo::set_allocated_validator(::tendermint::abci::Validator* validator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete validator_;
  }
  if (validator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::Validator>::GetOwningArena(validator);
    if (message_arena != submessage_arena) {
      validator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    
  } else {
    
  }
  validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.VoteInfo.validator)
}

// bool signed_last_block = 2;
inline void VoteInfo::clear_signed_last_block() {
  signed_last_block_ = false;
}
inline bool VoteInfo::_internal_signed_last_block() const {
  return signed_last_block_;
}
inline bool VoteInfo::signed_last_block() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.VoteInfo.signed_last_block)
  return _internal_signed_last_block();
}
inline void VoteInfo::_internal_set_signed_last_block(bool value) {
  
  signed_last_block_ = value;
}
inline void VoteInfo::set_signed_last_block(bool value) {
  _internal_set_signed_last_block(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.VoteInfo.signed_last_block)
}

// -------------------------------------------------------------------

// Evidence

// .tendermint.abci.EvidenceType type = 1;
inline void Evidence::clear_type() {
  type_ = 0;
}
inline ::tendermint::abci::EvidenceType Evidence::_internal_type() const {
  return static_cast< ::tendermint::abci::EvidenceType >(type_);
}
inline ::tendermint::abci::EvidenceType Evidence::type() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Evidence.type)
  return _internal_type();
}
inline void Evidence::_internal_set_type(::tendermint::abci::EvidenceType value) {
  
  type_ = value;
}
inline void Evidence::set_type(::tendermint::abci::EvidenceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Evidence.type)
}

// .tendermint.abci.Validator validator = 2 [(.gogoproto.nullable) = false];
inline bool Evidence::_internal_has_validator() const {
  return this != internal_default_instance() && validator_ != nullptr;
}
inline bool Evidence::has_validator() const {
  return _internal_has_validator();
}
inline void Evidence::clear_validator() {
  if (GetArenaForAllocation() == nullptr && validator_ != nullptr) {
    delete validator_;
  }
  validator_ = nullptr;
}
inline const ::tendermint::abci::Validator& Evidence::_internal_validator() const {
  const ::tendermint::abci::Validator* p = validator_;
  return p != nullptr ? *p : reinterpret_cast<const ::tendermint::abci::Validator&>(
      ::tendermint::abci::_Validator_default_instance_);
}
inline const ::tendermint::abci::Validator& Evidence::validator() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Evidence.validator)
  return _internal_validator();
}
inline void Evidence::unsafe_arena_set_allocated_validator(
    ::tendermint::abci::Validator* validator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(validator_);
  }
  validator_ = validator;
  if (validator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Evidence.validator)
}
inline ::tendermint::abci::Validator* Evidence::release_validator() {
  
  ::tendermint::abci::Validator* temp = validator_;
  validator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tendermint::abci::Validator* Evidence::unsafe_arena_release_validator() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Evidence.validator)
  
  ::tendermint::abci::Validator* temp = validator_;
  validator_ = nullptr;
  return temp;
}
inline ::tendermint::abci::Validator* Evidence::_internal_mutable_validator() {
  
  if (validator_ == nullptr) {
    auto* p = CreateMaybeMessage<::tendermint::abci::Validator>(GetArenaForAllocation());
    validator_ = p;
  }
  return validator_;
}
inline ::tendermint::abci::Validator* Evidence::mutable_validator() {
  ::tendermint::abci::Validator* _msg = _internal_mutable_validator();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Evidence.validator)
  return _msg;
}
inline void Evidence::set_allocated_validator(::tendermint::abci::Validator* validator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete validator_;
  }
  if (validator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::tendermint::abci::Validator>::GetOwningArena(validator);
    if (message_arena != submessage_arena) {
      validator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, validator, submessage_arena);
    }
    
  } else {
    
  }
  validator_ = validator;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Evidence.validator)
}

// int64 height = 3;
inline void Evidence::clear_height() {
  height_ = int64_t{0};
}
inline int64_t Evidence::_internal_height() const {
  return height_;
}
inline int64_t Evidence::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Evidence.height)
  return _internal_height();
}
inline void Evidence::_internal_set_height(int64_t value) {
  
  height_ = value;
}
inline void Evidence::set_height(int64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Evidence.height)
}

// .google.protobuf.Timestamp time = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Evidence::_internal_has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline bool Evidence::has_time() const {
  return _internal_has_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Evidence::_internal_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Evidence::time() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Evidence.time)
  return _internal_time();
}
inline void Evidence::unsafe_arena_set_allocated_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tendermint.abci.Evidence.time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Evidence::release_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Evidence::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Evidence.time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Evidence::_internal_mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Evidence::mutable_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Evidence.time)
  return _msg;
}
inline void Evidence::set_allocated_time(::PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Evidence.time)
}

// int64 total_voting_power = 5;
inline void Evidence::clear_total_voting_power() {
  total_voting_power_ = int64_t{0};
}
inline int64_t Evidence::_internal_total_voting_power() const {
  return total_voting_power_;
}
inline int64_t Evidence::total_voting_power() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Evidence.total_voting_power)
  return _internal_total_voting_power();
}
inline void Evidence::_internal_set_total_voting_power(int64_t value) {
  
  total_voting_power_ = value;
}
inline void Evidence::set_total_voting_power(int64_t value) {
  _internal_set_total_voting_power(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Evidence.total_voting_power)
}

// -------------------------------------------------------------------

// Snapshot

// uint64 height = 1;
inline void Snapshot::clear_height() {
  height_ = uint64_t{0u};
}
inline uint64_t Snapshot::_internal_height() const {
  return height_;
}
inline uint64_t Snapshot::height() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.height)
  return _internal_height();
}
inline void Snapshot::_internal_set_height(uint64_t value) {
  
  height_ = value;
}
inline void Snapshot::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.height)
}

// uint32 format = 2;
inline void Snapshot::clear_format() {
  format_ = 0u;
}
inline uint32_t Snapshot::_internal_format() const {
  return format_;
}
inline uint32_t Snapshot::format() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.format)
  return _internal_format();
}
inline void Snapshot::_internal_set_format(uint32_t value) {
  
  format_ = value;
}
inline void Snapshot::set_format(uint32_t value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.format)
}

// uint32 chunks = 3;
inline void Snapshot::clear_chunks() {
  chunks_ = 0u;
}
inline uint32_t Snapshot::_internal_chunks() const {
  return chunks_;
}
inline uint32_t Snapshot::chunks() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.chunks)
  return _internal_chunks();
}
inline void Snapshot::_internal_set_chunks(uint32_t value) {
  
  chunks_ = value;
}
inline void Snapshot::set_chunks(uint32_t value) {
  _internal_set_chunks(value);
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.chunks)
}

// bytes hash = 4;
inline void Snapshot::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& Snapshot::hash() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Snapshot::set_hash(ArgT0&& arg0, ArgT... args) {
 
 hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.hash)
}
inline std::string* Snapshot::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Snapshot.hash)
  return _s;
}
inline const std::string& Snapshot::_internal_hash() const {
  return hash_.Get();
}
inline void Snapshot::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Snapshot::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Snapshot::release_hash() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Snapshot.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Snapshot::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Snapshot.hash)
}

// bytes metadata = 5;
inline void Snapshot::clear_metadata() {
  metadata_.ClearToEmpty();
}
inline const std::string& Snapshot::metadata() const {
  // @@protoc_insertion_point(field_get:tendermint.abci.Snapshot.metadata)
  return _internal_metadata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Snapshot::set_metadata(ArgT0&& arg0, ArgT... args) {
 
 metadata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tendermint.abci.Snapshot.metadata)
}
inline std::string* Snapshot::mutable_metadata() {
  std::string* _s = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:tendermint.abci.Snapshot.metadata)
  return _s;
}
inline const std::string& Snapshot::_internal_metadata() const {
  return metadata_.Get();
}
inline void Snapshot::_internal_set_metadata(const std::string& value) {
  
  metadata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Snapshot::_internal_mutable_metadata() {
  
  return metadata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Snapshot::release_metadata() {
  // @@protoc_insertion_point(field_release:tendermint.abci.Snapshot.metadata)
  return metadata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Snapshot::set_allocated_metadata(std::string* metadata) {
  if (metadata != nullptr) {
    
  } else {
    
  }
  metadata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (metadata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    metadata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tendermint.abci.Snapshot.metadata)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace abci
}  // namespace tendermint

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tendermint::abci::ResponseOfferSnapshot_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tendermint::abci::ResponseOfferSnapshot_Result>() {
  return ::tendermint::abci::ResponseOfferSnapshot_Result_descriptor();
}
template <> struct is_proto_enum< ::tendermint::abci::ResponseApplySnapshotChunk_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tendermint::abci::ResponseApplySnapshotChunk_Result>() {
  return ::tendermint::abci::ResponseApplySnapshotChunk_Result_descriptor();
}
template <> struct is_proto_enum< ::tendermint::abci::CheckTxType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tendermint::abci::CheckTxType>() {
  return ::tendermint::abci::CheckTxType_descriptor();
}
template <> struct is_proto_enum< ::tendermint::abci::EvidenceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tendermint::abci::EvidenceType>() {
  return ::tendermint::abci::EvidenceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tendermint_2fabci_2ftypes_2eproto
